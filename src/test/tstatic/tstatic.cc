/*
 * tstatic.cc
 *
 * Ian Soboroff, NIST
 * June, 1994
 *
 * This tests static allocation of STEP entities, that is, not using the
 * Instance Manager.  We're just going to define some entities, give them
 * some data, and print them out.
 * Just for fun, this includes a small iterator for STEPentity's.  See the
 * file ../SEarritr.h for details.
 *
 */

#include "tests.h"

/* STEPentity* Iterator class definition */
#include "../SEarritr.h"

int main() {
    // This has to be done before anything else.  This initializes
    // all of the registry information for the schema you are using.
    // The SchemaInit() function is generated by exp2cxx... see
    // extern statement above.

    // This test creates a bunch of different entities, puts values in them,
    // prints the values out, links them to an array of entities, and then
    // outputs all the entities in STEP exchange format.

    // For specifics on the structure of the entity classes, see
    // the SdaiEXAMPLE_SCHEMA.h header file.

    const STEPentity * entArr[4];  // our array of entity pointers

    std::cout << "Creating an SdaiRectangle..." << std::endl;
    SdaiRectangle rect;
    rect.item_name_( "MyRect" );
    rect.item_color_( Color__orange );
    rect.number_of_sides_( 4 );
    rect.height_( 5 );
    rect.width_( 10 );
    std::cout << "Rectangle: (" << rect.opcode() << ") " << std::endl;
    std::cout << "  Name: " << rect.item_name_().c_str() << std::endl;
    std::cout << "  Color: " << rect.item_color_() << std::endl;
    std::cout << "  Sides: " << rect.number_of_sides_() << std::endl;
    std::cout << "  Height: " << rect.height_() << std::endl;
    std::cout << "  Width:  " << rect.width_() << std::endl;
    std::cout << std::endl;
    entArr[0] = &rect;

    std::cout << "Creating an SdaiSquare..." << std::endl;
    SdaiSquare square;
    square.item_name_( "MySquare" );
    square.item_color_( Color__green );
    square.number_of_sides_( 4 );
    square.height_( 3 );
    square.width_( 3 );
    std::cout << "Square: (" << square.opcode() << ") " << std::endl;
    std::cout << "  Name: " << square.item_name_().c_str() << std::endl;
    std::cout << "  Color: " << square.item_color_() << std::endl;
    std::cout << "  Sides: " << square.number_of_sides_() << std::endl;
    std::cout << "  Height: " << square.height_() << std::endl;
    std::cout << "  Width:  " << square.width_() << std::endl;
    std::cout << std::endl;
    entArr[1] = &square;

    std::cout << "Creating an SdaiTriangle..." << std::endl;
    SdaiTriangle tri;
    tri.item_name_( "MyTri" );
    tri.item_color_( Color__blue );
    tri.number_of_sides_( 3 );
    tri.side1_length_( 3 );
    tri.side2_length_( 4 );
    tri.side3_length_( 5 );
    std::cout << "Triangle: (" << tri.opcode() << ") " << std::endl;
    std::cout << "  Name: " << tri.item_name_().c_str() << std::endl;
    std::cout << "  Color: " << tri.item_color_() << std::endl;
    std::cout << "  Sides: " << tri.number_of_sides_() << std::endl;
    std::cout << "  Side 1: " << tri.side1_length_() << std::endl;
    std::cout << "  Side 2: " << tri.side2_length_() << std::endl;
    std::cout << "  Side 3: " << tri.side3_length_() << std::endl;
    std::cout << std::endl;
    entArr[2] = &tri;

    std::cout << "Creating an SdaiCircle..." << std::endl;
    SdaiCircle circ;
    circ.item_name_( "MyCirc" );
    circ.item_color_( Color__red );
    circ.number_of_sides_( 1 );
    circ.radius_( 15 );
    std::cout << "Circle: (" << circ.opcode() << ") " << std::endl;
    std::cout << "  Name: " << circ.item_name_().c_str() << std::endl;
    std::cout << "  Color: " << circ.item_color_() << std::endl;
    std::cout << "  Sides: " << circ.number_of_sides_() << std::endl;
    std::cout << "  Radius: " << circ.radius_() << std::endl;
    std::cout << std::endl;
    entArr[3] = &circ;

    std::cout << "And now, all entities in STEP Exchange Format!" << std::endl << std::endl;
    SEarrIterator SEitr( entArr, 4 );
    for( SEitr = 0; !SEitr; ++SEitr ) {
        SEitr()->STEPwrite( std::cout );
    }
}



