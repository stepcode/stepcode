/** \file p21read.cc
** 21-Jul-1995
** This code was developed with the support of the United States Government,
** and is not subject to copyright.

** This file contains a simple little program to read in a file and
** write it back out to a new file.  The purpose is to demonstrate the
** use of a Schema Class Library.  The name of the file to be read in
** can be supplied as a command line argument.  If no argument is
** provided, the program tries to read the file testfile.stp.  The
** name of the file to be output may also be provided, if no name is
** provided the file written out is called file.out
*/
#include <scl_cf.h>
extern void SchemaInit( class Registry & );
#include "scl_version_string.h"
#include <STEPfile.h>
#include <sdai.h>
#include <STEPattribute.h>
#include <ExpDict.h>
#include <Registry.h>
#include <errordesc.h>
#include <algorithm>
#include <string>
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif

#include <sc_getopt.h>

/**
 * Compare the schema names from the lib (generated by fedex_plus) and
 * the current exchange file. Both strings are converted to upper case
 * before comparison. If they are not identical, attempt to strip any
 * ASN.1 identifiers and compare again. Returns true for a match.
 */
bool compareOneSchName( std::string lib, std::string file ) {
    size_t b, e, ls, fs;
    b = lib.find_first_of( '\'' ) + 1;
    e = lib.find_last_of( '\'' );
    lib = lib.substr( b, e - b );
    std::transform( lib.begin(), lib.end(), lib.begin(), ::toupper );
    std::transform( file.begin(), file.end(), file.begin(), ::toupper );
    if( lib == file ) {
        return true;
    }

    //There are no spaces, unless there is an ASN.1 identifier. If
    //the strings don't already match, try to remove this identifier.
    ls = lib.find_first_of( ' ' );
    fs = file.find_first_of( ' ' );
    if( lib.substr( 0, ls ) == file.substr( 0, fs ) ) {
        return true;
    }
    std::cerr << "This pair of schema names do not match - " << lib << " and " << file << std::endl;
    return false;
}

/**
 * Loop through all available schemas and attributes, looking
 * for a match. If match not found, print error and exit(1)
 */
void checkSchemaName( Registry & reg, STEPfile & sf, bool ignoreErr ) {
    bool match = false;
    std::string sname;
    STEPattribute * attr;
    const Schema * sc;
    reg.ResetSchemas();
    //file id 3 is always the schema name
    SDAI_Application_instance * ai =
        sf.HeaderInstances()->FindFileId( 3 )->GetApplication_instance();
    while( ( attr = ai->NextAttribute() ) ) {
        attr->asStr( sname );
        while( ( sc = reg.NextSchema() ) ) {
            if( compareOneSchName( sname, sc->Name() ) ) {
                match = true;
                break;
            }
        }
        if( match ) {
            break;
        }
    }
    if( !match ) {
        std::cerr << "ERROR - schema name mismatch. Tried all available combinations." << std::endl;
        if( !ignoreErr ) {
            exit( 1 );
        }
    }
}

void printVersion( const char * exe ) {
    std::cout << exe << " build info: " << scl_version() << std::endl;
}

void printUse( const char * exe ) {
    std::cout << "p21read - read a STEP Part 21 exchange file using SCL, and write the data to another file." << std::endl;
    std::cout << "Syntax:  " << exe << " [-i] [-s] infile [outfile]" << std::endl;
    std::cout << "Use '-i' to ignore a schema name mismatch." << std::endl;
    std::cout << "Use '-m' to turn off memory info." << std::endl;
    std::cout << "Use '-s' for strict interpretation (attributes that are \"missing and required\" will cause errors)." << std::endl;
    std::cout << "Use '-v' to print the version info below and exit." << std::endl;
    std::cout << "Use '--' as the last argument if a file name starts with a dash." << std::endl;
    printVersion( exe );
    exit( 1 );
}

/// adapted from http://stackoverflow.com/questions/669438/how-to-get-memory-usage-at-run-time-in-c
/// virtMem and physMem are set to the virtual and physical memory use amounts, in kb.
void getMemUseKB( double& virtMem, double& physMem ) {
    using std::ios_base;
    using std::ifstream;
    using std::string;

    virtMem     = 0.0;
    physMem = 0.0;

#ifdef __linux__
    // 'file' stat seems to give the most reliable results
    ifstream stat_stream("/proc/self/stat",ios_base::in);

    // dummy vars for leading entries in stat that we don't care about
    string pid, comm, state, ppid, pgrp, session, tty_nr;
    string tpgid, flags, minflt, cminflt, majflt, cmajflt;
    string utime, stime, cutime, cstime, priority, nice;
    string O, itrealvalue, starttime;

    // the two fields we want
    unsigned long vsize;
    long rss;

    stat_stream >> pid >> comm >> state >> ppid >> pgrp >> session >> tty_nr
                >> tpgid >> flags >> minflt >> cminflt >> majflt >> cmajflt
                >> utime >> stime >> cutime >> cstime >> priority >> nice
                >> O >> itrealvalue >> starttime >> vsize >> rss; // don't care about the rest

//     stat_stream.close();

    long page_size_kb = sysconf(_SC_PAGE_SIZE) / 1024; // in case x86-64 is configured to use 2MB pages
    virtMem     = vsize / 1024.0;
    physMem = 1.0 * rss * page_size_kb;
#elif defined(__APPLE__)
    // http://stackoverflow.com/a/1911863/382458
#elif defined(__WIN32)
    // http://stackoverflow.com/a/282220/382458 and http://stackoverflow.com/a/64166/382458
#else
    #warning Unknown platform!
#endif //__linux__
}

int main( int argc, char * argv[] ) {
    bool ignoreErr = false;
    bool strict = false;
    bool memInfo = true;
    char c;
    double physMem, virtMem, preReadPhysMem, preReadVirtMem; //for memory monitoring

    if( argc > 4 || argc < 2 ) {
        printUse( argv[0] );
    }
    while( ( c = sc_getopt( argc, argv, "imsv" ) ) != -1 ) {
        switch( c ) {
            case 'i':
                ignoreErr = true;
                break;
            case 'm':
                memInfo = false;
                break;
            case 's':
                strict = true;
                break;
            case 'v':
                printVersion( argv[0] );
                exit( 0 );
            case '?':
            default:
                printUse( argv[0] );
        }
    }

    if( memInfo ) {
        getMemUseKB( virtMem, physMem );
        std::cout << "Memory used before initializing anything: Physical " << physMem << "kb, Virtual " << virtMem << "kb" << std::endl;
    }

    ///////////////////////////////////////////////////////////////////////////////
    // You have to initialize the schema before you do anything else.
    // This initializes all of the registry information for the schema you
    // plan to use.  The SchemaInit() function is generated by fedex_plus.
    // See the 'extern' stmt above.
    //
    // The registry is always going to be in memory.
    ///////////////////////////////////////////////////////////////////////////////
    Registry  registry( SchemaInit );
    InstMgr   instance_list;
    STEPfile  sfile( registry, instance_list, "", strict );
    char   *  flnm;

    if( memInfo ) {
        getMemUseKB( preReadVirtMem, preReadPhysMem );
        std::cout << "Memory used before ReadExchangeFile(): Physical " << preReadPhysMem << "kb, Virtual " << preReadVirtMem << "kb" << std::endl;
    }

    cout << argv[0] << ": load file ..." << endl;
    if( argc >= ( optind + 1 ) ) {
        flnm = argv[optind];
    } else {
        flnm = ( char * )"testfile.step";
    }
    sfile.ReadExchangeFile( flnm );
    if( sfile.Error().severity() < SEVERITY_USERMSG ) {
        sfile.Error().PrintContents( cout );
    }

    if( memInfo ) {
        getMemUseKB( virtMem, physMem );
        std::cout << "Memory used by ReadExchangeFile(): Physical " << physMem - preReadPhysMem << "kb, Virtual " << virtMem - preReadVirtMem << "kb" << std::endl;
    }

    if ( sfile.Error().severity() <= SEVERITY_INCOMPLETE ) {
        exit(1);
    }

    checkSchemaName( registry, sfile, ignoreErr );

    Severity readSev = sfile.Error().severity(); //otherwise, errors from reading will be wiped out by sfile.WriteExchangeFile()

    cout << argv[0] << ": write file ..." << endl;
    if( argc == optind + 2 ) {
        flnm = argv[optind + 1];
    } else {
        flnm = ( char * )"file.out";
    }
    sfile.WriteExchangeFile( flnm );
    if( sfile.Error().severity() < SEVERITY_USERMSG ) {
        sfile.Error().PrintContents( cout );
    }
    cout << argv[0] << ": " << flnm << " written"  << endl;

    if( ( sfile.Error().severity() <= SEVERITY_INCOMPLETE ) || ( readSev <= SEVERITY_INCOMPLETE ) ) { //lower is worse
        exit( 1 );
    }
}
