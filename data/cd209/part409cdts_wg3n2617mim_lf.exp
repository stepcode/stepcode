(*
$Id: mim_lf.exp,v 1.10 2010/09/22 14:41:47 lothartklein Exp $
WG12N2617 - ISO/CD - 10303-409 ap209_multidisciplinary_analysis_and_design - EXPRESS MIM LF
*)

SCHEMA Ap209_multidisciplinary_analysis_and_design_mim_LF;


CONSTANT
	dummy_gri : geometric_representation_item := representation_item('')||
                                   geometric_representation_item();


	dummy_tri : topological_representation_item := representation_item('')||
                   topological_representation_item();


	pre_defined_picture_representation_types : SET [0:?] OF STRING := [ 'JPEG', 'PNG', 'TIFF', 'BMP', 'GIF'];


	schema_prefix : STRING := 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.';


	the_binarys : elementary_space := make_elementary_space(es_binarys);


	the_booleans : elementary_space := make_elementary_space(es_booleans);


	the_complex_numbers : elementary_space := make_elementary_space(es_complex_numbers);


	the_complex_tuples : extended_tuple_space := make_extended_tuple_space(
    the_zero_tuple_space, the_complex_numbers);


	the_empty_maths_tuple : maths_tuple := [];


	the_empty_space : finite_space := make_finite_space([]);


	the_generics : elementary_space := make_elementary_space(es_generics);


	the_integer_tuples : extended_tuple_space := make_extended_tuple_space(
    the_zero_tuple_space, the_integers);


	the_integers : elementary_space := make_elementary_space(es_integers);


	the_logicals : elementary_space := make_elementary_space(es_logicals);


	the_maths_spaces : elementary_space := make_elementary_space(es_maths_spaces);


	the_neg1_one_interval : finite_real_interval := make_finite_real_interval(
    -1.0, closed, 1.0, closed);


	the_neghalfpi_halfpi_interval : finite_real_interval := make_finite_real_interval(
    -0.5*pi, closed, 0.5*pi, closed);


	the_negpi_pi_interval : finite_real_interval := make_finite_real_interval(
    -pi, open, pi, closed);


	the_nonnegative_reals : real_interval_from_min := make_real_interval_from_min(0.0, closed);


	the_numbers : elementary_space := make_elementary_space(es_numbers);


	the_real_tuples : extended_tuple_space := make_extended_tuple_space(
    the_zero_tuple_space, the_reals);


	the_reals : elementary_space := make_elementary_space(es_reals);


	the_strings : elementary_space := make_elementary_space(es_strings);


	the_tuples : extended_tuple_space := make_extended_tuple_space(
    the_zero_tuple_space, the_generics);


	the_zero_pi_interval : finite_real_interval := make_finite_real_interval(
    0.0, closed, pi, closed);


	the_zero_tuple_space : listed_product_space := make_listed_product_space([]);



END_CONSTANT;

TYPE absorbed_dose_measure = REAL;
END_TYPE;

TYPE acceleration_measure = REAL;
END_TYPE;

TYPE action_items = SELECT (
	action_directive,
	certification_item,
	characterized_object,
	classification_item,
	configuration_effectivity,
	document_reference_item,
	identification_item,
	organization,
	person_and_organization,
	product_definition,
	product_definition_formation,
	product_definition_formation_relationship,
	product_definition_relationship,
	requirement_assigned_item);
END_TYPE;

TYPE action_method_items = SELECT (
	product,
	product_definition_formation);
END_TYPE;

TYPE action_request_item = SELECT (
	product_definition,
	product_definition_formation,
	product_definition_formation_relationship,
	product_definition_relationship,
	property_definition,
	versioned_action_request);
END_TYPE;

TYPE action_type = ENUMERATION OF (
	applied_loads,
	residual_loads );
END_TYPE;

TYPE aggregated_angular_variable = ENUMERATION OF (
	total_applied_moment,
	application_defined_aggregated_angular_scalar_variable );
END_TYPE;

TYPE aggregated_scalar_variable = ENUMERATION OF (
	total_strain_energy,
	mass,
	volume );
END_TYPE;

TYPE aggregated_tensor2_3d_variable = ENUMERATION OF (
	rotational_inertia );
END_TYPE;

TYPE aggregated_vector_3d_variable = ENUMERATION OF (
	total_applied_force,
	centre_of_mass_offset );
END_TYPE;

TYPE ahead_or_behind = ENUMERATION OF (
	ahead,
	exact,
	behind );
END_TYPE;

TYPE amount_of_substance_measure = REAL;
END_TYPE;

TYPE analysed_item = SELECT (
	control,
	fea_model,
	result,
	temporal_spatial_domain);
END_TYPE;

TYPE angle_direction_reference_select = SELECT (
	direction,
	curve,
	point_path);
END_TYPE;

TYPE angle_direction_reference_with_a2p3d_select = SELECT (
	angle_direction_reference_select,
	axis2_placement_3d);
END_TYPE;

TYPE angle_relator = ENUMERATION OF (
	equal,
	large,
	small );
END_TYPE;

TYPE angular_value = context_dependent_measure;
END_TYPE;

TYPE anisotropic_symmetric_tensor2_2d = ARRAY [1:3] OF context_dependent_measure;
END_TYPE;

TYPE anisotropic_symmetric_tensor2_3d = ARRAY [1:6] OF context_dependent_measure;
END_TYPE;

TYPE anisotropic_symmetric_tensor4_2d = ARRAY [1:6] OF context_dependent_measure;
END_TYPE;

TYPE anisotropic_symmetric_tensor4_3d = ARRAY [1:21] OF context_dependent_measure;
END_TYPE;

TYPE annotation_plane_element = SELECT (
	draughting_callout,
	styled_item);
END_TYPE;

TYPE annotation_symbol_occurrence_item = SELECT (
	annotation_symbol,
	defined_symbol);
END_TYPE;

TYPE annotation_text_occurrence_item = SELECT (
	text_literal,
	annotation_text,
	annotation_text_character,
	composite_text);
END_TYPE;

TYPE application_defined_degree_of_freedom = STRING;
END_TYPE;

TYPE application_defined_element_purpose = STRING;
END_TYPE;

TYPE application_defined_matrix_property_type = STRING;
END_TYPE;

TYPE application_defined_scalar_variable = STRING;
END_TYPE;

TYPE application_defined_tensor2_2d_variable = STRING;
END_TYPE;

TYPE application_defined_tensor2_3d_variable = STRING;
END_TYPE;

TYPE application_defined_vector_2d_variable = STRING;
END_TYPE;

TYPE application_defined_vector_3d_variable = STRING;
END_TYPE;

TYPE approval_item = SELECT (
	action,
	action_directive,
	alternate_product_relationship,
	applied_action_assignment,
	applied_usage_right,
	assembly_component_usage_substitute,
	certification,
	configuration_effectivity,
	configuration_item,
	contract,
	date,
	directed_action,
	document,
	document_file,
	effectivity,
	executed_action,
	fea_model,
	general_property_relationship,
	group,
	group_relationship,
	information_usage_right,
	product,
	product_definition,
	product_definition_formation,
	product_definition_formation_relationship,
	product_definition_relationship,
	representation,
	requirement_assignment,
	security_classification,
	shape_aspect_relationship,
	temporal_spatial_domain,
	versioned_action_request);
END_TYPE;

TYPE approved_item = SELECT (
	certification,
	change,
	change_request,
	configuration_effectivity,
	configuration_item,
	contract,
	product,
	security_classification,
	start_request,
	start_work);
END_TYPE;

TYPE area_measure = REAL;
END_TYPE;

TYPE area_or_view = SELECT (
	presentation_area,
	presentation_view);
END_TYPE;

TYPE atom_based_tuple = LIST [0:?] OF atom_based_value;
END_TYPE;

TYPE atom_based_value = SELECT (
	maths_atom,
	atom_based_tuple);
END_TYPE;

TYPE attribute_classification_item = SELECT (
	action_directive,
	action_method,
	action_property,
	action_property_representation,
	action_relationship,
	action_request_solution,
	action_request_status,
	alternate_product_relationship,
	applied_action_assignment,
	applied_action_request_assignment,
	applied_approval_assignment,
	applied_certification_assignment,
	applied_document_reference,
	applied_document_usage_constraint_assignment,
	applied_effectivity_assignment,
	applied_event_occurrence_assignment,
	applied_external_identification_assignment,
	applied_identification_assignment,
	applied_organization_assignment,
	applied_organizational_project_assignment,
	applied_person_and_organization_assignment,
	approval,
	approval_person_organization,
	approval_relationship,
	approval_status,
	certification,
	context_dependent_unit,
	contract,
	date_and_time_assignment,
	date_assignment,
	derived_unit,
	descriptive_representation_item,
	document_file,
	document_relationship,
	effectivity,
	event_occurrence_relationship,
	executed_action,
	general_property,
	general_property_relationship,
	group,
	group_relationship,
	information_right,
	information_usage_right,
	language,
	measure_representation_item,
	measure_with_unit,
	named_unit,
	organization_relationship,
	organizational_address,
	organizational_project_relationship,
	person_and_organization,
	person_and_organization_address,
	product,
	product_category,
	product_concept,
	product_concept_context,
	product_definition,
	product_definition_context,
	product_definition_formation,
	product_definition_formation_relationship,
	product_definition_relationship,
	property_definition,
	property_definition_relationship,
	property_definition_representation,
	representation,
	representation_context,
	representation_item,
	security_classification,
	time_interval_relationship,
	uncertainty_measure_with_unit,
	usage_association,
	versioned_action_request);
END_TYPE;

TYPE attribute_language_item = SELECT (
	alternate_product_relationship,
	application_context,
	applied_certification_assignment,
	applied_document_reference,
	applied_document_usage_constraint_assignment,
	applied_external_identification_assignment,
	applied_identification_assignment,
	applied_organizational_project_assignment,
	applied_security_classification_assignment,
	approval,
	approval_relationship,
	approval_status,
	assembly_component_usage_substitute,
	attribute_value_assignment,
	certification,
	certification_type,
	configuration_design,
	configuration_item,
	contract,
	date_role,
	date_time_role,
	descriptive_representation_item,
	document_relationship,
	document_usage_role,
	effectivity,
	effectivity_relationship,
	event_occurrence,
	external_source,
	general_property,
	general_property_relationship,
	geometric_representation_item,
	geometric_tolerance,
	identification_role,
	information_right,
	information_usage_right,
	make_from_usage_option,
	mapped_item,
	multi_language_attribute_assignment,
	object_role,
	organization_relationship,
	organization_role,
	organizational_project,
	organizational_project_relationship,
	organizational_project_role,
	person_and_organization,
	person_and_organization_role,
	product,
	product_concept,
	product_concept_relationship,
	product_definition,
	product_definition_context,
	product_definition_formation,
	product_definition_formation_relationship,
	product_definition_relationship,
	product_definition_shape,
	product_related_product_category,
	property_definition,
	representation,
	security_classification,
	security_classification_assignment,
	shape_aspect,
	shape_aspect_relationship,
	shape_representation,
	time_interval_role,
	topological_representation_item,
	uncertainty_measure_with_unit,
	uncertainty_qualifier,
	usage_association);
END_TYPE;

TYPE attribute_type = SELECT (
	label,
	text);
END_TYPE;

TYPE axi_or_plane = ENUMERATION OF (
	axisymmetric,
	planar );
END_TYPE;

TYPE axis2_placement = SELECT (
	axis2_placement_2d,
	axis2_placement_3d);
END_TYPE;

TYPE b_spline_curve_form = ENUMERATION OF (
	polyline_form,
	circular_arc,
	elliptic_arc,
	parabolic_arc,
	hyperbolic_arc,
	unspecified );
END_TYPE;

TYPE b_spline_surface_form = ENUMERATION OF (
	plane_surf,
	cylindrical_surf,
	conical_surf,
	spherical_surf,
	toroidal_surf,
	surf_of_revolution,
	ruled_surf,
	generalised_cone,
	quadric_surf,
	surf_of_linear_extrusion,
	unspecified );
END_TYPE;

TYPE base_solid_select = SELECT (
	solid_model,
	csg_primitive,
	boolean_result);
WHERE
	WR1 : NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRIMITIVE_2D' IN TYPEOF(SELF));
END_TYPE;

TYPE blend_end_condition_select = SELECT (
	point_on_curve,
	edge_curve,
	vertex);
END_TYPE;

TYPE blend_radius_variation_type = ENUMERATION OF (
	linear_blend,
	cubic_blend,
	unspecified_blend );
END_TYPE;

TYPE boolean_operand = SELECT (
	solid_model,
	half_space_solid,
	csg_primitive,
	boolean_result);
END_TYPE;

TYPE boolean_operator = ENUMERATION OF (
	union,
	intersection,
	difference );
END_TYPE;

TYPE boundary_aggregated_variable = SELECT (
	aggregated_vector_3d_variable,
	application_defined_vector_3d_variable);
END_TYPE;

TYPE boundary_curve_scalar_variable = ENUMERATION OF (
	normal_force_per_unit_length );
END_TYPE;

TYPE boundary_curve_vector_3d_variable = ENUMERATION OF (
	applied_force_per_unit_length,
	applied_moment_per_unit_length );
END_TYPE;

TYPE boundary_edge_variable = SELECT (
	boundary_curve_scalar_variable,
	boundary_curve_vector_3d_variable,
	application_defined_scalar_variable,
	application_defined_vector_3d_variable);
END_TYPE;

TYPE boundary_surface_scalar_variable = ENUMERATION OF (
	pressure );
END_TYPE;

TYPE boundary_surface_vector_3d_variable = ENUMERATION OF (
	applied_force_per_unit_area,
	applied_moment_per_unit_area );
END_TYPE;

TYPE boundary_variable = SELECT (
	boundary_surface_scalar_variable,
	boundary_surface_vector_3d_variable,
	application_defined_scalar_variable,
	application_defined_vector_3d_variable);
END_TYPE;

TYPE box_characteristic_select = SELECT (
	box_height,
	box_width,
	box_slant_angle,
	box_rotate_angle);
END_TYPE;

TYPE box_height = positive_ratio_measure;
END_TYPE;

TYPE box_rotate_angle = plane_angle_measure;
END_TYPE;

TYPE box_slant_angle = plane_angle_measure;
END_TYPE;

TYPE box_width = positive_ratio_measure;
END_TYPE;

TYPE camera_model_d3_multi_clipping_interection_select = SELECT (
	camera_model_d3_multi_clipping_union,
	plane);
END_TYPE;

TYPE camera_model_d3_multi_clipping_union_select = SELECT (
	camera_model_d3_multi_clipping_intersection,
	plane);
END_TYPE;

TYPE capacitance_measure = REAL;
END_TYPE;

TYPE category_usage_item = SELECT (
	product_class);
END_TYPE;

TYPE cc_classified_item = SELECT (
	assembly_component_usage,
	product_definition_formation);
END_TYPE;

TYPE cc_person_organization_item = SELECT (
	change,
	change_request,
	configuration_item,
	contract,
	product,
	product_definition,
	product_definition_formation,
	security_classification,
	start_request,
	start_work);
END_TYPE;

TYPE cc_specified_item = SELECT (
	product_definition,
	shape_aspect);
END_TYPE;

TYPE cell_shape = SELECT (
	cell_shape_0D,
	cell_shape_1D,
	cell_shape_2D,
	cell_shape_3D);
END_TYPE;

TYPE cell_shape_0D = ENUMERATION OF (
	single );
END_TYPE;

TYPE cell_shape_1D = ENUMERATION OF (
	line );
END_TYPE;

TYPE cell_shape_2D = ENUMERATION OF (
	quadrilateral,
	triangle );
END_TYPE;

TYPE cell_shape_3D = ENUMERATION OF (
	hexahedron,
	pyramid,
	tetrahedron,
	wedge );
END_TYPE;

TYPE celsius_temperature_measure = REAL;
END_TYPE;

TYPE central_or_parallel = ENUMERATION OF (
	central,
	parallel );
END_TYPE;

TYPE certification_item = SELECT (
	alternate_product_relationship,
	make_from_usage_option,
	product_definition_formation,
	product_definition_formation_relationship);
END_TYPE;

TYPE certified_item = SELECT (
	supplied_part_relationship);
END_TYPE;

TYPE chained_representation_link = SELECT (
	mapped_item,
	representation_context,
	representation_relationship);
END_TYPE;

TYPE change_request_item = SELECT (
	product_definition_formation);
END_TYPE;

TYPE character_spacing_select = SELECT (
	length_measure,
	ratio_measure,
	measure_with_unit,
	descriptive_measure);
END_TYPE;

TYPE character_style_select = SELECT (
	character_glyph_style_stroke,
	character_glyph_style_outline,
	text_style_for_defined_font);
END_TYPE;

TYPE characterized_action_definition = SELECT (
	action,
	action_method,
	action_method_relationship,
	action_relationship);
END_TYPE;

TYPE characterized_definition = SELECT (
	characterized_object,
	characterized_product_definition,
	shape_definition);
END_TYPE;

TYPE characterized_material_property = SELECT (
	material_property_representation,
	product_material_composition_relationship);
END_TYPE;

TYPE characterized_product_composition_value = SELECT (
	measure_with_unit);
END_TYPE;

TYPE characterized_product_definition = SELECT (
	product_definition,
	product_definition_relationship);
END_TYPE;

TYPE characterized_resource_definition = SELECT (
	action_resource,
	action_resource_relationship);
END_TYPE;

TYPE choose_general_property_identifier = SELECT (
	defined_data_name,
	externally_defined_item);
END_TYPE;

TYPE choose_geometry_location = SELECT (
	externally_defined_item,
	shape_representation);
END_TYPE;

TYPE choose_representation_context_identifier = SELECT (
	defined_data_class,
	externally_defined_item);
END_TYPE;

TYPE class_usage_effectivity_context_item = SELECT (
	product_definition);
END_TYPE;

TYPE classification_item = SELECT (
	action,
	action_directive,
	action_method,
	action_property,
	action_relationship,
	action_request_solution,
	action_request_status,
	address,
	alternate_product_relationship,
	applied_action_assignment,
	applied_action_request_assignment,
	applied_approval_assignment,
	applied_certification_assignment,
	applied_contract_assignment,
	applied_date_and_time_assignment,
	applied_date_assignment,
	applied_document_reference,
	applied_document_usage_constraint_assignment,
	applied_effectivity_assignment,
	applied_event_occurrence_assignment,
	applied_external_identification_assignment,
	applied_identification_assignment,
	applied_organization_assignment,
	applied_organizational_project_assignment,
	applied_person_and_organization_assignment,
	applied_security_classification_assignment,
	approval,
	approval_person_organization,
	approval_relationship,
	approval_status,
	assembly_component_usage_substitute,
	calendar_date,
	certification,
	characterized_class,
	characterized_object,
	class,
	classified_item,
	configuration_item,
	context_dependent_unit,
	contract,
	conversion_based_unit,
	date_and_time,
	date_and_time_assignment,
	date_assignment,
	derived_unit,
	descriptive_representation_item,
	directed_action,
	document_file,
	document_relationship,
	effectivity,
	event_occurrence,
	executed_action,
	general_property,
	general_property_relationship,
	group,
	identification_assignment,
	information_right,
	information_usage_right,
	language,
	measure_representation_item,
	measure_with_unit,
	multi_language_attribute_assignment,
	named_unit,
	organization,
	organization_relationship,
	organizational_address,
	organizational_project,
	organizational_project_relationship,
	person,
	person_and_organization_address,
	product,
	product_concept,
	product_definition,
	product_definition_context,
	product_definition_formation,
	product_definition_formation_relationship,
	product_definition_relationship,
	property_definition,
	property_definition_representation,
	representation,
	representation_context,
	representation_item,
	security_classification,
	state_type,
	state_type_assignment,
	state_type_relationship,
	uncertainty_measure_with_unit,
	usage_association,
	versioned_action_request);
END_TYPE;

TYPE classified_item = SELECT (
	product,
	product_definition,
	product_definition_formation);
END_TYPE;

TYPE compound_item_definition = SELECT (
	list_representation_item,
	set_representation_item);
END_TYPE;

TYPE conductance_measure = REAL;
END_TYPE;

TYPE configuration_design_item = SELECT (
	product_definition,
	product_definition_formation);
END_TYPE;

TYPE configured_effectivity_context_item = SELECT (
	product_concept_feature_association);
END_TYPE;

TYPE configured_effectivity_item = SELECT (
	product_definition);
END_TYPE;

TYPE constructive_geometry_representation_or_shape_represenation = SELECT (
	constructive_geometry_representation,
	shape_representation);
END_TYPE;

TYPE context_dependent_measure = REAL;
END_TYPE;

TYPE contract_item = SELECT (
	action_directive,
	alternate_product_relationship,
	directed_action,
	executed_action,
	information_usage_right,
	organization,
	person_and_organization,
	product,
	product_definition_formation);
END_TYPE;

TYPE contracted_item = SELECT (
	product_definition_formation);
END_TYPE;

TYPE coordinate_data_name = ENUMERATION OF (
	coordinate_eta,
	coordinate_normal,
	coordinate_phi,
	coordinate_r,
	coordinate_tangential,
	coordinate_theta,
	coordinate_transform,
	coordinate_x,
	coordinate_xi,
	coordinate_y,
	coordinate_z,
	coordinate_zeta );
END_TYPE;

TYPE coordinate_system_type = ENUMERATION OF (
	cartesian,
	cylindrical,
	spherical );
END_TYPE;

TYPE count_measure = NUMBER;
END_TYPE;

TYPE csg_primitive = SELECT (
	sphere,
	block,
	right_angular_wedge,
	torus,
	right_circular_cone,
	right_circular_cylinder);
END_TYPE;

TYPE csg_select = SELECT (
	boolean_result,
	csg_primitive);
END_TYPE;

TYPE curve_2d_element_descriptor = SELECT (
	axisymmetric_curve_2d_element_descriptor,
	plane_curve_2d_element_descriptor);
END_TYPE;

TYPE curve_2d_element_output_reference = SELECT (
	curve_2d_element_representation,
	curve_2d_element_descriptor,
	curve_2d_element_group,
	curve_2d_substructure_element_reference,
	analysis_item_within_representation);
END_TYPE;

TYPE curve_2d_element_representation = SELECT (
	axisymmetric_curve_2d_element_representation,
	plane_curve_2d_element_representation);
END_TYPE;

TYPE curve_2d_state_coordinate_system = SELECT (
	fea_axis2_placement_3d,
	curve_2d_element_coordinate_system);
END_TYPE;

TYPE curve_3d_element_coordinate_system = SELECT (
	aligned_curve_3d_element_coordinate_system,
	parametric_curve_3d_element_coordinate_system);
END_TYPE;

TYPE curve_3d_element_length_integration = SELECT (
	element_integration_algebraic,
	curve_3d_element_length_integration_rule,
	curve_3d_element_length_integration_explicit);
END_TYPE;

TYPE curve_3d_element_output_reference = SELECT (
	curve_3d_element_representation,
	curve_3d_element_descriptor,
	curve_3d_element_group,
	curve_3d_substructure_element_reference,
	analysis_item_within_representation);
END_TYPE;

TYPE curve_3d_state_coordinate_system = SELECT (
	fea_axis2_placement_3d,
	curve_3d_element_coordinate_system);
END_TYPE;

TYPE curve_edge = ENUMERATION OF (
	element_edge );
END_TYPE;

TYPE curve_element_end_coordinate_system = SELECT (
	fea_axis2_placement_3d,
	curve_3d_element_coordinate_system);
END_TYPE;

TYPE curve_element_freedom = SELECT (
	enumerated_curve_element_freedom,
	application_defined_degree_of_freedom);
END_TYPE;

TYPE curve_element_purpose = SELECT (
	enumerated_curve_element_purpose,
	application_defined_element_purpose);
END_TYPE;

TYPE curve_element_variable = SELECT (
	volume_variable,
	curve_scalar_variable,
	curve_vector_2d_variable,
	application_defined_vector_2d_variable,
	curve_vector_3d_variable);
END_TYPE;

TYPE curve_font_or_scaled_curve_font_select = SELECT (
	curve_style_font_select,
	curve_style_font_and_scaling);
END_TYPE;

TYPE curve_matrix_property_type = SELECT (
	enumerated_curve_matrix_property_type,
	application_defined_matrix_property_type);
END_TYPE;

TYPE curve_on_surface = SELECT (
	pcurve,
	surface_curve,
	composite_curve_on_surface);
END_TYPE;

TYPE curve_or_annotation_curve_occurrence = SELECT (
	curve,
	annotation_curve_occurrence);
END_TYPE;

TYPE curve_or_render = SELECT (
	curve_style,
	curve_style_rendering);
END_TYPE;

TYPE curve_scalar_variable = ENUMERATION OF (
	curve_axial_force,
	curve_axial_strain,
	torque,
	curve_warping,
	bi_moment,
	twist );
END_TYPE;

TYPE curve_style_font_select = SELECT (
	curve_style_font,
	pre_defined_curve_font,
	externally_defined_curve_font);
END_TYPE;

TYPE curve_vector_2d_variable = ENUMERATION OF (
	curve_shear_force,
	curve_bending_moment,
	curve_element_curvature,
	curve_thermal_gradient,
	reference_curve_thermal_gradient );
END_TYPE;

TYPE curve_vector_3d_variable = ENUMERATION OF (
	applied_force_per_unit_length,
	applied_moment_per_unit_length );
END_TYPE;

TYPE cylindrical_harmonic_number = INTEGER;
WHERE
	WR1 : SELF >= 0;
END_TYPE;

TYPE date_and_time_item = SELECT (
	action,
	action_directive,
	applied_action_assignment,
	applied_organization_assignment,
	applied_person_and_organization_assignment,
	applied_security_classification_assignment,
	approval_person_organization,
	certification,
	contract,
	directed_action,
	document,
	document_file,
	event_occurrence,
	executed_action,
	information_usage_right,
	organizational_project,
	product_definition,
	product_definition_formation,
	product_definition_relationship,
	rule_action,
	security_classification,
	versioned_action_request);
END_TYPE;

TYPE date_item = SELECT (
	action,
	action_directive,
	applied_action_assignment,
	applied_organization_assignment,
	applied_person_and_organization_assignment,
	applied_security_classification_assignment,
	approval_person_organization,
	certification,
	contract,
	directed_action,
	document,
	document_file,
	event_occurrence,
	executed_action,
	information_usage_right,
	organizational_project,
	product_definition,
	product_definition_formation,
	product_definition_relationship,
	security_classification,
	versioned_action_request);
END_TYPE;

TYPE date_time_item = SELECT (
	approval_person_organization,
	certification,
	change,
	change_request,
	contract,
	product_definition,
	security_classification,
	start_request,
	start_work);
END_TYPE;

TYPE date_time_or_event_occurrence = SELECT (
	date_time_select,
	event_occurrence);
END_TYPE;

TYPE date_time_select = SELECT (
	date,
	date_and_time,
	local_time);
END_TYPE;

TYPE day_in_month_number = INTEGER;
WHERE
	WR1 : {1 <= SELF <= 31};
END_TYPE;

TYPE day_in_week_number = INTEGER;
WHERE
	WR1 : { 1 <= SELF <= 7 };
END_TYPE;

TYPE day_in_year_number = INTEGER;
WHERE
	WR1 : {1 <= SELF <= 366};
END_TYPE;

TYPE defined_data_class = ENUMERATION OF (
	application_defined,
	dimensional,
	dimensionless_constant,
	dimensionless_parameter,
	normalise_by_unknown_dimensional,
	normalised_by_dimensional,
	unspecified );
END_TYPE;

TYPE defined_data_name = SELECT (
	coordinate_data_name,
	fd_defined_data_name);
END_TYPE;

TYPE defined_symbol_select = SELECT (
	pre_defined_symbol,
	externally_defined_symbol);
END_TYPE;

TYPE degree_of_freedom = SELECT (
	enumerated_degree_of_freedom,
	application_defined_degree_of_freedom);
END_TYPE;

TYPE derived_property_select = SELECT (
	property_definition,
	action_property,
	resource_property);
END_TYPE;

TYPE description_attribute_select = SELECT (
	action_request_solution,
	application_context,
	approval_role,
	configuration_design,
	date_role,
	date_time_role,
	context_dependent_shape_representation,
	effectivity,
	external_source,
	organization_role,
	person_and_organization_role,
	person_and_organization,
	property_definition_representation,
	representation);
END_TYPE;

TYPE descriptive_measure = STRING;
END_TYPE;

TYPE dimension_count = INTEGER;
WHERE
	WR1 : SELF > 0;
END_TYPE;

TYPE dimension_extent_usage = ENUMERATION OF (
	origin,
	target );
END_TYPE;

TYPE dimensional_characteristic = SELECT (
	dimensional_location,
	dimensional_size);
END_TYPE;

TYPE direction_count_select = SELECT (
	u_direction_count,
	v_direction_count);
END_TYPE;

TYPE directionally_explicit_element_coordinate_system = SELECT (
	directionally_explicit_element_coordinate_system_arbitrary,
	directionally_explicit_element_coordinate_system_aligned);
END_TYPE;

TYPE discretised_action_model_select = SELECT (
	analysis_step,
	model_action_domain);
END_TYPE;

TYPE discretised_distribution_model_select = SELECT (
	model_property_distribution,
	state_definition);
END_TYPE;

TYPE discretised_product_model_select = SELECT (
	fea_model,
	model_product_domain);
END_TYPE;

TYPE discretised_state_model_select = SELECT (
	model_state_domain,
	state);
END_TYPE;

TYPE document_identifier_assigned_item = SELECT (
	document);
END_TYPE;

TYPE document_reference_item = SELECT (
	action_method,
	applied_external_identification_assignment,
	assembly_component_usage,
	characterized_class,
	characterized_object,
	configuration_item,
	descriptive_representation_item,
	dimensional_size,
	executed_action,
	externally_defined_dimension_definition,
	externally_defined_item,
	group,
	group_relationship,
	information_right,
	information_usage_right,
	material_designation,
	measure_representation_item,
	product,
	product_category,
	product_definition,
	product_definition_formation,
	product_definition_formation_relationship,
	product_definition_relationship,
	property_definition,
	representation,
	representation_item,
	rule_set,
	shape_aspect,
	shape_aspect_relationship,
	usage_association,
	versioned_action_request);
END_TYPE;

TYPE dose_equivalent_measure = REAL;
END_TYPE;

TYPE draughting_callout_element = SELECT (
	annotation_curve_occurrence,
	annotation_fill_area_occurrence,
	annotation_symbol_occurrence,
	annotation_text_occurrence);
END_TYPE;

TYPE draughting_model_item_association_select = SELECT (
	annotation_occurrence,
	draughting_callout);
END_TYPE;

TYPE draughting_model_item_select = SELECT (
	mapped_item,
	styled_item,
	axis2_placement,
	camera_model,
	draughting_callout);
END_TYPE;

TYPE draughting_subfigure_representation_item = SELECT (
	annotation_occurrence,
	draughting_callout,
	axis2_placement);
END_TYPE;

TYPE draughting_symbol_representation_item = SELECT (
	annotation_curve_occurrence,
	annotation_symbol_occurrence,
	annotation_fill_area_occurrence,
	annotation_text_occurrence,
	axis2_placement);
END_TYPE;

TYPE draughting_titled_item = SELECT (
	drawing_revision,
	drawing_sheet_revision);
END_TYPE;

TYPE effectivity_item = SELECT (
	assembly_component_usage_substitute,
	product,
	product_definition,
	product_definition_formation,
	product_definition_relationship,
	product_definition_substitute);
END_TYPE;

TYPE electric_charge_measure = REAL;
END_TYPE;

TYPE electric_current_measure = REAL;
END_TYPE;

TYPE electric_potential_measure = REAL;
END_TYPE;

TYPE element_2d_shape = ENUMERATION OF (
	quadrilateral,
	triangle );
END_TYPE;

TYPE element_aspect = SELECT (
	element_volume,
	volume_3d_face,
	volume_2d_face,
	volume_3d_edge,
	volume_2d_edge,
	surface_3d_face,
	surface_2d_face,
	surface_3d_edge,
	surface_2d_edge,
	curve_edge);
END_TYPE;

TYPE element_integration_algebraic = ENUMERATION OF (
	algebraic );
END_TYPE;

TYPE element_or_element_group = SELECT (
	element_representation,
	element_group);
END_TYPE;

TYPE element_order = ENUMERATION OF (
	linear,
	quadratic,
	cubic );
END_TYPE;

TYPE element_volume = ENUMERATION OF (
	volume );
END_TYPE;

TYPE elementary_function_enumerators = ENUMERATION OF (
	ef_and,
	ef_or,
	ef_not,
	ef_xor,
	ef_negate_i,
	ef_add_i,
	ef_subtract_i,
	ef_multiply_i,
	ef_divide_i,
	ef_mod_i,
	ef_exponentiate_i,
	ef_eq_i,
	ef_ne_i,
	ef_gt_i,
	ef_lt_i,
	ef_ge_i,
	ef_le_i,
	ef_abs_i,
	ef_max_i,
	ef_min_i,
	ef_if_i,
	ef_negate_r,
	ef_reciprocal_r,
	ef_add_r,
	ef_subtract_r,
	ef_multiply_r,
	ef_divide_r,
	ef_mod_r,
	ef_exponentiate_r,
	ef_exponentiate_ri,
	ef_eq_r,
	ef_ne_r,
	ef_gt_r,
	ef_lt_r,
	ef_ge_r,
	ef_le_r,
	ef_abs_r,
	ef_max_r,
	ef_min_r,
	ef_acos_r,
	ef_asin_r,
	ef_atan2_r,
	ef_cos_r,
	ef_exp_r,
	ef_ln_r,
	ef_log2_r,
	ef_log10_r,
	ef_sin_r,
	ef_sqrt_r,
	ef_tan_r,
	ef_if_r,
	ef_form_c,
	ef_rpart_c,
	ef_ipart_c,
	ef_negate_c,
	ef_reciprocal_c,
	ef_add_c,
	ef_subtract_c,
	ef_multiply_c,
	ef_divide_c,
	ef_exponentiate_c,
	ef_exponentiate_ci,
	ef_eq_c,
	ef_ne_c,
	ef_conjugate_c,
	ef_abs_c,
	ef_arg_c,
	ef_cos_c,
	ef_exp_c,
	ef_ln_c,
	ef_sin_c,
	ef_sqrt_c,
	ef_tan_c,
	ef_if_c,
	ef_subscript_s,
	ef_eq_s,
	ef_ne_s,
	ef_gt_s,
	ef_lt_s,
	ef_ge_s,
	ef_le_s,
	ef_subsequence_s,
	ef_concat_s,
	ef_size_s,
	ef_format,
	ef_value,
	ef_like,
	ef_if_s,
	ef_subscript_b,
	ef_eq_b,
	ef_ne_b,
	ef_gt_b,
	ef_lt_b,
	ef_ge_b,
	ef_le_b,
	ef_subsequence_b,
	ef_concat_b,
	ef_size_b,
	ef_if_b,
	ef_subscript_t,
	ef_eq_t,
	ef_ne_t,
	ef_concat_t,
	ef_size_t,
	ef_entuple,
	ef_detuple,
	ef_insert,
	ef_remove,
	ef_if_t,
	ef_sum_it,
	ef_product_it,
	ef_add_it,
	ef_subtract_it,
	ef_scalar_mult_it,
	ef_dot_prod_it,
	ef_sum_rt,
	ef_product_rt,
	ef_add_rt,
	ef_subtract_rt,
	ef_scalar_mult_rt,
	ef_dot_prod_rt,
	ef_norm_rt,
	ef_sum_ct,
	ef_product_ct,
	ef_add_ct,
	ef_subtract_ct,
	ef_scalar_mult_ct,
	ef_dot_prod_ct,
	ef_norm_ct,
	ef_if,
	ef_ensemble,
	ef_member_of );
END_TYPE;

TYPE elementary_space_enumerators = ENUMERATION OF (
	es_numbers,
	es_complex_numbers,
	es_reals,
	es_integers,
	es_logicals,
	es_booleans,
	es_strings,
	es_binarys,
	es_maths_spaces,
	es_maths_functions,
	es_generics );
END_TYPE;

TYPE energy_measure = REAL;
END_TYPE;

TYPE enumerated_curve_element_freedom = ENUMERATION OF (
	x_translation,
	y_translation,
	z_translation,
	x_rotation,
	y_rotation,
	z_rotation,
	warp,
	none );
END_TYPE;

TYPE enumerated_curve_element_purpose = ENUMERATION OF (
	axial,
	y_y_bending,
	z_z_bending,
	torsion,
	x_y_shear,
	x_z_shear,
	warping );
END_TYPE;

TYPE enumerated_curve_matrix_property_type = ENUMERATION OF (
	axial,
	y_y_bending,
	z_z_bending,
	torsion,
	x_y_shear,
	x_z_shear,
	warping,
	axial_mass,
	y_y_bending_mass,
	z_z_bending_mass,
	torsion_mass,
	x_y_shear_mass,
	x_z_shear_mass,
	warping_mass,
	mass );
END_TYPE;

TYPE enumerated_degree_of_freedom = ENUMERATION OF (
	x_translation,
	y_translation,
	z_translation,
	x_rotation,
	y_rotation,
	z_rotation,
	warp );
END_TYPE;

TYPE enumerated_matrix_property_type = ENUMERATION OF (
	stiffness,
	mass,
	damping );
END_TYPE;

TYPE enumerated_plane_2d_element_purpose = ENUMERATION OF (
	plane_stress,
	plane_strain );
END_TYPE;

TYPE enumerated_surface_element_purpose = ENUMERATION OF (
	membrane_direct,
	membrane_shear,
	bending_direct,
	bending_torsion,
	normal_to_plane_shear );
END_TYPE;

TYPE enumerated_surface_matrix_property_type = ENUMERATION OF (
	membrane_direct,
	membrane_shear,
	bending_direct,
	bending_torsion,
	normal_to_plane_shear,
	membrane_direct_mass,
	membrane_shear_mass,
	bending_direct_mass,
	bending_torsion_mass,
	normal_to_plane_shear_mass,
	mass );
END_TYPE;

TYPE enumerated_volume_element_purpose = ENUMERATION OF (
	stress_displacement );
END_TYPE;

TYPE event_occurrence_item = SELECT (
	organizational_project);
END_TYPE;

TYPE extension_options = ENUMERATION OF (
	eo_none,
	eo_cont,
	eo_cont_right,
	eo_cont_left );
END_TYPE;

TYPE external_identification_item = SELECT (
	action_relationship,
	action_request_status,
	applied_organization_assignment,
	applied_person_and_organization_assignment,
	approval,
	approval_status,
	date_and_time_assignment,
	date_assignment,
	document_file,
	external_source,
	externally_defined_class,
	externally_defined_context_dependent_unit,
	externally_defined_conversion_based_unit,
	externally_defined_general_property,
	externally_defined_picture_representation_item,
	externally_defined_representation_item,
	organizational_address,
	product_definition,
	security_classification,
	trimmed_curve,
	versioned_action_request);
END_TYPE;

TYPE fd_bc_type_simple = mbna_bc_type_simple;
END_TYPE;

TYPE fd_behaviour_models = SELECT (
	gas_model,
	turbulence_closure,
	turbulence_model,
	viscosity_model);
END_TYPE;

TYPE fd_defined_data_name = SELECT (
	fd_nondimensional_parameter_name,
	flow_solution_data_name,
	force_moment_data_name,
	gas_model_data_name,
	Riemann_1D_data_name,
	thermal_conductivity_model_data_name,
	turbulence_closure_data_name,
	turbulence_model_data_name,
	viscosity_model_data_name);
END_TYPE;

TYPE fd_governing_equation_type = mbna_governing_equation_type;
END_TYPE;

TYPE fd_nondimensional_parameter_name = ENUMERATION OF (
	coef_pressure,
	coef_pressure_dynamic,
	coef_pressure_reference,
	coef_skin_friction_x,
	coef_skin_friction_y,
	coef_skin_friction_z,
	length_reference,
	Mach,
	Mach_velocity,
	Mach_velocity_sound,
	Prandtl,
	Prandtl_specific_heat_pressure,
	Prandtl_thermal_conductivity,
	Prandtl_viscosity_molecular,
	Reynolds,
	Reynolds_length,
	Reynolds_velocity,
	Reynolds_viscosity_kinematic,
	specific_heat_ratio,
	specific_heat_ratio_pressure,
	specific_heat_ratio_volume );
END_TYPE;

TYPE fea_column_normalised_monoclinic_symmetric_tensor4_3d = ARRAY [1:13] OF context_dependent_measure;
END_TYPE;

TYPE fea_column_normalised_orthotropic_symmetric_tensor4_3d = ARRAY [1:9] OF context_dependent_measure;
END_TYPE;

TYPE fea_iso_orthotropic_symmetric_tensor4_3d = ARRAY [1:3] OF context_dependent_measure;
END_TYPE;

TYPE fea_isotropic_symmetric_tensor4_3d = ARRAY [1:2] OF context_dependent_measure;
END_TYPE;

TYPE fea_transverse_isotropic_symmetric_tensor4_3d = ARRAY [1:5] OF context_dependent_measure;
END_TYPE;

TYPE field_value = SELECT (
	unspecified_value,
	scalar,
	tensor1_2d,
	tensor1_3d,
	anisotropic_symmetric_tensor2_2d,
	isotropic_symmetric_tensor2_3d,
	orthotropic_symmetric_tensor2_3d,
	anisotropic_symmetric_tensor2_3d);
END_TYPE;

TYPE fill_area_style_tile_shape_select = SELECT (
	fill_area_style_tile_curve_with_style,
	fill_area_style_tile_coloured_region,
	fill_area_style_tile_symbol_with_style,
	pre_defined_tile,
	externally_defined_tile);
END_TYPE;

TYPE fill_style_select = SELECT (
	fill_area_style_colour,
	externally_defined_tile_style,
	fill_area_style_tiles,
	externally_defined_hatch_style,
	fill_area_style_hatching);
END_TYPE;

TYPE flow_solution_data_name = ENUMERATION OF (
	density,
	density_stagnation,
	energy_internal,
	energy_kinetic,
	energy_stagnation,
	energy_stagnation_density,
	enthalpy,
	enthalpy_stagnation,
	entropy,
	entropy_approx,
	ideal_gas_constant,
	mass_flow,
	momentum_magnitude,
	momentum_x,
	momentum_y,
	momentum_z,
	potential,
	pressure,
	pressure_dynamic,
	pressure_stagnation,
	Reynolds_stress_xx,
	Reynolds_stress_xy,
	Reynolds_stress_xz,
	Reynolds_stress_yy,
	Reynolds_stress_yz,
	Reynolds_stress_zz,
	skin_friction_magnitude,
	skin_friction_x,
	skin_friction_y,
	skin_friction_z,
	specific_heat_pressure,
	specific_heat_volume,
	stream_function,
	temperature,
	temperature_stagnation,
	thermal_conductivity,
	velocity_angle_x,
	velocity_angle_y,
	velocity_angle_z,
	velocity_magnitude,
	velocity_normal,
	velocity_phi,
	velocity_r,
	velocity_sound,
	velocity_sound_stagnation,
	velocity_tangential,
	velocity_theta,
	velocity_unit_vector_x,
	velocity_unit_vector_y,
	velocity_unit_vector_z,
	velocity_x,
	velocity_y,
	velocity_z,
	viscosity_eddy,
	viscosity_kinematic,
	viscosity_molecular,
	vorticity_magnitude,
	vorticity_x,
	vorticity_y,
	vorticity_z );
END_TYPE;

TYPE font_select = SELECT (
	pre_defined_text_font,
	externally_defined_text_font,
	text_font);
END_TYPE;

TYPE force_measure = REAL;
END_TYPE;

TYPE force_moment_data_name = ENUMERATION OF (
	coef_drag,
	coef_length,
	coef_lift,
	coef_moment_area,
	coef_moment_eta,
	coef_moment_phi,
	coef_moment_pressure_dynamic,
	coef_moment_r,
	coef_moment_theta,
	coef_moment_x,
	coef_moment_xi,
	coef_moment_y,
	coef_moment_z,
	coef_moment_zeta,
	drag,
	force_phi,
	force_r,
	force_theta,
	force_x,
	force_y,
	force_z,
	lift,
	moment_center_x,
	moment_center_y,
	moment_center_z,
	moment_eta,
	moment_phi,
	moment_r,
	moment_theta,
	moment_x,
	moment_xi,
	moment_y,
	moment_z,
	moment_zeta );
END_TYPE;

TYPE founded_item_select = SELECT (
	founded_item,
	representation_item);
END_TYPE;

TYPE frequency_measure = REAL;
END_TYPE;

TYPE gas_model_data_name = ENUMERATION OF (
	ideal_gas_constant,
	specific_heat_pressure,
	specific_heat_ratio,
	specific_heat_volume );
END_TYPE;

TYPE gas_model_type = ENUMERATION OF (
	application_defined,
	ideal,
	unspecified,
	Van_der_Waals );
END_TYPE;

TYPE generalized_surface_select = SELECT (
	surface,
	face_surface,
	surfaced_open_shell);
END_TYPE;

TYPE geometric_item_specific_usage_select = SELECT (
	shape_aspect,
	shape_aspect_relationship);
END_TYPE;

TYPE geometric_set_select = SELECT (
	point,
	curve,
	surface);
END_TYPE;

TYPE groupable_item = SELECT (
	geometric_representation_item,
	group_relationship,
	mapped_item,
	package_product_concept_feature,
	product_concept_feature,
	product_definition,
	product_definition_formation,
	property_definition_representation,
	representation,
	representation_item,
	representation_relationship_with_transformation,
	shape_aspect,
	shape_aspect_relationship,
	shape_representation_relationship,
	styled_item,
	topological_representation_item);
WHERE
	WR1 : NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GROUP' IN TYPEOF(SELF));
END_TYPE;

TYPE hour_in_day = INTEGER;
WHERE
	WR1 : { 0 <= SELF < 24 };
END_TYPE;

TYPE id_attribute_select = SELECT (
	action,
	address,
	product_category,
	property_definition,
	shape_aspect,
	shape_aspect_relationship,
	application_context,
	group,
	organizational_project,
	representation);
END_TYPE;

TYPE idealised_action_select = SELECT (
	action,
	physical_action_domain);
END_TYPE;

TYPE idealised_distribution_select = SELECT (
	domain_property,
	property_definition);
END_TYPE;

TYPE idealised_product_select = SELECT (
	physical_product_domain,
	product_definition);
END_TYPE;

TYPE idealised_state_select = SELECT (
	physical_state_domain,
	state_type);
END_TYPE;

TYPE identification_item = SELECT (
	approval_status,
	characterized_class,
	class,
	configuration_item,
	contract,
	dimensional_size,
	document_file,
	general_property,
	group,
	group_relationship,
	information_right,
	information_usage_right,
	material_designation,
	organization,
	person_and_organization,
	product,
	product_category,
	product_class,
	product_concept,
	product_concept_feature,
	product_definition,
	product_definition_formation,
	product_identification,
	representation,
	rule_set,
	security_classification,
	security_classification_level,
	shape_aspect_relationship,
	shape_representation,
	state_type,
	state_type_relationship,
	usage_association);
END_TYPE;

TYPE identifier = STRING;
END_TYPE;

TYPE ijk_minmax = ENUMERATION OF (
	i_min,
	j_min,
	k_min,
	i_max,
	j_max,
	k_max );
END_TYPE;

TYPE illuminance_measure = REAL;
END_TYPE;

TYPE indices_group = SELECT (
	indices_list,
	indices_range);
END_TYPE;

TYPE inductance_measure = REAL;
END_TYPE;

TYPE input_selector = positive_integer;
END_TYPE;

TYPE instance_usage_context_select = SELECT (
	product_definition_relationship,
	product_definition_usage);
END_TYPE;

TYPE integration_rule = ENUMERATION OF (
	gaussian,
	simpson );
END_TYPE;

TYPE invisibility_context = SELECT (
	draughting_model,
	presentation_representation,
	presentation_set);
END_TYPE;

TYPE invisible_item = SELECT (
	draughting_callout,
	presentation_layer_assignment,
	representation,
	styled_item);
END_TYPE;

TYPE ir_usage_item = action_items;
WHERE
	wr1 : NOT ('INFORMATION_RIGHTS_MIM.CONFIGURATION_EFFECTIVITY' IN TYPEOF(SELF));
	wr2 : NOT ('INFORMATION_RIGHTS_MIM.PRODUCT_DEFINITION' IN TYPEOF(SELF));
	wr3 : NOT ('INFORMATION_RIGHTS_MIM.PRODUCT_DEFINITION_FORMATION_RELATIONSHIP' IN TYPEOF(SELF));
	wr4 : NOT ('INFORMATION_RIGHTS_MIM.PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(SELF));
END_TYPE;

TYPE isotropic_symmetric_tensor2_3d = context_dependent_measure;
END_TYPE;

TYPE knot_type = ENUMERATION OF (
	uniform_knots,
	quasi_uniform_knots,
	piecewise_bezier_knots,
	unspecified );
END_TYPE;

TYPE label = STRING;
END_TYPE;

TYPE layered_item = SELECT (
	presentation_representation,
	representation_item);
END_TYPE;

TYPE length_measure = REAL;
END_TYPE;

TYPE limit_condition = ENUMERATION OF (
	maximum_material_condition,
	least_material_condition,
	regardless_of_feature_size );
END_TYPE;

TYPE list_of_reversible_topology_item = LIST [0:?] OF reversible_topology_item;
END_TYPE;

TYPE list_representation_item = LIST [1:?] OF representation_item;
END_TYPE;

TYPE lower_upper = ENUMERATION OF (
	lower,
	upper );
END_TYPE;

TYPE luminous_flux_measure = REAL;
END_TYPE;

TYPE luminous_intensity_measure = REAL;
END_TYPE;

TYPE magnetic_flux_density_measure = REAL;
END_TYPE;

TYPE magnetic_flux_measure = REAL;
END_TYPE;

TYPE marker_select = SELECT (
	marker_type,
	pre_defined_marker);
END_TYPE;

TYPE marker_type = ENUMERATION OF (
	dot,
	x,
	plus,
	asterisk,
	ring,
	square,
	triangle );
END_TYPE;

TYPE mass_measure = REAL;
END_TYPE;

TYPE maths_atom = SELECT (
	maths_simple_atom,
	maths_enum_atom);
END_TYPE;

TYPE maths_binary = BINARY;
END_TYPE;

TYPE maths_boolean = BOOLEAN;
END_TYPE;

TYPE maths_enum_atom = SELECT (
	elementary_space_enumerators,
	ordering_type,
	lower_upper,
	symmetry_type,
	elementary_function_enumerators,
	open_closed,
	space_constraint_type,
	repackage_options,
	extension_options);
END_TYPE;

TYPE maths_expression = SELECT (
	atom_based_value,
	maths_tuple,
	generic_expression);
END_TYPE;

TYPE maths_function_select = SELECT (
	maths_function,
	elementary_function_enumerators);
END_TYPE;

TYPE maths_integer = INTEGER;
END_TYPE;

TYPE maths_logical = LOGICAL;
END_TYPE;

TYPE maths_number = NUMBER;
END_TYPE;

TYPE maths_real = REAL;
END_TYPE;

TYPE maths_simple_atom = SELECT (
	maths_number,
	maths_real,
	maths_integer,
	maths_logical,
	maths_boolean,
	maths_string,
	maths_binary);
END_TYPE;

TYPE maths_space_or_function = SELECT (
	maths_space,
	maths_function);
END_TYPE;

TYPE maths_string = STRING;
END_TYPE;

TYPE maths_tuple = LIST [0:?] OF maths_value;
END_TYPE;

TYPE maths_value = SELECT (
	atom_based_value,
	maths_tuple,
	generic_expression);
WHERE
	constancy : NOT ('GENERIC_EXPRESSION' IN stripped_typeof(SELF)) OR
             expression_is_constant(SELF);
END_TYPE;

TYPE matrix_property_type = SELECT (
	enumerated_matrix_property_type,
	application_defined_matrix_property_type);
END_TYPE;

TYPE matrix_symmetry = ENUMERATION OF (
	symmetric,
	diagonal );
END_TYPE;

TYPE mbna_bc_type = SELECT (
	mbna_bc_type_compound,
	mbna_bc_type_simple);
END_TYPE;

TYPE mbna_bc_type_compound = ENUMERATION OF (
	application_defined,
	bc_farfield,
	bc_inflow,
	bc_outflow,
	unspecified );
END_TYPE;

TYPE mbna_bc_type_simple = ENUMERATION OF (
	application_defined,
	bc_axissymmetric_wedge,
	bc_degenerate_line,
	bc_degenerate_point,
	bc_Dirichlet,
	bc_extrapolate,
	bc_general,
	bc_inflow_subsonic,
	bc_inflow_supersonic,
	bc_Neumann,
	bc_outflow_subsonic,
	bc_outflow_supersonic,
	bc_symmetry_plane,
	bc_symmetry_polar,
	bc_tunnel_inflow,
	bc_tunnel_outflow,
	bc_wall,
	bc_wall_inviscid,
	bc_wall_viscous,
	bc_wall_viscous_heat_flux,
	bc_wall_viscous_isothermal,
	unspecified );
END_TYPE;

TYPE mbna_behaviour_models = SELECT (
	thermal_conductivity_model);
END_TYPE;

TYPE mbna_governing_equation_type = ENUMERATION OF (
	application_defined,
	Euler,
	full_potential,
	NS_laminar,
	NS_laminar_incompressible,
	NS_turbulent,
	NS_turbulent_incompressible,
	unspecified );
END_TYPE;

TYPE measure_or_unspecified_value = SELECT (
	context_dependent_measure,
	unspecified_value);
END_TYPE;

TYPE measure_value = SELECT (
	absorbed_dose_measure,
	dose_equivalent_measure,
	radioactivity_measure,
	acceleration_measure,
	amount_of_substance_measure,
	area_measure,
	celsius_temperature_measure,
	context_dependent_measure,
	count_measure,
	descriptive_measure,
	capacitance_measure,
	electric_charge_measure,
	conductance_measure,
	electric_current_measure,
	electric_potential_measure,
	energy_measure,
	magnetic_flux_density_measure,
	force_measure,
	frequency_measure,
	illuminance_measure,
	inductance_measure,
	length_measure,
	luminous_flux_measure,
	luminous_intensity_measure,
	magnetic_flux_measure,
	mass_measure,
	numeric_measure,
	non_negative_length_measure,
	parameter_value,
	plane_angle_measure,
	positive_length_measure,
	positive_plane_angle_measure,
	positive_ratio_measure,
	power_measure,
	pressure_measure,
	ratio_measure,
	resistance_measure,
	solid_angle_measure,
	thermodynamic_temperature_measure,
	time_measure,
	velocity_measure,
	volume_measure);
END_TYPE;

TYPE mechanical_design_and_draughting_relationship_select = SELECT (
	draughting_model,
	mechanical_design_geometric_presentation_representation,
	mechanical_design_presentation_representation_with_draughting,
	mechanical_design_shaded_presentation_representation,
	shape_representation);
END_TYPE;

TYPE mechanical_design_geometric_presentation_area_items = SELECT (
	axis2_placement,
	mapped_item);
END_TYPE;

TYPE mechanical_design_geometric_presentation_representation_items = SELECT (
	axis2_placement,
	camera_model_d3,
	mapped_item,
	styled_item);
END_TYPE;

TYPE mechanical_design_shaded_presentation_area_items = SELECT (
	axis2_placement,
	mapped_item);
END_TYPE;

TYPE mechanical_design_shaded_presentation_representation_items = SELECT (
	axis2_placement,
	camera_model_d3,
	mapped_item,
	styled_item);
END_TYPE;

TYPE mesh_location = ENUMERATION OF (
	application_defined,
	cell_centre,
	edge_centre,
	face_centre,
	iface_centre,
	jface_centre,
	kface_centre,
	unspecified,
	vertices );
END_TYPE;

TYPE mesh_maths_space_type = ENUMERATION OF (
	cells,
	vertices );
END_TYPE;

TYPE message = STRING;
END_TYPE;

TYPE message_level = ENUMERATION OF (
	error,
	warning,
	note );
END_TYPE;

TYPE minute_in_hour = INTEGER;
WHERE
	WR1 : { 0 <= SELF <= 59 };
END_TYPE;

TYPE mismatched_region_type = ENUMERATION OF (
	abutting,
	overset );
END_TYPE;

TYPE model_or_control_element = SELECT (
	element_representation,
	constraint_element);
END_TYPE;

TYPE month_in_year_number = INTEGER;
WHERE
	WR1 : { 1 <= SELF <= 12 };
END_TYPE;

TYPE multi_language_attribute_item = SELECT (
	alternate_product_relationship,
	application_context,
	applied_certification_assignment,
	applied_document_reference,
	applied_document_usage_constraint_assignment,
	applied_external_identification_assignment,
	applied_identification_assignment,
	applied_organizational_project_assignment,
	approval,
	approval_relationship,
	approval_status,
	assembly_component_usage_substitute,
	attribute_value_assignment,
	certification,
	certification_type,
	colour,
	configuration_design,
	configuration_item,
	contract,
	date_role,
	date_time_role,
	descriptive_representation_item,
	document_relationship,
	document_usage_role,
	effectivity,
	effectivity_relationship,
	event_occurrence,
	external_source,
	general_property,
	general_property_relationship,
	geometric_representation_item,
	geometric_tolerance,
	identification_role,
	information_right,
	information_usage_right,
	make_from_usage_option,
	mapped_item,
	object_role,
	organization_relationship,
	organization_role,
	organizational_project,
	organizational_project_relationship,
	organizational_project_role,
	person_and_organization,
	person_and_organization_role,
	product,
	product_concept,
	product_concept_relationship,
	product_definition,
	product_definition_context,
	product_definition_formation,
	product_definition_formation_relationship,
	product_definition_relationship,
	product_definition_shape,
	product_related_product_category,
	property_definition,
	representation,
	representation_relationship,
	security_classification,
	security_classification_assignment,
	shape_aspect,
	shape_aspect_relationship,
	shape_representation,
	time_interval_role,
	topological_representation_item,
	uncertainty_measure_with_unit,
	usage_association);
END_TYPE;

TYPE name_attribute_select = SELECT (
	action_request_solution,
	address,
	configuration_design,
	context_dependent_shape_representation,
	derived_unit,
	effectivity,
	person_and_organization,
	product_definition,
	product_definition_substitute,
	property_definition_representation);
END_TYPE;

TYPE name_item = SELECT (
	assembly_component_usage,
	external_class_library,
	group,
	group_relationship,
	product,
	product_definition);
END_TYPE;

TYPE node_or_node_group = SELECT (
	node_representation,
	node_group);
END_TYPE;

TYPE node_output_reference = SELECT (
	node_representation,
	node_group,
	substructure_node_reference,
	analysis_item_within_representation);
END_TYPE;

TYPE non_negative_length_measure = length_measure;
WHERE
	WR1 : SELF >= 0.0;
END_TYPE;

TYPE nonnegative_integer = INTEGER;
WHERE
	nonnegativity : SELF >= 0;
END_TYPE;

TYPE null_style = ENUMERATION OF (
	null );
END_TYPE;

TYPE numeric_measure = NUMBER;
END_TYPE;

TYPE one_or_two = positive_integer;
WHERE
	in_range : (SELF = 1) OR (SELF = 2);
END_TYPE;

TYPE open_closed = ENUMERATION OF (
	open,
	closed );
END_TYPE;

TYPE ordering_type = ENUMERATION OF (
	by_rows,
	by_columns );
END_TYPE;

TYPE organization_item = SELECT (
	action,
	action_directive,
	alternate_product_relationship,
	applied_action_assignment,
	applied_classification_assignment,
	applied_identification_assignment,
	applied_security_classification_assignment,
	approval,
	assembly_component_usage_substitute,
	certification,
	class,
	configuration_item,
	contract,
	document_file,
	executed_action,
	general_property,
	information_usage_right,
	organizational_project,
	product,
	product_definition,
	product_definition_formation,
	product_definition_formation_relationship,
	property_definition,
	rule_action,
	security_classification,
	shape_representation,
	versioned_action_request);
END_TYPE;

TYPE orientation_basis_select = SELECT (
	axis2_placement_3d,
	min_and_major_ply_orientation_basis);
END_TYPE;

TYPE orthotropic_symmetric_tensor2_3d = ARRAY [1:3] OF context_dependent_measure;
END_TYPE;

TYPE parameter_value = REAL;
END_TYPE;

TYPE pcurve_or_surface = SELECT (
	pcurve,
	surface);
END_TYPE;

TYPE person_and_organization_item = SELECT (
	action,
	action_directive,
	alternate_product_relationship,
	applied_action_assignment,
	applied_classification_assignment,
	applied_identification_assignment,
	applied_security_classification_assignment,
	approval,
	assembly_component_usage_substitute,
	certification,
	configuration_item,
	contract,
	document_file,
	executed_action,
	general_property,
	information_usage_right,
	organizational_project,
	person_and_organization,
	product,
	product_definition,
	product_definition_formation,
	product_definition_formation_relationship,
	property_definition,
	rule_action,
	security_classification,
	shape_representation,
	versioned_action_request);
END_TYPE;

TYPE person_organization_select = SELECT (
	person,
	organization,
	person_and_organization);
END_TYPE;

TYPE picture_representation_item_select = SELECT (
	styled_item,
	planar_box,
	axis2_placement_2d);
END_TYPE;

TYPE plane_2d_element_purpose = SELECT (
	enumerated_plane_2d_element_purpose,
	application_defined_element_purpose);
END_TYPE;

TYPE plane_angle_measure = REAL;
END_TYPE;

TYPE plane_or_planar_box = SELECT (
	plane,
	planar_box);
END_TYPE;

TYPE point_and_vector_member = SELECT (
	point,
	direction);
END_TYPE;

TYPE point_and_vector_members = LIST [2:3] OF point_and_vector_member;
END_TYPE;

TYPE point_path_members = LIST [1:?] OF point_and_vector;
END_TYPE;

TYPE positive_integer = nonnegative_integer;
WHERE
	positivity : SELF > 0;
END_TYPE;

TYPE positive_length_measure = non_negative_length_measure;
WHERE
	WR1 : SELF > 0.0;
END_TYPE;

TYPE positive_plane_angle_measure = plane_angle_measure;
WHERE
	WR1 : SELF > 0.0;
END_TYPE;

TYPE positive_ratio_measure = ratio_measure;
WHERE
	WR1 : SELF > 0.0;
END_TYPE;

TYPE power_measure = REAL;
END_TYPE;

TYPE preferred_surface_curve_representation = ENUMERATION OF (
	curve_3d,
	pcurve_s1,
	pcurve_s2 );
END_TYPE;

TYPE presentable_text = STRING;
WHERE
	WR1 : control_characters_free(SELF);
END_TYPE;

TYPE presentation_representation_select = SELECT (
	presentation_representation,
	presentation_set);
END_TYPE;

TYPE presentation_size_assignment_select = SELECT (
	presentation_view,
	presentation_area,
	area_in_set);
END_TYPE;

TYPE presentation_style_select = SELECT (
	point_style,
	curve_style,
	surface_style_usage,
	symbol_style,
	fill_area_style,
	text_style,
	null_style);
END_TYPE;

TYPE presented_item_select = SELECT (
	action,
	action_method,
	action_relationship,
	product_concept,
	product_concept_feature,
	product_concept_feature_category,
	product_definition,
	product_definition_formation,
	product_definition_relationship);
END_TYPE;

TYPE pressure_measure = REAL;
END_TYPE;

TYPE product_definition_or_assembly_relationship = SELECT (
	assembly_component_usage,
	product_definition);
END_TYPE;

TYPE product_definition_or_breakdown_element_usage = SELECT (
	product_definition,
	product_definition_usage);
END_TYPE;

TYPE product_definition_or_product_definition_relationship = SELECT (
	product_definition,
	product_definition_usage);
END_TYPE;

TYPE product_or_formation_or_definition = SELECT (
	product,
	product_definition_formation,
	product_definition);
END_TYPE;

TYPE product_space = SELECT (
	uniform_product_space,
	listed_product_space);
END_TYPE;

TYPE project_item = SELECT (
	executed_action,
	product_concept);
END_TYPE;

TYPE property_distribution_select = SELECT (
	action_property,
	general_property_relationship,
	model_property_distribution,
	property_definition,
	resource_property);
END_TYPE;

TYPE radioactivity_measure = REAL;
END_TYPE;

TYPE ratio_measure = REAL;
END_TYPE;

TYPE real_interval = SELECT (
	real_interval_from_min,
	real_interval_to_max,
	finite_real_interval,
	elementary_space);
WHERE
	WR1 : NOT ('ELEMENTARY_SPACE' IN stripped_typeof(SELF)) OR
    (SELF\elementary_space.space_id = es_reals);
END_TYPE;

TYPE rendering_properties_select = SELECT (
	surface_style_reflectance_ambient,
	surface_style_transparent);
END_TYPE;

TYPE repackage_options = ENUMERATION OF (
	ro_nochange,
	ro_wrap_as_tuple,
	ro_unwrap_tuple );
END_TYPE;

TYPE represented_definition = SELECT (
	general_property,
	property_definition,
	property_definition_relationship,
	shape_aspect,
	shape_aspect_relationship);
END_TYPE;

TYPE requirement_assigned_item = SELECT (
	configuration_item,
	descriptive_representation_item,
	product,
	product_class,
	product_definition,
	product_definition_formation,
	product_definition_relationship,
	representation,
	shape_aspect);
END_TYPE;

TYPE requirement_satisfaction_item = SELECT (
	requirement_assigned_item);
END_TYPE;

TYPE requirement_source_item = SELECT (
	characterized_object,
	group,
	group_relationship,
	product,
	product_definition,
	product_definition_formation,
	product_definition_relationship,
	shape_aspect);
END_TYPE;

TYPE resistance_measure = REAL;
END_TYPE;

TYPE reversible_topology = SELECT (
	reversible_topology_item,
	list_of_reversible_topology_item,
	set_of_reversible_topology_item);
END_TYPE;

TYPE reversible_topology_item = SELECT (
	edge,
	path,
	face,
	face_bound,
	closed_shell,
	open_shell);
END_TYPE;

TYPE Riemann_1D_data_name = ENUMERATION OF (
	characteristic_acoustic_minus,
	characteristic_acoustic_plus,
	characteristic_entropy,
	characteristic_vorticity1,
	characteristic_vorticity2,
	Riemann_invariant_minus,
	Riemann_invariant_plus );
END_TYPE;

TYPE role_select = SELECT (
	action_assignment,
	action_request_assignment,
	approval_assignment,
	approval_date_time,
	certification_assignment,
	contract_assignment,
	document_reference,
	effectivity_assignment,
	group_assignment,
	name_assignment,
	security_classification_assignment);
END_TYPE;

TYPE rule_superseded_item = SELECT (
	product_definition_formation);
END_TYPE;

TYPE scalar = context_dependent_measure;
END_TYPE;

TYPE second_in_minute = REAL;
WHERE
	WR1 : { 0 <= SELF <= 60.0 };
END_TYPE;

TYPE security_classification_item = SELECT (
	assembly_component_usage,
	document,
	document_file,
	make_from_usage_option,
	product,
	product_definition,
	product_definition_formation,
	product_definition_usage);
END_TYPE;

TYPE set_of_reversible_topology_item = SET [0:?] OF reversible_topology_item;
END_TYPE;

TYPE set_representation_item = SET [1:?] OF representation_item;
END_TYPE;

TYPE shading_curve_method = ENUMERATION OF (
	constant_colour,
	linear_colour );
END_TYPE;

TYPE shading_surface_method = ENUMERATION OF (
	constant_shading,
	colour_shading,
	dot_shading,
	normal_shading );
END_TYPE;

TYPE shape_definition = SELECT (
	product_definition_shape,
	shape_aspect,
	shape_aspect_relationship);
END_TYPE;

TYPE shape_function = ENUMERATION OF (
	lagrangian_function,
	serendipity_function,
	hermitian_function,
	unspecified_function );
END_TYPE;

TYPE shell = SELECT (
	vertex_shell,
	wire_shell,
	open_shell,
	closed_shell);
END_TYPE;

TYPE si_prefix = ENUMERATION OF (
	exa,
	peta,
	tera,
	giga,
	mega,
	kilo,
	hecto,
	deca,
	deci,
	centi,
	milli,
	micro,
	nano,
	pico,
	femto,
	atto );
END_TYPE;

TYPE si_unit_name = ENUMERATION OF (
	metre,
	gram,
	second,
	ampere,
	kelvin,
	mole,
	candela,
	radian,
	steradian,
	hertz,
	newton,
	pascal,
	joule,
	watt,
	coulomb,
	volt,
	farad,
	ohm,
	siemens,
	weber,
	tesla,
	henry,
	degree_Celsius,
	lumen,
	lux,
	becquerel,
	gray,
	sievert );
END_TYPE;

TYPE size_select = SELECT (
	positive_length_measure,
	measure_with_unit,
	descriptive_measure);
END_TYPE;

TYPE sketch_basis_select = SELECT (
	curve_bounded_surface,
	face_surface);
END_TYPE;

TYPE solid_angle_measure = REAL;
END_TYPE;

TYPE source = ENUMERATION OF (
	made,
	bought,
	not_known );
END_TYPE;

TYPE source_item = SELECT (
	identifier,
	message);
END_TYPE;

TYPE space_constraint_type = ENUMERATION OF (
	sc_equal,
	sc_subspace,
	sc_member );
END_TYPE;

TYPE space_context_select = SELECT (
	action,
	action_method,
	general_property,
	product_definition,
	representation_item,
	shape_aspect);
END_TYPE;

TYPE start_request_item = SELECT (
	product_definition_formation);
END_TYPE;

TYPE string_representation_item_select = SELECT (
	descriptive_representation_item,
	included_text_block,
	structured_text_composition);
END_TYPE;

TYPE structured_mesh_type = ENUMERATION OF (
	pentahedral,
	pyramidal,
	rectangular,
	tetrahedral );
END_TYPE;

TYPE style_context_select = SELECT (
	group,
	presentation_layer_assignment,
	presentation_set,
	representation,
	representation_item,
	representation_relationship);
END_TYPE;

TYPE supported_item = SELECT (
	action_directive,
	action,
	action_method);
END_TYPE;

TYPE surface_2d_edge = INTEGER;
WHERE
	WR1 : (SELF >= 1) AND (SELF <= 2);
END_TYPE;

TYPE surface_2d_element_coordinate_system = SELECT (
	aligned_surface_2d_element_coordinate_system,
	parametric_surface_2d_element_coordinate_system);
END_TYPE;

TYPE surface_2d_element_descriptor = SELECT (
	axisymmetric_surface_2d_element_descriptor,
	plane_surface_2d_element_descriptor);
END_TYPE;

TYPE surface_2d_element_length_integration = SELECT (
	element_integration_algebraic,
	surface_2d_element_length_integration_rule,
	surface_2d_element_length_integration_explicit);
END_TYPE;

TYPE surface_2d_element_output_reference = SELECT (
	surface_2d_element_representation,
	surface_2d_element_descriptor,
	surface_2d_element_group,
	surface_2d_substructure_element_reference,
	analysis_item_within_representation);
END_TYPE;

TYPE surface_2d_element_representation = SELECT (
	axisymmetric_surface_2d_element_representation,
	plane_surface_2d_element_representation);
END_TYPE;

TYPE surface_2d_face = INTEGER;
WHERE
	WR1 : (SELF >= 1) AND (SELF <= 2);
END_TYPE;

TYPE surface_2d_state_coordinate_system = SELECT (
	fea_axis2_placement_3d,
	surface_2d_element_coordinate_system);
END_TYPE;

TYPE surface_3d_edge = INTEGER;
WHERE
	WR1 : (SELF >= 1) AND (SELF <= 4);
END_TYPE;

TYPE surface_3d_element_coordinate_system = SELECT (
	aligned_surface_3d_element_coordinate_system,
	parametric_surface_3d_element_coordinate_system,
	constant_surface_3d_element_coordinate_system);
END_TYPE;

TYPE surface_3d_element_field_integration = SELECT (
	element_integration_algebraic,
	surface_3d_element_field_integration_rule,
	surface_3d_element_field_integration_explicit);
END_TYPE;

TYPE surface_3d_element_output_reference = SELECT (
	surface_3d_element_representation,
	surface_3d_element_descriptor,
	surface_3d_element_group,
	surface_3d_substructure_element_reference,
	analysis_item_within_representation);
END_TYPE;

TYPE surface_3d_face = INTEGER;
WHERE
	WR1 : (SELF >= 1) AND (SELF <= 2);
END_TYPE;

TYPE surface_3d_state_coordinate_system = SELECT (
	fea_axis2_placement_3d,
	surface_3d_element_coordinate_system);
END_TYPE;

TYPE surface_element_purpose = SELECT (
	enumerated_surface_element_purpose,
	application_defined_element_purpose);
END_TYPE;

TYPE surface_element_variable = SELECT (
	volume_variable,
	surface_scalar_variable,
	surface_vector_2d_variable,
	surface_vector_3d_variable,
	surface_tensor2_2d_variable,
	application_defined_tensor2_2d_variable);
END_TYPE;

TYPE surface_matrix_property_type = SELECT (
	enumerated_surface_matrix_property_type,
	application_defined_matrix_property_type);
END_TYPE;

TYPE surface_scalar_variable = ENUMERATION OF (
	thickness,
	surface_thermal_gradient,
	reference_surface_thermal_gradient );
END_TYPE;

TYPE surface_section_integration = SELECT (
	element_integration_algebraic,
	surface_section_integration_rule,
	surface_section_integration_explicit);
END_TYPE;

TYPE surface_side = ENUMERATION OF (
	positive,
	negative,
	both );
END_TYPE;

TYPE surface_side_style_select = SELECT (
	surface_side_style,
	pre_defined_surface_side_style);
END_TYPE;

TYPE surface_style_element_select = SELECT (
	surface_style_fill_area,
	surface_style_boundary,
	surface_style_silhouette,
	surface_style_segmentation_curve,
	surface_style_control_grid,
	surface_style_parameter_line,
	surface_style_rendering);
END_TYPE;

TYPE surface_tensor2_2d_variable = ENUMERATION OF (
	surface_membrane_force,
	surface_membrane_strain,
	surface_bending_moment,
	surface_curvature );
END_TYPE;

TYPE surface_vector_2d_variable = ENUMERATION OF (
	surface_out_of_plane_shear_force,
	surface_out_of_plane_shear_strain );
END_TYPE;

TYPE surface_vector_3d_variable = ENUMERATION OF (
	applied_force_per_unit_area,
	applied_moment_per_unit_area );
END_TYPE;

TYPE symbol_style_select = SELECT (
	symbol_colour);
END_TYPE;

TYPE symmetric_tensor2_2d = SELECT (
	anisotropic_symmetric_tensor2_2d);
END_TYPE;

TYPE symmetric_tensor2_3d = SELECT (
	isotropic_symmetric_tensor2_3d,
	orthotropic_symmetric_tensor2_3d,
	anisotropic_symmetric_tensor2_3d);
END_TYPE;

TYPE symmetric_tensor4_2d = SELECT (
	anisotropic_symmetric_tensor4_2d);
END_TYPE;

TYPE symmetric_tensor4_3d = SELECT (
	anisotropic_symmetric_tensor4_3d,
	fea_isotropic_symmetric_tensor4_3d,
	fea_iso_orthotropic_symmetric_tensor4_3d,
	fea_transverse_isotropic_symmetric_tensor4_3d,
	fea_column_normalised_orthotropic_symmetric_tensor4_3d,
	fea_column_normalised_monoclinic_symmetric_tensor4_3d);
END_TYPE;

TYPE symmetry_type = ENUMERATION OF (
	identity,
	skew,
	hermitian,
	skew_hermitian );
END_TYPE;

TYPE tensor1_2d = ARRAY [1:2] OF context_dependent_measure;
END_TYPE;

TYPE tensor1_3d = ARRAY [1:3] OF context_dependent_measure;
END_TYPE;

TYPE tensor_type = SELECT (
	scalar,
	angular_value,
	tensor1_2d,
	tensor1_3d,
	anisotropic_symmetric_tensor2_2d,
	isotropic_symmetric_tensor2_3d,
	orthotropic_symmetric_tensor2_3d,
	anisotropic_symmetric_tensor2_3d,
	anisotropic_symmetric_tensor4_2d,
	anisotropic_symmetric_tensor4_3d,
	fea_isotropic_symmetric_tensor4_3d,
	fea_iso_orthotropic_symmetric_tensor4_3d,
	fea_transverse_isotropic_symmetric_tensor4_3d,
	fea_column_normalised_orthotropic_symmetric_tensor4_3d,
	fea_column_normalised_monoclinic_symmetric_tensor4_3d);
END_TYPE;

TYPE text = STRING;
END_TYPE;

TYPE text_alignment = label;
END_TYPE;

TYPE text_delineation = label;
END_TYPE;

TYPE text_or_character = SELECT (
	annotation_text,
	annotation_text_character,
	composite_text,
	text_literal);
END_TYPE;

TYPE text_path = ENUMERATION OF (
	left,
	right,
	up,
	down );
END_TYPE;

TYPE text_string_representation_item = SELECT (
	text_literal,
	annotation_text,
	annotation_text_character,
	composite_text,
	axis2_placement);
END_TYPE;

TYPE thermal_conductivity_model_data_name = ENUMERATION OF (
	constant_Prandtl,
	power_law_exponent,
	Sutherland_constant_conductivity,
	temperature_reference,
	thermal_conductivity_reference );
END_TYPE;

TYPE thermal_conductivity_model_type = ENUMERATION OF (
	application_defined,
	constant_Prandtl,
	independent,
	power_law,
	Sutherland_law,
	unspecified );
END_TYPE;

TYPE thermodynamic_temperature_measure = REAL;
END_TYPE;

TYPE time_interval_item = SELECT (
	action,
	time_interval_based_effectivity);
END_TYPE;

TYPE time_measure = REAL;
END_TYPE;

TYPE tolerance_method_definition = SELECT (
	tolerance_value,
	limits_and_fits);
END_TYPE;

TYPE transformation = SELECT (
	item_defined_transformation,
	functionally_defined_transformation);
END_TYPE;

TYPE transition_code = ENUMERATION OF (
	discontinuous,
	continuous,
	cont_same_gradient,
	cont_same_gradient_same_curvature );
END_TYPE;

TYPE trim_condition_select = SELECT (
	length_measure,
	plane_angle_measure,
	generalized_surface_select,
	solid_model);
END_TYPE;

TYPE trim_intent = ENUMERATION OF (
	blind,
	offset,
	through_all,
	unspecified,
	up_to_next );
END_TYPE;

TYPE trimming_preference = ENUMERATION OF (
	cartesian,
	parameter,
	unspecified );
END_TYPE;

TYPE trimming_select = SELECT (
	cartesian_point,
	parameter_value);
END_TYPE;

TYPE tuple_space = SELECT (
	product_space,
	extended_tuple_space);
END_TYPE;

TYPE turbulence_closure_data_name = ENUMERATION OF (
	eddy_viscosity,
	Prandtl_turbulent );
END_TYPE;

TYPE turbulence_closure_type = ENUMERATION OF (
	application_defined,
	eddy_viscosity,
	Reynolds_stress,
	Reynolds_stress_algebraic,
	unspecified );
END_TYPE;

TYPE turbulence_model_data_name = ENUMERATION OF (
	turbulent_BB_Reynolds,
	turbulent_dissipation,
	turbulent_dissipation_rate,
	turbulent_distance,
	turbulent_energy_kinetic,
	turbulent_SA_cb1,
	turbulent_SA_cb2,
	turbulent_SA_chi,
	turbulent_SA_ct1,
	turbulent_SA_ct2,
	turbulent_SA_ct3,
	turbulent_SA_ct4,
	turbulent_SA_cv1,
	turbulent_SA_cw1,
	turbulent_SA_cw2,
	turbulent_SA_cw3,
	turbulent_SA_kappa,
	turbulent_SA_nu_tilde,
	turbulent_SA_sigma );
END_TYPE;

TYPE turbulence_model_type = ENUMERATION OF (
	algebraic_Baldwin_Lomax,
	algebraic_Cebeci_Smith,
	application_defined,
	half_equation_Johnson_King,
	one_equation_Baldwin_Barth,
	one_equation_Spalart_Allmaras,
	two_equation_Jones_Launder,
	two_equation_Menter_SST,
	two_equation_Wilcox,
	unspecified );
END_TYPE;

TYPE u_direction_count = INTEGER;
WHERE
	WR1 : SELF > 1;
END_TYPE;

TYPE unit = SELECT (
	derived_unit,
	named_unit);
END_TYPE;

TYPE unspecified_value = ENUMERATION OF (
	unspecified );
END_TYPE;

TYPE v_direction_count = INTEGER;
WHERE
	WR1 : SELF > 1;
END_TYPE;

TYPE value_context_select = SELECT (
	action,
	action_method,
	choose_representation_context_identifier,
	general_property,
	product_definition,
	representation_item,
	shape_aspect);
END_TYPE;

TYPE value_qualifier = SELECT (
	precision_qualifier,
	type_qualifier,
	uncertainty_qualifier);
END_TYPE;

TYPE vector_or_direction = SELECT (
	vector,
	direction);
END_TYPE;

TYPE velocity_measure = REAL;
END_TYPE;

TYPE viscosity_model_data_name = ENUMERATION OF (
	Sutherland_constant_viscosity,
	viscosity_molecular_reference );
END_TYPE;

TYPE viscosity_model_type = ENUMERATION OF (
	application_defined,
	constant_viscosity,
	power_law,
	Sutherland_law,
	unspecified );
END_TYPE;

TYPE volume_2d_edge = INTEGER;
WHERE
	WR1 : (SELF >= 1) AND (SELF <= 4);
END_TYPE;

TYPE volume_2d_element_coordinate_system = SELECT (
	arbitrary_volume_2d_element_coordinate_system,
	parametric_volume_2d_element_coordinate_system);
END_TYPE;

TYPE volume_2d_element_descriptor = SELECT (
	axisymmetric_volume_2d_element_descriptor,
	plane_volume_2d_element_descriptor);
END_TYPE;

TYPE volume_2d_element_field_integration = SELECT (
	element_integration_algebraic,
	volume_2d_element_field_integration_rule,
	volume_2d_element_field_integration_explicit);
END_TYPE;

TYPE volume_2d_element_output_reference = SELECT (
	volume_2d_element_representation,
	volume_2d_element_descriptor,
	volume_2d_element_group,
	volume_2d_substructure_element_reference,
	analysis_item_within_representation);
END_TYPE;

TYPE volume_2d_element_representation = SELECT (
	axisymmetric_volume_2d_element_representation,
	plane_volume_2d_element_representation);
END_TYPE;

TYPE volume_2d_face = INTEGER;
WHERE
	WR1 : (SELF >= 1) AND (SELF <= 4);
END_TYPE;

TYPE volume_3d_edge = INTEGER;
WHERE
	WR1 : (SELF >= 1) AND (SELF <= 12);
END_TYPE;

TYPE volume_3d_element_coordinate_system = SELECT (
	arbitrary_volume_3d_element_coordinate_system,
	parametric_volume_3d_element_coordinate_system);
END_TYPE;

TYPE volume_3d_element_field_integration = SELECT (
	element_integration_algebraic,
	volume_3d_element_field_integration_rule,
	volume_3d_element_field_integration_explicit);
END_TYPE;

TYPE volume_3d_element_output_reference = SELECT (
	volume_3d_element_representation,
	volume_3d_element_descriptor,
	volume_3d_element_group,
	volume_3d_substructure_element_reference,
	analysis_item_within_representation);
END_TYPE;

TYPE volume_3d_element_shape = ENUMERATION OF (
	hexahedron,
	wedge,
	tetrahedron,
	pyramid );
END_TYPE;

TYPE volume_3d_face = INTEGER;
WHERE
	WR1 : (SELF >= 1) AND (SELF <= 6);
END_TYPE;

TYPE volume_aggregated_variable = SELECT (
	aggregated_scalar_variable,
	aggregated_angular_variable,
	aggregated_vector_3d_variable,
	aggregated_tensor2_3d_variable,
	application_defined_scalar_variable,
	application_defined_vector_3d_variable,
	application_defined_tensor2_3d_variable);
END_TYPE;

TYPE volume_angular_variable = ENUMERATION OF (
	constant_angular_acceleration,
	application_defined_angular_scalar_variable );
END_TYPE;

TYPE volume_element_purpose = SELECT (
	enumerated_volume_element_purpose,
	application_defined_element_purpose);
END_TYPE;

TYPE volume_measure = REAL;
END_TYPE;

TYPE volume_scalar_variable = ENUMERATION OF (
	temperature,
	moisture,
	reference_temperature,
	strain_energy_per_unit_volume );
END_TYPE;

TYPE volume_tensor2_3d_variable = ENUMERATION OF (
	total_strain,
	stress );
END_TYPE;

TYPE volume_variable = SELECT (
	volume_scalar_variable,
	volume_angular_variable,
	volume_vector_3d_variable,
	volume_tensor2_3d_variable,
	application_defined_scalar_variable,
	application_defined_vector_3d_variable,
	application_defined_tensor2_3d_variable);
END_TYPE;

TYPE volume_vector_3d_variable = ENUMERATION OF (
	position,
	applied_force_per_unit_volume,
	applied_moment_per_unit_volume,
	displacement,
	infinitesimal_rotation,
	acceleration );
END_TYPE;

TYPE week_in_year_number = INTEGER;
WHERE
	WR1 : { 1 <= SELF <= 53 };
END_TYPE;

TYPE work_item = SELECT (
	product_definition_formation);
END_TYPE;

TYPE year_number = INTEGER;
END_TYPE;

TYPE zero_or_one = nonnegative_integer;
WHERE
	in_range : (SELF = 0) OR (SELF = 1);
END_TYPE;

ENTITY abs_function
	SUBTYPE OF (unary_function_call);
END_ENTITY;


ENTITY absorbed_dose_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ABSORBED_DOSE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY absorbed_dose_unit
	SUBTYPE OF (derived_unit);
WHERE
	WR1 : derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.gray);
END_ENTITY;


ENTITY abstract_variable
	SUBTYPE OF (property_definition, property_definition_representation, representation, representation_item);
END_ENTITY;


ENTITY abstracted_expression_function
	SUBTYPE OF (maths_function, quantifier_expression);
DERIVE
	expr : generic_expression := SELF\multiple_arity_generic_expression.operands[1];
	SELF\quantifier_expression.variables : LIST [1:?] OF  UNIQUE generic_variable := remove_first(SELF\multiple_arity_generic_expression.operands);
WHERE
	WR1 : SIZEOF (QUERY ( operand <*
       SELF\multiple_arity_generic_expression.operands | NOT (
       has_values_space( operand)))) = 0;
END_ENTITY;


ENTITY acceleration_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ACCELERATION_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY acceleration_unit
	SUBTYPE OF (derived_unit);
WHERE
	WR1 : derive_dimensional_exponents(SELF) = 
       dimensional_exponents ( 1.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0 );
END_ENTITY;


ENTITY acos_function
	SUBTYPE OF (unary_function_call);
END_ENTITY;


ENTITY action;
	name : label;
	description : OPTIONAL text;
	chosen_method : action_method;
DERIVE
	id : identifier := get_id_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;


ENTITY action_assignment
	ABSTRACT SUPERTYPE;
	assigned_action : action;
DERIVE
	role : object_role := get_role(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;


ENTITY action_directive;
	name : label;
	description : OPTIONAL text;
	analysis : text;
	comment : text;
	requests : SET [1:?] OF versioned_action_request;
END_ENTITY;


ENTITY action_method;
	name : label;
	description : OPTIONAL text;
	consequence : text;
	purpose : text;
END_ENTITY;


ENTITY action_method_assignment
	ABSTRACT SUPERTYPE;
	assigned_action_method : action_method;
	role : action_method_role;
END_ENTITY;


ENTITY action_method_relationship;
	name : label;
	description : OPTIONAL text;
	relating_method : action_method;
	related_method : action_method;
END_ENTITY;


ENTITY action_method_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY;


ENTITY action_property;
	name : label;
	description : text;
	definition : characterized_action_definition;
END_ENTITY;


ENTITY action_property_representation;
	name : label;
	description : text;
	property : action_property;
	representation : representation;
END_ENTITY;


ENTITY action_relationship;
	name : label;
	description : OPTIONAL text;
	relating_action : action;
	related_action : action;
END_ENTITY;


ENTITY action_request_assignment
	ABSTRACT SUPERTYPE;
	assigned_action_request : versioned_action_request;
DERIVE
	role : object_role := get_role(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;


ENTITY action_request_solution;
	method : action_method;
	request : versioned_action_request;
DERIVE
	description : text := get_description_value(SELF);
	name : label := get_name_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
	WR2 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;


ENTITY action_request_status;
	status : label;
	assigned_request : versioned_action_request;
END_ENTITY;


ENTITY action_resource;
	name : label;
	description : OPTIONAL text;
	usage : SET [1:?] OF supported_item;
	kind : action_resource_type;
END_ENTITY;


ENTITY action_resource_relationship;
	name : label;
	description : OPTIONAL text;
	relating_resource : action_resource;
	related_resource : action_resource;
END_ENTITY;


ENTITY action_resource_type;
	name : label;
END_ENTITY;


ENTITY action_status;
	status : label;
	assigned_action : executed_action;
END_ENTITY;


ENTITY action_view_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	discretised_model : discretised_action_model_select;
	idealised_action : idealised_action_select;
END_ENTITY;


ENTITY address;
	internal_location : OPTIONAL label;
	street_number : OPTIONAL label;
	street : OPTIONAL label;
	postal_box : OPTIONAL label;
	town : OPTIONAL label;
	region : OPTIONAL label;
	postal_code : OPTIONAL label;
	country : OPTIONAL label;
	facsimile_number : OPTIONAL label;
	telephone_number : OPTIONAL label;
	electronic_mail_address : OPTIONAL label;
	telex_number : OPTIONAL label;
DERIVE
	name : label := get_name_value(SELF);
	url : identifier := get_id_value(SELF);
WHERE
	WR1 : EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(facsimile_number) OR EXISTS(telephone_number) OR EXISTS(electronic_mail_address) OR EXISTS(telex_number);
END_ENTITY;


ENTITY advanced_brep_shape_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 : SIZEOF ( 
QUERY ( it <* SELF.items| NOT ( SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACETED_BREP', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D' ] * TYPEOF (it)) = 1) )) = 0;
	WR2 : SIZEOF ( 
QUERY ( it <* SELF.items| ( SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' ] * TYPEOF (it)) = 1) )) > 0;
	WR3 : SIZEOF ( 
QUERY ( msb <* 
QUERY ( it <* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( csh <* msb_shells(msb)| NOT ( SIZEOF ( 
QUERY ( fcs <* csh\connected_face_set.cfs_faces| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fcs)) )) = 0) )) = 0) )) = 0;
	WR4 : SIZEOF ( 
QUERY ( msb <* 
QUERY ( it <* items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF (it)) )| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_CLOSED_SHELL' IN TYPEOF (msb\manifold_solid_brep.outer)) )) = 0;
	WR5 : SIZEOF ( 
QUERY ( brv <* 
QUERY ( it <* items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BREP_WITH_VOIDS' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( csh <* brv\brep_with_voids.voids| csh\oriented_closed_shell.orientation )) = 0) )) = 0;
	WR6 : SIZEOF ( 
QUERY ( mi <* 
QUERY ( it <* items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_BREP_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
END_ENTITY;


ENTITY advanced_face
	SUBTYPE OF (face_surface);
WHERE
	WR1 : SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELEMENTARY_SURFACE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_SURFACE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SWEPT_SURFACE' ] * TYPEOF (face_geometry)) = 1;
	WR2 : SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_CURVE' IN TYPEOF (oe\oriented_edge.edge_element)) )) = 0) )) = 0;
	WR3 : SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| NOT ( SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONIC', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE' ] * TYPEOF (oe.edge_element\edge_curve.edge_geometry)) = 1) )) = 0) )) = 0;
	WR4 : SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| NOT ((('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF (oe\edge.edge_start)) AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT' IN TYPEOF (oe\edge.edge_start\vertex_point.vertex_geometry))) AND (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF (oe\edge.edge_end)) AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT' IN TYPEOF (oe\edge.edge_end\vertex_point.vertex_geometry)))) )) = 0) )) = 0;
	WR5 : SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_PATH' IN TYPEOF (elp_fbnds.bound)) )) = 0;
	WR6 : NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SWEPT_SURFACE' IN TYPEOF (face_geometry)) OR ( SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONIC', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE' ] * TYPEOF (face_geometry\swept_surface.swept_curve)) = 1);
	WR7 : SIZEOF ( 
QUERY ( vlp_fbnds <* 
QUERY ( bnds <* bounds| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_LOOP' IN TYPEOF (bnds.bound)) )| NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF (vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT' IN TYPEOF (vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex\vertex_point.vertex_geometry))) )) = 0;
	WR8 : SIZEOF ( 
QUERY ( bnd <* bounds| NOT ( SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_LOOP' ] * TYPEOF (bnd.bound)) = 1) )) = 0;
	WR9 : SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE' IN TYPEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND NOT ( SIZEOF ( 
QUERY ( sc_ag <* oe.edge_element\edge_curve.edge_geometry\surface_curve.associated_geometry| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN TYPEOF (sc_ag)) )) = 0) )) = 0) )) = 0;
	WR10 : (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SWEPT_SURFACE' IN TYPEOF (face_geometry)) OR (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN TYPEOF (face_geometry\swept_surface.swept_curve)) OR ( SIZEOF (face_geometry\swept_surface.swept_curve\polyline.points) >= 3))) AND ( SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN TYPEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND NOT ( SIZEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry\polyline.points) >= 3) )) = 0) )) = 0);
END_ENTITY;


ENTITY aligned_axis_tolerance;
	model_ref : fea_model;
	tolerance : context_dependent_measure;
END_ENTITY;


ENTITY aligned_curve_3d_element_coordinate_system
	SUBTYPE OF (fea_representation_item);
	coordinate_system : fea_axis2_placement_3d;
END_ENTITY;


ENTITY aligned_surface_2d_element_coordinate_system
	SUBTYPE OF (fea_representation_item);
	orientation : direction;
WHERE
	WR1 : SELF\geometric_representation_item.dim=2;
END_ENTITY;


ENTITY aligned_surface_3d_element_coordinate_system
	SUBTYPE OF (fea_representation_item);
	coordinate_system : fea_axis2_placement_3d;
END_ENTITY;


ENTITY alternate_product_relationship;
	name : label;
	definition : OPTIONAL text;
	alternate : product;
	base : product;
	basis : text;
UNIQUE
	UR1 : alternate, base;
WHERE
	WR1 : alternate :<>: base;
END_ENTITY;


ENTITY amount_of_substance_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY amount_of_substance_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;


ENTITY analysis_assignment
	SUBTYPE OF (group);
END_ENTITY;


ENTITY analysis_item
	SUBTYPE OF (group_assignment);
	items : SET [1:1] OF analysed_item;
	SELF\group_assignment.assigned_group : analysis_assignment;
END_ENTITY;


ENTITY analysis_item_within_representation;
	name : label;
	description : text;
	item : representation_item;
	rep : representation;
WHERE
	WR1 : SIZEOF (QUERY (tmp <* using_representations(item) | 
                      tmp :=: rep)) = 1;
END_ENTITY;


ENTITY analysis_message
	SUPERTYPE OF (ONEOF (whole_model_analysis_message, element_analysis_message, node_analysis_message, element_group_analysis_message))
	SUBTYPE OF (state_definition);
	level : message_level;
	message_text : text;
END_ENTITY;


ENTITY analysis_model
	SUBTYPE OF (representation);
	SELF\representation.context_of_items : analysis_representation_context;
END_ENTITY;


ENTITY analysis_representation_context
	SUBTYPE OF (representation_context);
END_ENTITY;


ENTITY analysis_step
	SUPERTYPE OF (ONEOF (control_analysis_step, result_analysis_step));
	analysis_control : control;
END_ENTITY;


ENTITY and_expression
	SUBTYPE OF (multiple_arity_boolean_expression);
END_ENTITY;


ENTITY angle_direction_reference
	SUBTYPE OF (representation_item_relationship, geometric_representation_item);
	SELF\representation_item_relationship.related_representation_item : angle_direction_reference_select;
	SELF\representation_item_relationship.relating_representation_item : orientation_basis_select;
WHERE
	WR1 : ((('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_PATH' IN TYPEOF(related_representation_item)) AND
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MIN_AND_MAJOR_PLY_ORIENTATION_BASIS' IN TYPEOF(relating_representation_item))) 
        OR
		(NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_PATH' IN TYPEOF(related_representation_item)) AND
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D' IN TYPEOF(relating_representation_item))));
END_ENTITY;


ENTITY angular_dimension
	SUBTYPE OF (dimension_curve_directed_callout);
END_ENTITY;


ENTITY angular_location
	SUBTYPE OF (dimensional_location);
	angle_selection : angle_relator;
END_ENTITY;


ENTITY angular_size
	SUBTYPE OF (dimensional_size);
	angle_selection : angle_relator;
END_ENTITY;


ENTITY angularity_tolerance
	SUBTYPE OF (geometric_tolerance_with_datum_reference);
WHERE
	WR1 : SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) < 3;
END_ENTITY;


ENTITY annotation_curve_occurrence
	SUBTYPE OF (annotation_occurrence);
	SELF\styled_item.item : curve;
END_ENTITY;


ENTITY annotation_fill_area
	SUBTYPE OF (geometric_representation_item);
	boundaries : SET [1:?] OF curve;
WHERE
	WR1 : (SELF\geometric_representation_item.dim = 3) OR (SIZEOF (QUERY (curve <* SELF.boundaries |
          NOT (
              ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CIRCLE' IN TYPEOF (curve)) OR 
              ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELLIPSE' IN TYPEOF (curve)) OR 
              ( ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE' IN TYPEOF (curve)) 
                   AND (curve\b_spline_curve.closed_curve = TRUE) ) OR 
              ( ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_CURVE' IN TYPEOF (curve)) 
                   AND (curve\composite_curve.closed_curve = TRUE) ) OR 
              ( ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN TYPEOF (curve)) 
                   AND (curve\polyline.points[LOINDEX(curve\polyline.points)] = 
                        curve\polyline.points[HIINDEX(curve\polyline.points)]) )
              ) )) = 0);
END_ENTITY;


ENTITY annotation_fill_area_occurrence
	SUBTYPE OF (annotation_occurrence);
	fill_style_target : point;
	SELF\styled_item.item : annotation_fill_area;
END_ENTITY;


ENTITY annotation_occurrence
	SUPERTYPE OF (ONEOF (annotation_curve_occurrence, annotation_fill_area_occurrence, annotation_text_occurrence, annotation_symbol_occurrence))
	SUBTYPE OF (styled_item);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN
             TYPEOF (SELF);
	WR2 : SIZEOF (QUERY (reps <* using_representations(SELF) | 
        NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_REPRESENTATION_SELECT' IN TYPEOF(reps)))) = 0;
END_ENTITY;


ENTITY annotation_occurrence_associativity
	SUBTYPE OF (annotation_occurrence_relationship);
WHERE
	WR1 : SIZEOF (TYPEOF (SELF.related_annotation_occurrence) *
          ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_FILL_AREA_OCCURRENCE',
           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROJECTION_CURVE',
           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_CURVE']) = 1;
END_ENTITY;


ENTITY annotation_occurrence_relationship;
	name : label;
	description : text;
	relating_annotation_occurrence : annotation_occurrence;
	related_annotation_occurrence : annotation_occurrence;
END_ENTITY;


ENTITY annotation_plane
	SUBTYPE OF (annotation_occurrence, geometric_representation_item);
	elements : OPTIONAL SET [1:?] OF annotation_plane_element;
	SELF\styled_item.item : plane_or_planar_box;
WHERE
	WR1 : SELF\geometric_representation_item.dim = 3;
	WR2 : NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PLANAR_BOX' IN TYPEOF(SELF\styled_item.item)) OR
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'AXIS2_PLACEMENT_3D' IN TYPEOF(SELF\styled_item.item\planar_box.placement));
	WR3 : (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PLANAR_BOX' IN TYPEOF(SELF\styled_item.item)) AND
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'CURVE_STYLE' IN TYPEOF(SELF\styled_item.styles[1]\presentation_style_assignment.styles[1]))) OR
        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PLANE' IN TYPEOF(SELF\styled_item.item)) AND
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'FILL_AREA_STYLE' IN TYPEOF(SELF\styled_item.styles[1]\presentation_style_assignment.styles[1])));
	WR4 : (SIZEOF(SELF\styled_item.styles) = 1) AND
        (SIZEOF(SELF\styled_item.styles[1]\presentation_style_assignment.styles) = 1);
END_ENTITY;


ENTITY annotation_subfigure_occurrence
	SUBTYPE OF (annotation_symbol_occurrence);
WHERE
	WR1 : SIZEOF (QUERY (sty <* SELF.styles |
         NOT (SIZEOF (sty.styles) = 1)
       )) = 0;
	WR2 : SIZEOF (QUERY (sty <* SELF.styles |
         NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NULL_STYLE'
               IN TYPEOF (sty.styles[1]))       ))=0;
	WR3 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_SYMBOL'
           IN TYPEOF (SELF.item));
	WR4 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAUGHTING_SUBFIGURE_REPRESENTATION'
           IN TYPEOF
           (SELF.item\mapped_item.mapping_source.mapped_representation));
END_ENTITY;


ENTITY annotation_symbol
	SUBTYPE OF (mapped_item);
	SELF\mapped_item.mapping_source : symbol_representation_map;
	SELF\mapped_item.mapping_target : symbol_target;
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN
          TYPEOF (SELF);
END_ENTITY;


ENTITY annotation_symbol_occurrence
	SUBTYPE OF (annotation_occurrence);
	SELF\styled_item.item : annotation_symbol_occurrence_item;
END_ENTITY;


ENTITY annotation_text
	SUBTYPE OF (mapped_item);
	SELF\mapped_item.mapping_target : axis2_placement;
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TEXT_STRING_REPRESENTATION' IN
        TYPEOF( SELF\mapped_item.mapping_source.mapped_representation);
	WR2 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN
        TYPEOF( SELF);
END_ENTITY;


ENTITY annotation_text_character
	SUBTYPE OF (mapped_item);
	alignment : text_alignment;
	SELF\mapped_item.mapping_target : axis2_placement;
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CHARACTER_GLYPH_SYMBOL' IN
         TYPEOF (SELF\mapped_item.mapping_source.mapped_representation);
	WR2 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN
         TYPEOF (SELF);
END_ENTITY;


ENTITY annotation_text_occurrence
	SUBTYPE OF (annotation_occurrence);
	SELF\styled_item.item : annotation_text_occurrence_item;
END_ENTITY;


ENTITY apex
	SUBTYPE OF (derived_shape_aspect);
END_ENTITY;


ENTITY application_context;
	application : label;
DERIVE
	description : text := get_description_value(SELF);
	id : identifier := get_id_value(SELF);
INVERSE
	context_elements: SET [1:?] OF application_context_element FOR frame_of_reference;
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
	WR2 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;


ENTITY application_context_element
	SUPERTYPE OF (ONEOF (product_concept_context, product_context, product_definition_context));
	name : label;
	frame_of_reference : application_context;
END_ENTITY;


ENTITY application_defined_function
	SUBTYPE OF (maths_function);
	explicit_domain : tuple_space;
	explicit_range : tuple_space;
	parameters : LIST [0:?] OF maths_value;
WHERE
	WR1 : expression_is_constant(explicit_domain);
	WR2 : expression_is_constant(explicit_range);
END_ENTITY;


ENTITY application_protocol_definition;
	status : label;
	application_interpreted_model_schema_name : label;
	application_protocol_year : year_number;
	application : application_context;
END_ENTITY;


ENTITY applied_action_assignment
	SUBTYPE OF (action_assignment);
	items : SET [1:?] OF action_items;
END_ENTITY;


ENTITY applied_action_method_assignment
	SUBTYPE OF (action_method_assignment);
	items : SET [1:?] OF action_method_items;
END_ENTITY;


ENTITY applied_action_request_assignment
	SUBTYPE OF (action_request_assignment);
	items : SET [1:?] OF action_request_item;
END_ENTITY;


ENTITY applied_approval_assignment
	SUBTYPE OF (approval_assignment);
	items : SET [1:?] OF approval_item;
END_ENTITY;


ENTITY applied_attribute_classification_assignment
	SUBTYPE OF (attribute_classification_assignment);
	items : SET [1:?] OF attribute_classification_item;
	SELF\attribute_classification_assignment.assigned_class : class;
END_ENTITY;


ENTITY applied_certification_assignment
	SUBTYPE OF (certification_assignment);
	items : SET [1:?] OF certification_item;
END_ENTITY;


ENTITY applied_classification_assignment
	SUBTYPE OF (classification_assignment);
	items : SET [1:?] OF classification_item;
END_ENTITY;


ENTITY applied_contract_assignment
	SUBTYPE OF (contract_assignment);
	items : SET [1:?] OF contract_item;
END_ENTITY;


ENTITY applied_date_and_time_assignment
	SUBTYPE OF (date_and_time_assignment);
	items : SET [1:?] OF date_and_time_item;
END_ENTITY;


ENTITY applied_date_assignment
	SUBTYPE OF (date_assignment);
	items : SET [1:?] OF date_item;
END_ENTITY;


ENTITY applied_document_reference
	SUBTYPE OF (document_reference);
	items : SET [1:?] OF document_reference_item;
END_ENTITY;


ENTITY applied_document_usage_constraint_assignment
	SUBTYPE OF (document_usage_constraint_assignment);
	items : SET [1:?] OF document_reference_item;
END_ENTITY;


ENTITY applied_effectivity_assignment
	SUBTYPE OF (effectivity_assignment);
	items : SET [1:?] OF effectivity_item;
END_ENTITY;


ENTITY applied_event_occurrence_assignment
	SUBTYPE OF (event_occurrence_assignment);
	items : SET [1:?] OF event_occurrence_item;
END_ENTITY;


ENTITY applied_external_identification_assignment
	SUBTYPE OF (external_identification_assignment);
	items : SET [1:?] OF external_identification_item;
END_ENTITY;


ENTITY applied_group_assignment
	SUBTYPE OF (group_assignment);
	items : SET [1:?] OF groupable_item;
END_ENTITY;


ENTITY applied_identification_assignment
	SUBTYPE OF (identification_assignment);
	items : SET [1:?] OF identification_item;
END_ENTITY;


ENTITY applied_name_assignment
	SUBTYPE OF (name_assignment);
	item : name_item;
END_ENTITY;


ENTITY applied_organization_assignment
	SUBTYPE OF (organization_assignment);
	items : SET [1:?] OF organization_item;
END_ENTITY;


ENTITY applied_organizational_project_assignment
	SUBTYPE OF (organizational_project_assignment);
	items : SET [1:?] OF project_item;
END_ENTITY;


ENTITY applied_person_and_organization_assignment
	SUBTYPE OF (person_and_organization_assignment);
	items : SET [1:?] OF person_and_organization_item;
END_ENTITY;


ENTITY applied_presented_item
	SUBTYPE OF (presented_item);
	items : SET [1:?] OF presented_item_select;
END_ENTITY;


ENTITY applied_security_classification_assignment
	SUBTYPE OF (security_classification_assignment);
	items : SET [1:?] OF security_classification_item;
END_ENTITY;


ENTITY applied_time_interval_assignment
	SUBTYPE OF (time_interval_assignment);
	items : SET [0:?] OF time_interval_item;
END_ENTITY;


ENTITY applied_usage_right
	SUBTYPE OF (applied_action_assignment);
	SELF\applied_action_assignment.items : SET [1:?] OF ir_usage_item;
END_ENTITY;


ENTITY approval;
	status : approval_status;
	level : label;
END_ENTITY;


ENTITY approval_assignment
	ABSTRACT SUPERTYPE;
	assigned_approval : approval;
DERIVE
	role : object_role := get_role(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;


ENTITY approval_date_time;
	date_time : date_time_select;
	dated_approval : approval;
DERIVE
	role : object_role := get_role(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;


ENTITY approval_person_organization;
	person_organization : person_organization_select;
	authorized_approval : approval;
	role : approval_role;
END_ENTITY;


ENTITY approval_relationship;
	name : label;
	description : OPTIONAL text;
	relating_approval : approval;
	related_approval : approval;
END_ENTITY;


ENTITY approval_role;
	role : label;
DERIVE
	description : text := get_description_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;


ENTITY approval_status;
	name : label;
END_ENTITY;


ENTITY arbitrary_volume_2d_element_coordinate_system
	SUBTYPE OF (fea_representation_item);
	orientation : direction;
WHERE
	WR1 : SELF\geometric_representation_item.dim=2;
END_ENTITY;


ENTITY arbitrary_volume_3d_element_coordinate_system
	SUBTYPE OF (fea_representation_item);
	coordinate_system : fea_axis2_placement_3d;
END_ENTITY;


ENTITY area_in_set;
	area : presentation_area;
	in_set : presentation_set;
END_ENTITY;


ENTITY area_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AREA_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY area_unit
	SUBTYPE OF (derived_unit);
WHERE
	WR1 : derive_dimensional_exponents(SELF) = 
      dimensional_exponents ( 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 );
END_ENTITY;


ENTITY array_based_unstructured_mesh
	SUBTYPE OF (unstructured_mesh);
	cells : ARRAY [1:cell_count] OF vertex_defined_cell;
WHERE
	wr1 : SELF\mesh.index_count = 1;
END_ENTITY;


ENTITY array_based_unstructured_mesh_and_vertices
	SUBTYPE OF (array_based_unstructured_mesh);
	vertex_count : INTEGER;
	vertices : ARRAY [1:vertex_count] OF  UNIQUE vertex;
WHERE
	wr1 : all_mesh_vertices(SELF);
END_ENTITY;


ENTITY asin_function
	SUBTYPE OF (unary_function_call);
END_ENTITY;


ENTITY assembly_component_usage
	SUPERTYPE OF (ONEOF (next_assembly_usage_occurrence, specified_higher_usage_occurrence, promissory_usage_occurrence))
	SUBTYPE OF (product_definition_usage);
	reference_designator : OPTIONAL identifier;
END_ENTITY;


ENTITY assembly_component_usage_substitute;
	name : label;
	definition : OPTIONAL text;
	base : assembly_component_usage;
	substitute : assembly_component_usage;
UNIQUE
	UR1 : base, substitute;
WHERE
	WR1 : base.relating_product_definition :=:
       substitute.relating_product_definition;
	WR2 : base :<>: substitute;
END_ENTITY;


ENTITY assigned_analysis
	SUBTYPE OF (group_assignment);
	items : SET [1:1] OF product_definition_formation;
	SELF\group_assignment.assigned_group : analysis_assignment;
END_ENTITY;


ENTITY assigned_requirement
	SUBTYPE OF (group_assignment);
	items : SET [1:1] OF product_definition;
	SELF\group_assignment.assigned_group : requirement_assignment;
END_ENTITY;


ENTITY atan_function
	SUBTYPE OF (binary_function_call);
END_ENTITY;


ENTITY atom_based_literal
	SUBTYPE OF (generic_literal);
	lit_value : atom_based_value;
END_ENTITY;


ENTITY atomic_formula
	SUBTYPE OF (compound_representation_item);
END_ENTITY;


ENTITY attribute_assertion
	SUBTYPE OF (fact_type, property_definition_representation, representation);
END_ENTITY;


ENTITY attribute_classification_assignment
	ABSTRACT SUPERTYPE;
	assigned_class : group;
	attribute_name : label;
	role : classification_role;
END_ENTITY;


ENTITY attribute_language_assignment
	SUBTYPE OF (attribute_classification_assignment);
	items : SET [1:?] OF attribute_language_item;
	SELF\attribute_classification_assignment.assigned_class : language;
WHERE
	WR1 : SELF\attribute_classification_assignment.role.name IN ['primary', 'translated'];
	WR2 : SELF\attribute_classification_assignment.attribute_name<> '';
END_ENTITY;


ENTITY attribute_value_assignment
	ABSTRACT SUPERTYPE;
	attribute_name : label;
	attribute_value : attribute_type;
	role : attribute_value_role;
END_ENTITY;


ENTITY attribute_value_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY;


ENTITY auxiliary_geometric_representation_item
	SUBTYPE OF (geometric_representation_item, variational_representation_item);
END_ENTITY;


ENTITY axis1_placement
	SUBTYPE OF (placement);
	axis : OPTIONAL direction;
DERIVE
	z : direction := NVL(normalise(axis), dummy_gri ||
                                 direction([0.0,0.0,1.0]));
WHERE
	WR1 : SELF\geometric_representation_item.dim  = 3;
END_ENTITY;


ENTITY axis2_placement_2d
	SUBTYPE OF (placement);
	ref_direction : OPTIONAL direction;
DERIVE
	p : LIST [2:2] OF direction := build_2axes(ref_direction);
WHERE
	WR1 : SELF\geometric_representation_item.dim = 2;
END_ENTITY;


ENTITY axis2_placement_3d
	SUBTYPE OF (placement);
	axis : OPTIONAL direction;
	ref_direction : OPTIONAL direction;
DERIVE
	p : LIST [3:3] OF direction := build_axes(axis,ref_direction);
WHERE
	WR1 : SELF\placement.location.dim = 3;
	WR2 : (NOT (EXISTS (axis))) OR (axis.dim = 3);
	WR3 : (NOT (EXISTS (ref_direction))) OR (ref_direction.dim = 3);
	WR4 : (NOT (EXISTS (axis))) OR (NOT (EXISTS (ref_direction))) OR
          (cross_product(axis,ref_direction).magnitude > 0.0);
END_ENTITY;


ENTITY axisymmetric_2d_element_property;
	angle : plane_angle_measure;
END_ENTITY;


ENTITY axisymmetric_curve_2d_element_descriptor
	SUBTYPE OF (element_descriptor);
	purpose : SET [1:?] OF SET [1:?] OF curve_element_purpose;
END_ENTITY;


ENTITY axisymmetric_curve_2d_element_representation
	SUBTYPE OF (element_representation);
	model_ref : fea_model_2d;
	element_descriptor : axisymmetric_curve_2d_element_descriptor;
	property : curve_2d_element_property;
	angle_property : axisymmetric_2d_element_property;
	material : element_material;
UNIQUE
	UR1 : model_ref, SELF\representation.name;
WHERE
	WR1 : model_ref.type_of_2d_analysis = axisymmetric;
	WR2 : SIZEOF (QUERY(item <* SELF\representation.items |
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
              'CURVE_2D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) = 1;
	WR3 : SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_MASS_DENSITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_AREA_DENSITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_MOISTURE_ABSORPTION'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
	WR4 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items);
	FU1 : required_0d_nodes (
        SELF\element_representation.node_list);
END_ENTITY;


ENTITY axisymmetric_surface_2d_element_descriptor
	SUBTYPE OF (element_descriptor);
	purpose : SET [1:?] OF SET [1:?] OF surface_element_purpose;
END_ENTITY;


ENTITY axisymmetric_surface_2d_element_representation
	SUBTYPE OF (element_representation);
	model_ref : fea_model_2d;
	element_descriptor : axisymmetric_surface_2d_element_descriptor;
	property : surface_element_property;
	angle_property : axisymmetric_2d_element_property;
	material : element_material;
UNIQUE
	UR1 : model_ref, SELF\representation.name;
WHERE
	WR1 : model_ref.type_of_2d_analysis = axisymmetric;
	WR2 : SIZEOF (QUERY(item <* SELF\representation.items |
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
              'PARAMETRIC_SURFACE_2D_ELEMENT_COORDINATE_SYSTEM'
               IN TYPEOF (item))) +
       SIZEOF (QUERY(item <* SELF\representation.items |
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
              'ALIGNED_SURFACE_2D_ELEMENT_COORDINATE_SYSTEM' 
               IN TYPEOF (item))) = 1;
	WR3 : SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_MASS_DENSITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_AREA_DENSITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_MOISTURE_ABSORPTION',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_SHELL_MEMBRANE_STIFFNESS',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_SHELL_BENDING_STIFFNESS',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_SHELL_MEMBRANE_BENDING_COUPLING_STIFFNESS',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_SHELL_SHEAR_STIFFNESS'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
	WR4 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items);
	FU1 : required_1d_nodes (
        SELF\element_representation.node_list,
        element_descriptor\element_descriptor.topology_order);
END_ENTITY;


ENTITY axisymmetric_volume_2d_element_descriptor
	SUBTYPE OF (element_descriptor);
	purpose : SET [1:?] OF SET [1:?] OF volume_element_purpose;
	shape : element_2d_shape;
END_ENTITY;


ENTITY axisymmetric_volume_2d_element_representation
	SUBTYPE OF (element_representation);
	model_ref : fea_model_2d;
	element_descriptor : axisymmetric_volume_2d_element_descriptor;
	angle_property : axisymmetric_2d_element_property;
	material : element_material;
UNIQUE
	UR1 : model_ref, SELF\representation.name;
WHERE
	WR1 : model_ref.type_of_2d_analysis = axisymmetric;
	WR2 : SIZEOF (QUERY(item <* SELF\representation.items |
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
              'PARAMETRIC_VOLUME_2D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) +
       SIZEOF (QUERY(item <* SELF\representation.items |
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
              'ARBITRARY_VOLUME_2D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) = 1;
	WR3 : SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_MASS_DENSITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_AREA_DENSITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_MOISTURE_ABSORPTION'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
	WR4 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items);
	FU1 : required_2d_nodes (
        SELF\element_representation.node_list,
        element_descriptor.shape,
        element_descriptor\element_descriptor.topology_order);
END_ENTITY;


ENTITY b_spline_basis
	SUBTYPE OF (maths_function, generic_literal);
	degree : nonnegative_integer;
	repeated_knots : LIST [2:?] OF REAL;
DERIVE
	num_basis : positive_integer := SIZEOF (repeated_knots) - order;
	order : positive_integer := degree + 1;
WHERE
	WR1 : num_basis >= order;
	WR2 : nondecreasing(repeated_knots);
	WR3 : repeated_knots[order] < repeated_knots[num_basis+1];
END_ENTITY;


ENTITY b_spline_curve
	SUPERTYPE OF ((ONEOF (uniform_curve, b_spline_curve_with_knots, quasi_uniform_curve, bezier_curve) ANDOR rational_b_spline_curve))
	SUBTYPE OF (bounded_curve);
	degree : INTEGER;
	control_points_list : LIST [2:?] OF cartesian_point;
	curve_form : b_spline_curve_form;
	closed_curve : LOGICAL;
	self_intersect : LOGICAL;
DERIVE
	control_points : ARRAY [0:upper_index_on_control_points] OF cartesian_point := list_to_array(control_points_list,0,
                                             upper_index_on_control_points);
	upper_index_on_control_points : INTEGER := (SIZEOF(control_points_list) - 1);
WHERE
	WR1 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.UNIFORM_CURVE' IN TYPEOF(self)) OR
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.QUASI_UNIFORM_CURVE' IN TYPEOF(self)) OR
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BEZIER_CURVE' IN TYPEOF(self)) OR
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(self));
END_ENTITY;


ENTITY b_spline_curve_with_knots
	SUBTYPE OF (b_spline_curve);
	knot_multiplicities : LIST [2:?] OF INTEGER;
	knots : LIST [2:?] OF parameter_value;
	knot_spec : knot_type;
DERIVE
	upper_index_on_knots : INTEGER := SIZEOF(knots);
WHERE
	WR1 : constraints_param_b_spline(degree, upper_index_on_knots,
                               upper_index_on_control_points,
                               knot_multiplicities, knots);
	WR2 : SIZEOF(knot_multiplicities) = upper_index_on_knots;
END_ENTITY;


ENTITY b_spline_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	basis : LIST [1:?] OF b_spline_basis;
	SELF\unary_generic_expression.operand : maths_function;
DERIVE
	coef : maths_function := SELF\unary_generic_expression.operand;
WHERE
	WR1 : function_is_table(coef);
	WR2 : (space_dimension(coef.range) = 1) AND
       (number_superspace_of(factor1(coef.range)) = the_reals);
	WR3 : SIZEOF (basis) <=
       SIZEOF (shape_of_array(coef));
	WR4 : compare_basis_and_coef(basis, coef);
END_ENTITY;


ENTITY b_spline_surface
	SUPERTYPE OF ((ONEOF (b_spline_surface_with_knots, uniform_surface, quasi_uniform_surface, bezier_surface) ANDOR rational_b_spline_surface))
	SUBTYPE OF (bounded_surface);
	u_degree : INTEGER;
	v_degree : INTEGER;
	control_points_list : LIST [2:?] OF LIST [2:?] OF cartesian_point;
	surface_form : b_spline_surface_form;
	u_closed : LOGICAL;
	v_closed : LOGICAL;
	self_intersect : LOGICAL;
DERIVE
	control_points : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF cartesian_point := make_array_of_array(control_points_list,
                                              0,u_upper,0,v_upper);
	u_upper : INTEGER := SIZEOF(control_points_list) - 1;
	v_upper : INTEGER := SIZEOF(control_points_list[1]) - 1;
WHERE
	WR1 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.QUASI_UNIFORM_SURFACE' IN TYPEOF(SELF)) OR
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BEZIER_SURFACE' IN TYPEOF(SELF)) OR
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF));
END_ENTITY;


ENTITY b_spline_surface_with_knots
	SUBTYPE OF (b_spline_surface);
	u_multiplicities : LIST [2:?] OF INTEGER;
	v_multiplicities : LIST [2:?] OF INTEGER;
	u_knots : LIST [2:?] OF parameter_value;
	v_knots : LIST [2:?] OF parameter_value;
	knot_spec : knot_type;
DERIVE
	knot_u_upper : INTEGER := SIZEOF(u_knots);
	knot_v_upper : INTEGER := SIZEOF(v_knots);
WHERE
	WR1 : constraints_param_b_spline(SELF\b_spline_surface.u_degree,
                   knot_u_upper, SELF\b_spline_surface.u_upper,
                               u_multiplicities, u_knots);
	WR2 : constraints_param_b_spline(SELF\b_spline_surface.v_degree,
                   knot_v_upper, SELF\b_spline_surface.v_upper,
                               v_multiplicities, v_knots);
	WR3 : SIZEOF(u_multiplicities) = knot_u_upper;
	WR4 : SIZEOF(v_multiplicities) = knot_v_upper;
END_ENTITY;


ENTITY back_chaining_rule
	SUBTYPE OF (rule_definition);
END_ENTITY;


ENTITY back_chaining_rule_body
	SUBTYPE OF (property_definition, property_definition_representation, representation);
END_ENTITY;


ENTITY background_colour
	SUBTYPE OF (colour);
	presentation : area_or_view;
UNIQUE
	UR1 : presentation;
END_ENTITY;


ENTITY banded_matrix
	SUBTYPE OF (linearized_table_function);
	default_entry : maths_value;
	below : INTEGER;
	above : INTEGER;
	order : ordering_type;
WHERE
	WR1 : SIZEOF (self\explicit_table_function.shape) = 2;
	WR2 : -below <= above;
	WR3 : member_of(default_entry,
       factor1(SELF\linearized_table_function.source.range));
END_ENTITY;


ENTITY basic_sparse_matrix
	SUBTYPE OF (explicit_table_function, multiple_arity_generic_expression);
	default_entry : maths_value;
	order : ordering_type;
	SELF\multiple_arity_generic_expression.operands : LIST [3:3] OF maths_function;
DERIVE
	index : maths_function := SELF\multiple_arity_generic_expression.operands[1];
	loc : maths_function := SELF\multiple_arity_generic_expression.operands[2];
	val : maths_function := SELF\multiple_arity_generic_expression.operands[3];
WHERE
	WR1 : function_is_1d_table(index);
	WR2 : function_is_1d_table(loc);
	WR3 : function_is_1d_table(val);
	WR4 : check_sparse_index_domain(index.domain, index_base, shape, order);
	WR5 : check_sparse_index_to_loc(index.range, loc.domain);
	WR6 : loc.domain = val.domain;
	WR7 : check_sparse_loc_range(loc.range, index_base, shape, order);
	WR8 : member_of(default_entry, val.range);
END_ENTITY;


ENTITY behavioural_decomposition_of_numerical_model;
	parts : SET [2:?] OF numerical_model;
	whole : numerical_model;
END_ENTITY;


ENTITY behavioural_decomposition_of_temporal_spatial_domain;
	parts : SET [2:?] OF temporal_spatial_domain;
	whole : temporal_spatial_domain;
END_ENTITY;


ENTITY beveled_sheet_representation
	SUBTYPE OF (shape_representation);
END_ENTITY;


ENTITY bezier_curve
	SUBTYPE OF (b_spline_curve);
END_ENTITY;


ENTITY bezier_surface
	SUBTYPE OF (b_spline_surface);
END_ENTITY;


ENTITY binary_boolean_expression
	ABSTRACT SUPERTYPE OF (ONEOF (xor_expression, equals_expression))
	SUBTYPE OF (boolean_expression, binary_generic_expression);
END_ENTITY;


ENTITY binary_function_call
	ABSTRACT SUPERTYPE
	SUBTYPE OF (binary_numeric_expression);
END_ENTITY;


ENTITY binary_generic_expression
	ABSTRACT SUPERTYPE
	SUBTYPE OF (generic_expression);
	operands : LIST [2:2] OF generic_expression;
END_ENTITY;


ENTITY binary_literal
	SUBTYPE OF (generic_literal);
	lit_value : BINARY;
END_ENTITY;


ENTITY binary_numeric_expression
	ABSTRACT SUPERTYPE OF (ONEOF (minus_expression, div_expression, mod_expression, slash_expression, power_expression, binary_function_call))
	SUBTYPE OF (numeric_expression, binary_generic_expression);
	SELF\binary_generic_expression.operands : LIST [2:2] OF numeric_expression;
END_ENTITY;


ENTITY binary_representation_item
	SUBTYPE OF (representation_item);
	binary_value : BINARY;
END_ENTITY;


ENTITY block
	SUBTYPE OF (geometric_representation_item);
	position : axis2_placement_3d;
	x : positive_length_measure;
	y : positive_length_measure;
	z : positive_length_measure;
END_ENTITY;


ENTITY boolean_defined_function
	ABSTRACT SUPERTYPE
	SUBTYPE OF (defined_function, boolean_expression);
END_ENTITY;


ENTITY boolean_expression
	ABSTRACT SUPERTYPE OF (ONEOF (simple_boolean_expression, unary_boolean_expression, binary_boolean_expression, multiple_arity_boolean_expression, comparison_expression, interval_expression, boolean_defined_function))
	SUBTYPE OF (expression);
END_ENTITY;


ENTITY boolean_literal
	SUBTYPE OF (simple_boolean_expression, generic_literal);
	the_value : BOOLEAN;
END_ENTITY;


ENTITY boolean_representation_item
	SUBTYPE OF (representation_item, boolean_literal);
END_ENTITY;


ENTITY boolean_result
	SUBTYPE OF (geometric_representation_item);
	operator : boolean_operator;
	first_operand : boolean_operand;
	second_operand : boolean_operand;
END_ENTITY;


ENTITY boolean_variable
	SUBTYPE OF (simple_boolean_expression, variable);
END_ENTITY;


ENTITY bound_variable_semantics
	SUBTYPE OF (variable_semantics);
END_ENTITY;


ENTITY boundary_curve
	SUBTYPE OF (composite_curve_on_surface);
WHERE
	WR1 : SELF\composite_curve.closed_curve;
END_ENTITY;


ENTITY bounded_curve
	SUPERTYPE OF (ONEOF (polyline, b_spline_curve, trimmed_curve, bounded_pcurve, bounded_surface_curve, composite_curve))
	SUBTYPE OF (curve);
END_ENTITY;


ENTITY bounded_pcurve
	SUBTYPE OF (pcurve, bounded_curve);
WHERE
	WR1 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BOUNDED_CURVE' IN
                   TYPEOF(SELF\pcurve.reference_to_curve.items[1]));
END_ENTITY;


ENTITY bounded_surface
	SUPERTYPE OF (ONEOF (b_spline_surface, rectangular_trimmed_surface, curve_bounded_surface, rectangular_composite_surface))
	SUBTYPE OF (surface);
END_ENTITY;


ENTITY bounded_surface_curve
	SUBTYPE OF (surface_curve, bounded_curve);
WHERE
	WR1 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BOUNDED_CURVE' IN
             TYPEOF(SELF\surface_curve.curve_3d));
END_ENTITY;


ENTITY box_domain
	SUBTYPE OF (founded_item);
	corner : cartesian_point;
	xlength : positive_length_measure;
	ylength : positive_length_measure;
	zlength : positive_length_measure;
WHERE
	WR1 : SIZEOF(QUERY(item <* USEDIN(SELF,'')|
             NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BOXED_HALF_SPACE'
                    IN TYPEOF(item)))) = 0;
END_ENTITY;


ENTITY boxed_half_space
	SUBTYPE OF (half_space_solid);
	enclosure : box_domain;
END_ENTITY;


ENTITY breakdown_context
	SUBTYPE OF (product_definition_relationship);
END_ENTITY;


ENTITY breakdown_element_group_assignment
	SUBTYPE OF (group_assignment);
	items : SET [1:1] OF product_definition_or_breakdown_element_usage;
	SELF\group_assignment.assigned_group : product_definition_element_relationship;
END_ENTITY;


ENTITY breakdown_element_realization
	SUBTYPE OF (characterized_object, product_definition_element_relationship);
END_ENTITY;


ENTITY breakdown_element_usage
	SUBTYPE OF (product_definition_relationship);
END_ENTITY;


ENTITY breakdown_of
	SUBTYPE OF (product_definition_relationship);
END_ENTITY;


ENTITY brep_with_voids
	SUBTYPE OF (manifold_solid_brep);
	voids : SET [1:?] OF oriented_closed_shell;
END_ENTITY;


ENTITY bytes_representation_item
	SUBTYPE OF (binary_representation_item);
DERIVE
	no_of_bytes : INTEGER := BLENGTH(SELF\binary_representation_item.binary_value) DIV 8;
WHERE
	WR1 : BLENGTH(SELF\binary_representation_item.binary_value) MOD 8 = 0;
END_ENTITY;


ENTITY calculated_state
	SUBTYPE OF (state);
END_ENTITY;


ENTITY calendar_date
	SUBTYPE OF (date);
	day_component : day_in_month_number;
	month_component : month_in_year_number;
WHERE
	WR1 : valid_calendar_date (SELF);
END_ENTITY;


ENTITY camera_image
	SUBTYPE OF (mapped_item);
	SELF\mapped_item.mapping_source : camera_usage;
	SELF\mapped_item.mapping_target : planar_box;
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM'
        IN TYPEOF (SELF);
END_ENTITY;


ENTITY camera_image_3d_with_scale
	SUBTYPE OF (camera_image);
DERIVE
	scale : positive_ratio_measure := ((SELF\mapped_item.mapping_target\
           planar_extent.size_in_x) / (SELF\mapped_item.mapping_source.
           mapping_origin\camera_model_d3.perspective_of_volume.view_window.
           size_in_x));
WHERE
	WR1 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CAMERA_MODEL_D3'
         IN TYPEOF (SELF\mapped_item.mapping_source.mapping_origin));
	WR2 : aspect_ratio(SELF\mapped_item.mapping_target) =
           aspect_ratio(SELF\mapped_item.mapping_source.mapping_origin\
           camera_model_d3.perspective_of_volume.view_window);
	WR3 : SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
           perspective_of_volume.front_plane_clipping
           AND
           SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
           perspective_of_volume.view_volume_sides_clipping;
	WR4 : (SELF\mapped_item.mapping_target\planar_extent.size_in_x > 0)
           AND
           (SELF\mapped_item.mapping_target\planar_extent.size_in_y > 0);
	WR5 : (SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
           perspective_of_volume.view_window.size_in_x > 0)
           AND
           (SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
           perspective_of_volume.view_window.size_in_y > 0);
	WR6 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
            'AXIS2_PLACEMENT_2D' IN TYPEOF (SELF\mapped_item.
           mapping_target\planar_box.placement))
           AND NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
           'AXIS2_PLACEMENT_3D' IN TYPEOF (SELF\mapped_item.
           mapping_target\planar_box.placement));
END_ENTITY;


ENTITY camera_model
	ABSTRACT SUPERTYPE
	SUBTYPE OF (geometric_representation_item);
WHERE
	WR1 : (SIZEOF (USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                  'ITEM_DEFINED_TRANSFORMATION.' +
                                  'TRANSFORM_ITEM_1')) +
            SIZEOF (USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                  'REPRESENTATION_MAP.MAPPING_ORIGIN'))
            ) > 0;
	WR2 : SIZEOF(USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
                              'STYLED_ITEM.ITEM')) = 0;
END_ENTITY;


ENTITY camera_model_d3
	SUBTYPE OF (camera_model);
	view_reference_system : axis2_placement_3d;
	perspective_of_volume : view_volume;
WHERE
	WR1 : SELF\geometric_representation_item.dim = 3;
END_ENTITY;


ENTITY camera_model_d3_multi_clipping
	SUBTYPE OF (camera_model_d3);
	shape_clipping : SET [1:?] OF camera_model_d3_multi_clipping_interection_select;
END_ENTITY;


ENTITY camera_model_d3_multi_clipping_intersection
	SUBTYPE OF (geometric_representation_item);
	shape_clipping : SET [2:?] OF camera_model_d3_multi_clipping_interection_select;
END_ENTITY;


ENTITY camera_model_d3_multi_clipping_union
	SUBTYPE OF (geometric_representation_item);
	shape_clipping : SET [2:?] OF camera_model_d3_multi_clipping_union_select;
END_ENTITY;


ENTITY camera_model_d3_with_hlhsr
	SUBTYPE OF (camera_model_d3);
	hidden_line_surface_removal : BOOLEAN;
END_ENTITY;


ENTITY camera_model_with_light_sources
	SUBTYPE OF (camera_model_d3);
	sources : SET [1:?] OF light_source;
END_ENTITY;


ENTITY camera_usage
	SUBTYPE OF (representation_map);
	SELF\representation_map.mapping_origin : camera_model;
WHERE
	WR1 : NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRESENTATION_REPRESENTATION'
          IN TYPEOF(SELF\representation_map.mapped_representation));
END_ENTITY;


ENTITY capacitance_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CAPACITANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY capacitance_unit
	SUBTYPE OF (derived_unit);
WHERE
	WR1 : derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.farad);
END_ENTITY;


ENTITY cartesian_complex_number_region
	SUBTYPE OF (maths_space, generic_literal);
	real_constraint : real_interval;
	imag_constraint : real_interval;
WHERE
	WR1 : min_exists(real_constraint) OR max_exists(real_constraint) OR
       min_exists(imag_constraint) OR max_exists(imag_constraint);
END_ENTITY;


ENTITY cartesian_point
	SUPERTYPE OF (ONEOF (cylindrical_point, polar_point, spherical_point))
	SUBTYPE OF (point);
	coordinates : LIST [1:3] OF length_measure;
END_ENTITY;


ENTITY cartesian_transformation_operator
	SUPERTYPE OF (ONEOF (cartesian_transformation_operator_2d, cartesian_transformation_operator_3d))
	SUBTYPE OF (geometric_representation_item, functionally_defined_transformation);
	axis1 : OPTIONAL direction;
	axis2 : OPTIONAL direction;
	local_origin : cartesian_point;
	scale : OPTIONAL REAL;
DERIVE
	scl : REAL := NVL(scale, 1.0);
WHERE
	WR1 : scl > 0.0;
END_ENTITY;


ENTITY cartesian_transformation_operator_2d
	SUBTYPE OF (cartesian_transformation_operator);
DERIVE
	u : LIST [2:2] OF direction := base_axis(2,SELF\cartesian_transformation_operator.axis1,
                   SELF\cartesian_transformation_operator.axis2,?);
WHERE
	WR1 : SELF\geometric_representation_item.dim = 2;
END_ENTITY;


ENTITY cartesian_transformation_operator_3d
	SUBTYPE OF (cartesian_transformation_operator);
	axis3 : OPTIONAL direction;
DERIVE
	u : LIST [3:3] OF direction := base_axis(3,SELF\cartesian_transformation_operator.axis1,
                        SELF\cartesian_transformation_operator.axis2,axis3);
WHERE
	WR1 : SELF\geometric_representation_item.dim = 3;
END_ENTITY;


ENTITY cc_design_approval
	SUBTYPE OF (approval_assignment);
	items : SET [1:?] OF approved_item;
END_ENTITY;


ENTITY cc_design_certification
	SUBTYPE OF (certification_assignment);
	items : SET [1:?] OF certified_item;
END_ENTITY;


ENTITY cc_design_contract
	SUBTYPE OF (contract_assignment);
	items : SET [1:?] OF contracted_item;
END_ENTITY;


ENTITY cc_design_date_and_time_assignment
	SUBTYPE OF (date_and_time_assignment);
	items : SET [1:?] OF date_time_item;
END_ENTITY;


ENTITY cc_design_person_and_organization_assignment
	SUBTYPE OF (person_and_organization_assignment);
	items : SET [1:?] OF cc_person_organization_item;
WHERE
	WR1 : cc_design_person_and_organization_correlation(SELF);
END_ENTITY;


ENTITY cc_design_security_classification
	SUBTYPE OF (security_classification_assignment);
	items : SET [1:?] OF cc_classified_item;
END_ENTITY;


ENTITY cc_design_specification_reference
	SUBTYPE OF (document_reference);
	items : SET [1:?] OF cc_specified_item;
END_ENTITY;


ENTITY cell
	SUPERTYPE OF (ONEOF (cell_of_structured_mesh, vertex_defined_cell))
	SUBTYPE OF (topological_representation_item);
	description : text;
	dimension : INTEGER;
END_ENTITY;


ENTITY cell_of_structured_mesh
	SUBTYPE OF (cell);
	the_mesh : structured_mesh;
	cell_identifier : ARRAY [1:index_count] OF INTEGER;
DERIVE
	index_count : INTEGER := the_mesh\mesh.index_count;
END_ENTITY;


ENTITY cell_with_explicit_boundary
	SUBTYPE OF (cell);
	boundary : SET [1:?] OF topological_representation_item;
END_ENTITY;


ENTITY celsius_temperature_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY centre_of_symmetry
	SUBTYPE OF (derived_shape_aspect);
WHERE
	WR1 : SIZEOF
        (QUERY(sadr<*SELF\derived_shape_aspect.deriving_relationships|
    NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SYMMETRIC_SHAPE_ASPECT'
     IN TYPEOF
     (sadr\shape_aspect_relationship.related_shape_aspect))))=0;
END_ENTITY;


ENTITY certification;
	name : label;
	purpose : text;
	kind : certification_type;
END_ENTITY;


ENTITY certification_assignment
	ABSTRACT SUPERTYPE;
	assigned_certification : certification;
DERIVE
	role : object_role := get_role(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;


ENTITY certification_type;
	description : label;
END_ENTITY;


ENTITY chain_based_geometric_item_specific_usage
	SUBTYPE OF (geometric_item_specific_usage, chain_based_item_identified_representation_usage);
END_ENTITY;


ENTITY chain_based_item_identified_representation_usage
	SUBTYPE OF (item_identified_representation_usage);
	nodes : LIST [2:?] OF  UNIQUE representation;
	undirected_link : LIST [1:?] OF  UNIQUE chained_representation_link;
DERIVE
	directed_link : LIST [1:?] OF representation_relationship := get_directed_link(nodes, undirected_link);
	leaf : representation := SELF\item_identified_representation_usage.used_representation;
	root : representation := nodes[1];
	SELF\item_identified_representation_usage.used_representation : representation := nodes[HIINDEX(nodes)];
WHERE
	WR1 : root :=: directed_link[1]\representation_relationship.rep_1;
	WR2 : leaf :=: directed_link[HIINDEX(undirected_link)]\representation_relationship.rep_2;
	WR3 : SIZEOF(nodes) :=: SIZEOF(undirected_link) + 1;
	WR4 : (SIZEOF(QUERY(directed_link_element <* directed_link |(root :=:  directed_link_element\representation_relationship.rep_1))) +
             SIZEOF(QUERY(directed_link_element <* directed_link |(root :=:  directed_link_element\representation_relationship.rep_2)))) = 1;
	WR5 : (SIZEOF(QUERY(directed_link_element <* directed_link |(leaf :=:  directed_link_element\representation_relationship.rep_1))) +
             SIZEOF(QUERY(directed_link_element <* directed_link |(leaf :=:  directed_link_element\representation_relationship.rep_2)))) = 1;
	WR6 : (SIZEOF(QUERY(directed_link_element <* directed_link |(root :<>: directed_link_element\representation_relationship.rep_1))) +
             SIZEOF(QUERY(directed_link_element <* directed_link |(root :<>: directed_link_element\representation_relationship.rep_2))) + 
             SIZEOF(QUERY(directed_link_element <* directed_link |(leaf :<>: directed_link_element\representation_relationship.rep_1))) +
             SIZEOF(QUERY(directed_link_element <* directed_link |(leaf :<>: directed_link_element\representation_relationship.rep_2)))) = 2;
	WR7 : NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF(undirected_link[1])) OR
                (root IN using_representations(undirected_link[1]));
	WR8 : SIZEOF(undirected_link) = SIZEOF(directed_link);
END_ENTITY;


ENTITY change
	SUBTYPE OF (action_assignment);
	items : SET [1:?] OF work_item;
END_ENTITY;


ENTITY change_request
	SUBTYPE OF (action_request_assignment);
	items : SET [1:?] OF change_request_item;
END_ENTITY;


ENTITY character_glyph_font_usage;
	character : generic_character_glyph_symbol;
	font : text_font;
END_ENTITY;


ENTITY character_glyph_style_outline
	SUBTYPE OF (founded_item);
	outline_style : curve_style;
END_ENTITY;


ENTITY character_glyph_style_stroke
	SUBTYPE OF (founded_item);
	stroke_style : curve_style;
END_ENTITY;


ENTITY character_glyph_symbol
	SUBTYPE OF (generic_character_glyph_symbol);
	character_box : planar_extent;
	baseline_ratio : ratio_measure;
DERIVE
	box_height : length_measure := character_box.size_in_y;
WHERE
	WR1 : {0.0 <= baseline_ratio <= 1.0};
	WR2 : item_in_context(SELF.character_box, 
                       SELF\representation.context_of_items);
	WR3 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POSITIVE_LENGTH_MEASURE'
        IN TYPEOF (SELF.box_height);
END_ENTITY;


ENTITY character_glyph_symbol_outline
	SUBTYPE OF (character_glyph_symbol);
	outlines : SET [1:?] OF annotation_fill_area;
WHERE
	WR1 : SELF.outlines <= SELF\representation.items;
END_ENTITY;


ENTITY character_glyph_symbol_stroke
	SUBTYPE OF (character_glyph_symbol);
	strokes : SET [1:?] OF curve;
WHERE
	WR1 : SELF.strokes <= SELF\representation.items;
END_ENTITY;


ENTITY characteristic_data_column_header
	SUBTYPE OF (general_property);
END_ENTITY;


ENTITY characteristic_data_column_header_link
	SUBTYPE OF (general_property_relationship);
END_ENTITY;


ENTITY characteristic_data_table_header
	SUBTYPE OF (general_property);
END_ENTITY;


ENTITY characteristic_data_table_header_decomposition
	SUBTYPE OF (general_property_relationship);
END_ENTITY;


ENTITY characteristic_type
	SUBTYPE OF (group);
END_ENTITY;


ENTITY characterized_class
	SUBTYPE OF (characterized_object, class);
END_ENTITY;


ENTITY characterized_object;
	name : label;
	description : OPTIONAL text;
END_ENTITY;


ENTITY circle
	SUBTYPE OF (conic);
	radius : positive_length_measure;
END_ENTITY;


ENTITY circular_runout_tolerance
	SUBTYPE OF (geometric_tolerance_with_datum_reference);
WHERE
	WR1 : SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) <= 2;
END_ENTITY;


ENTITY class
	SUBTYPE OF (group);
END_ENTITY;


ENTITY class_by_extension
	SUBTYPE OF (class);
END_ENTITY;


ENTITY class_by_intension
	SUBTYPE OF (class);
END_ENTITY;


ENTITY class_of_activity
	SUBTYPE OF (executed_action, class);
END_ENTITY;


ENTITY class_of_possession_of_property_by_activity
	SUBTYPE OF (action_property);
	SELF\action_property.definition : class_of_activity;
END_ENTITY;


ENTITY class_of_possession_of_property_by_product
	SUBTYPE OF (property_definition);
WHERE
	link_to_class : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CLASS_OF_PRODUCT' IN TYPEOF(SELF\property_definition.definition.formation);
END_ENTITY;


ENTITY class_of_product
	SUBTYPE OF (product_definition_formation, class);
END_ENTITY;


ENTITY class_system
	SUBTYPE OF (group);
END_ENTITY;


ENTITY class_usage_effectivity_context_assignment
	SUBTYPE OF (effectivity_context_assignment);
	items : SET [1:?] OF class_usage_effectivity_context_item;
WHERE
	WR1 : SELF.role.name = 'class usage influence';
	WR2 : SIZEOF( QUERY( i <* SELF.items | NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(i)) )) = 0;
	WR3 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.APPLIED_EFFECTIVITY_ASSIGNMENT' IN TYPEOF(SELF.assigned_effectivity_assignment)) AND 
        (SIZEOF(TYPEOF(SELF.assigned_effectivity_assignment.assigned_effectivity) ) = 1) AND 
        (SELF.assigned_effectivity_assignment.assigned_effectivity.id = 'class usage') AND 
        (SIZEOF( QUERY( i <* SELF.assigned_effectivity_assignment\applied_effectivity_assignment.items | 
        NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE' IN TYPEOF(i)) )) = 0);
END_ENTITY;


ENTITY classification_assignment
	ABSTRACT SUPERTYPE;
	assigned_class : group;
	role : classification_role;
END_ENTITY;


ENTITY classification_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY;


ENTITY closed_shell
	SUBTYPE OF (connected_face_set);
END_ENTITY;


ENTITY coaxiality_tolerance
	SUBTYPE OF (geometric_tolerance_with_datum_reference);
WHERE
	WR1 : SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) <= 2;
END_ENTITY;


ENTITY colour;
END_ENTITY;


ENTITY colour_rgb
	SUBTYPE OF (colour_specification);
	red : REAL;
	green : REAL;
	blue : REAL;
WHERE
	WR1 : {0.0 <= red <= 1.0};
	WR2 : {0.0 <= green <= 1.0};
	WR3 : {0.0 <= blue <= 1.0};
END_ENTITY;


ENTITY colour_specification
	SUBTYPE OF (colour);
	name : label;
END_ENTITY;


ENTITY common_datum
	SUBTYPE OF (composite_shape_aspect, datum);
WHERE
	WR1 : SIZEOF (SELF\composite_shape_aspect.component_relationships) = 2;
	WR2 : SIZEOF (QUERY ( sar <* SELF\composite_shape_aspect.component_relationships| 
                      NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DATUM' IN TYPEOF (sar.related_shape_aspect)) AND 
                          NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMMON_DATUM' IN TYPEOF (sar.related_shape_aspect))) )) = 0;
END_ENTITY;


ENTITY comparison_equal
	SUBTYPE OF (comparison_expression);
END_ENTITY;


ENTITY comparison_expression
	ABSTRACT SUPERTYPE OF (ONEOF (comparison_equal, comparison_greater, comparison_greater_equal, comparison_less, comparison_less_equal, comparison_not_equal, like_expression))
	SUBTYPE OF (boolean_expression, binary_generic_expression);
	SELF\binary_generic_expression.operands : LIST [2:2] OF expression;
WHERE
	WR1 : (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NUMERIC_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[1]))
		AND 
		 	('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NUMERIC_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[2]))) 
OR
 (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BOOLEAN_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[1]))
		AND 
		 	('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BOOLEAN_EXPRESSION' 
	IN TYPEOF(SELF\binary_generic_expression.operands[2])))
OR
(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRING_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[1]))
		AND 
		 	('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRING_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[2])));
END_ENTITY;


ENTITY comparison_greater
	SUBTYPE OF (comparison_expression);
END_ENTITY;


ENTITY comparison_greater_equal
	SUBTYPE OF (comparison_expression);
END_ENTITY;


ENTITY comparison_less
	SUBTYPE OF (comparison_expression);
END_ENTITY;


ENTITY comparison_less_equal
	SUBTYPE OF (comparison_expression);
END_ENTITY;


ENTITY comparison_not_equal
	SUBTYPE OF (comparison_expression);
END_ENTITY;


ENTITY complex_clause
	SUBTYPE OF (compound_representation_item);
END_ENTITY;


ENTITY complex_conjunctive_clause
	SUBTYPE OF (complex_clause);
END_ENTITY;


ENTITY complex_disjunctive_clause
	SUBTYPE OF (complex_clause);
END_ENTITY;


ENTITY complex_number_literal
	SUBTYPE OF (generic_literal);
	real_part : REAL;
	imag_part : REAL;
END_ENTITY;


ENTITY complex_shelled_solid
	SUBTYPE OF (shelled_solid);
	thickened_face_list : LIST [1:?] OF SET [1:?] OF face_surface;
	thickness_list : LIST [1:?] OF length_measure;
WHERE
	WR1 : SIZEOF(thickened_face_list) = SIZEOF(thickness_list);
	WR2 : SIZEOF(QUERY(q <* thickness_list | (q = 0))) = 0;
END_ENTITY;


ENTITY composite_assembly_definition
	SUBTYPE OF (product_definition);
WHERE
	WR1 : SIZEOF (QUERY (pdr <* USEDIN (SELF, 
                             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                             'PRODUCT_DEFINITION_RELATIONSHIP.' +
                             'RELATING_PRODUCT_DEFINITION') |
                             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                             'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN
                             TYPEOF (pdr))) = 1;
END_ENTITY;


ENTITY composite_assembly_sequence_definition
	SUBTYPE OF (product_definition);
WHERE
	WR1 : SIZEOF (QUERY (pdr <* USEDIN (SELF, 
                             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                             'PRODUCT_DEFINITION_RELATIONSHIP.' +
                             'RELATING_PRODUCT_DEFINITION') |
                             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                             'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN
                             TYPEOF (pdr))) > 0;
END_ENTITY;


ENTITY composite_assembly_table
	SUBTYPE OF (part_laminate_table);
END_ENTITY;


ENTITY composite_curve
	SUBTYPE OF (bounded_curve);
	segments : LIST [1:?] OF composite_curve_segment;
	self_intersect : LOGICAL;
DERIVE
	closed_curve : LOGICAL := segments[n_segments].transition <> discontinuous;
	n_segments : INTEGER := SIZEOF(segments);
WHERE
	WR1 : ((NOT closed_curve) AND (SIZEOF(QUERY(temp <* segments |
                temp.transition = discontinuous)) = 1)) OR
            ((closed_curve) AND (SIZEOF(QUERY(temp <* segments | 
                temp.transition = discontinuous)) = 0));
END_ENTITY;


ENTITY composite_curve_on_surface
	SUPERTYPE OF (boundary_curve)
	SUBTYPE OF (composite_curve);
DERIVE
	basis_surface : SET [0:2] OF surface := get_basis_surface(SELF);
WHERE
	WR1 : SIZEOF(basis_surface) > 0;
	WR2 : constraints_composite_curve_on_surface(SELF);
END_ENTITY;


ENTITY composite_curve_segment
	SUBTYPE OF (founded_item);
	transition : transition_code;
	same_sense : BOOLEAN;
	parent_curve : curve;
INVERSE
	using_curves: BAG [1:?] OF composite_curve FOR segments;
WHERE
	WR1 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BOUNDED_CURVE' IN TYPEOF(parent_curve));
END_ENTITY;


ENTITY composite_material_designation
	SUBTYPE OF (material_designation);
END_ENTITY;


ENTITY composite_shape_aspect
	SUBTYPE OF (shape_aspect);
INVERSE
	component_relationships: SET [2:?] OF shape_aspect_relationship FOR relating_shape_aspect;
END_ENTITY;


ENTITY composite_sheet_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 : SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'MANIFOLD_SURFACE_SHAPE_REPRESENTATION'] * TYPEOF (SELF)) = 1;
END_ENTITY;


ENTITY composite_text
	SUBTYPE OF (geometric_representation_item);
	collected_text : SET [2:?] OF text_or_character;
WHERE
	WR1 : acyclic_composite_text( SELF, SELF.collected_text);
END_ENTITY;


ENTITY composite_text_with_associated_curves
	SUBTYPE OF (composite_text);
	associated_curves : SET [1:?] OF curve;
END_ENTITY;


ENTITY composite_text_with_blanking_box
	SUBTYPE OF (composite_text);
	blanking : planar_box;
END_ENTITY;


ENTITY composite_text_with_delineation
	SUBTYPE OF (composite_text);
	delineation : text_delineation;
END_ENTITY;


ENTITY composite_text_with_extent
	SUBTYPE OF (composite_text);
	extent : planar_extent;
END_ENTITY;


ENTITY compound_maths_space_context
	SUBTYPE OF (maths_space_context);
	components : LIST [2:?] OF maths_space_context;
END_ENTITY;


ENTITY compound_representation_item
	SUPERTYPE OF ((ONEOF (point_and_vector, point_path) ANDOR ONEOF (row_representation_item, table_representation_item)))
	SUBTYPE OF (representation_item);
	item_element : compound_item_definition;
END_ENTITY;


ENTITY compound_shape_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 : ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'GEOMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF ( SELF.context_of_items ) ) AND (
        SELF.context_of_items\
        geometric_representation_context.coordinate_space_dimension =3 );
	WR2 : SIZEOF ( QUERY ( cbsr_i <* SELF.items | SIZEOF (
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'EDGE_BASED_WIREFRAME_MODEL' ,
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'FACE_BASED_SURFACE_MODEL' ,
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'MAPPED_ITEM' , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
         'AXIS2_PLACEMENT_3D']* TYPEOF ( cbsr_i ) ) <>1 ) ) =0;
	WR3 : SIZEOF ( QUERY ( cbsr_i <* SELF.items | SIZEOF (
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'EDGE_BASED_WIREFRAME_MODEL' ,
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'FACE_BASED_SURFACE_MODEL' ,
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'MAPPED_ITEM']* TYPEOF ( cbsr_i ) ) =1 ) ) >0;
	WR4 : SIZEOF ( QUERY ( cbsr_i <* SELF.items | (
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'MAPPED_ITEM' IN TYPEOF ( cbsr_i ) )
         AND ( SIZEOF ( ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
         'COMPOUND_SHAPE_REPRESENTATION' , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
         'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION' ,
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
         'NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION']* TYPEOF (
         cbsr_i\ mapped_item.mapping_source ) ) <>1 ) ) ) =0;
END_ENTITY;


ENTITY concat_expression
	SUBTYPE OF (string_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF string_expression;
END_ENTITY;


ENTITY concentricity_tolerance
	SUBTYPE OF (geometric_tolerance_with_datum_reference);
WHERE
	WR1 : SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) = 1;
END_ENTITY;


ENTITY concept_feature_operator;
	name : label;
	description : OPTIONAL text;
END_ENTITY;


ENTITY concept_feature_relationship;
	name : label;
	description : OPTIONAL text;
	relating_product_concept_feature : product_concept_feature;
	related_product_concept_feature : product_concept_feature;
END_ENTITY;


ENTITY concept_feature_relationship_with_condition
	SUBTYPE OF (concept_feature_relationship);
	conditional_operator : concept_feature_operator;
END_ENTITY;


ENTITY conditional_concept_feature
	SUBTYPE OF (product_concept_feature);
	condition : concept_feature_relationship_with_condition;
END_ENTITY;


ENTITY conductance_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONDUCTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY conductance_unit
	SUBTYPE OF (derived_unit);
WHERE
	WR1 : derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.siemens);
END_ENTITY;


ENTITY configurable_item
	SUBTYPE OF (configuration_item);
	item_concept_feature : SET [1:?] OF product_concept_feature_association;
END_ENTITY;


ENTITY configuration_design;
	configuration : configuration_item;
	design : configuration_design_item;
DERIVE
	description : text := get_description_value (SELF);
	name : label := get_name_value (SELF);
UNIQUE
	UR1 : configuration, design;
WHERE
	WR1 : SIZEOF (USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                             'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
	WR2 : SIZEOF (USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;


ENTITY configuration_effectivity
	SUBTYPE OF (product_definition_effectivity);
	configuration : configuration_design;
UNIQUE
	UR1 : configuration, SELF\product_definition_effectivity.usage, SELF\effectivity.id;
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION_USAGE' IN
        TYPEOF (SELF\product_definition_effectivity.usage);
END_ENTITY;


ENTITY configuration_item;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	item_concept : product_concept;
	purpose : OPTIONAL label;
END_ENTITY;


ENTITY configuration_item_hierarchical_relationship
	SUBTYPE OF (configuration_item_relationship);
END_ENTITY;


ENTITY configuration_item_relationship;
	name : label;
	description : OPTIONAL text;
	relating_configuration_item : configuration_item;
	related_configuration_item : configuration_item;
END_ENTITY;


ENTITY configuration_item_revision_sequence
	SUBTYPE OF (configuration_item_relationship);
END_ENTITY;


ENTITY configured_effectivity_assignment
	SUBTYPE OF (effectivity_assignment);
	items : SET [1:?] OF configured_effectivity_item;
WHERE
	WR1 : (SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EFFECTIVITY'] * TYPEOF(SELF.assigned_effectivity) ) = 1) 
	AND (SELF.assigned_effectivity.id = 'configuration validity');
	WR2 : SIZEOF(SELF.items) = 1;
	WR3 : SIZEOF( QUERY( i <* SELF.items | NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(i)) 
	OR NOT (i\product_definition.frame_of_reference.name IN ['conceptual definition','part occurrence', 'functional definition','alternative definition']) )) = 0;
	WR4 : SELF.role.name IN ['design', 'usage'];
	WR5 : (SELF.role.name <> 'design') 
	OR (SIZEOF( QUERY( i <* SELF.items | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(i)) AND (i\product_definition.frame_of_reference.name = 'part occurrence') )) = 0);
	WR6 : (SELF.role.name <> 'usage') OR (SIZEOF( QUERY( i <* SELF.items | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(i)) AND (i\product_definition.frame_of_reference.name = 'conceptual definition') )) = 0);
	WR7 : SELF.role.description IN ['exception', 'inherited', 'local'];
	WR8 : SIZEOF( QUERY( x <* USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'EFFECTIVITY_CONTEXT_ASSIGNMENT.ASSIGNED_EFFECTIVITY_ASSIGNMENT') | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONFIGURED_EFFECTIVITY_CONTEXT_ASSIGNMENT' IN TYPEOF(x) )) = 1;
END_ENTITY;


ENTITY configured_effectivity_context_assignment
	SUBTYPE OF (effectivity_context_assignment);
	items : SET [1:?] OF configured_effectivity_context_item;
	SELF\effectivity_context_assignment.assigned_effectivity_assignment : configured_effectivity_assignment;
WHERE
	WR1 : SIZEOF(SELF.items) = 1;
END_ENTITY;


ENTITY conic
	SUPERTYPE OF (ONEOF (circle, ellipse, hyperbola, parabola))
	SUBTYPE OF (curve);
	position : axis2_placement;
END_ENTITY;


ENTITY conical_stepped_hole_transition
	SUBTYPE OF (geometric_representation_item);
	transition_number : positive_integer;
	cone_apex_angle : plane_angle_measure;
	cone_base_radius : positive_length_measure;
END_ENTITY;


ENTITY conical_surface
	SUBTYPE OF (elementary_surface);
	radius : length_measure;
	semi_angle : plane_angle_measure;
WHERE
	WR1 : radius >= 0.0;
END_ENTITY;


ENTITY connected_edge_set
	SUBTYPE OF (topological_representation_item);
	ces_edges : SET [1:?] OF edge;
END_ENTITY;


ENTITY connected_face_set
	SUPERTYPE OF (ONEOF (closed_shell, open_shell))
	SUBTYPE OF (topological_representation_item);
	cfs_faces : SET [1:?] OF face;
END_ENTITY;


ENTITY connected_face_sub_set
	SUBTYPE OF (connected_face_set);
	parent_face_set : connected_face_set;
END_ENTITY;


ENTITY constant_function
	SUBTYPE OF (maths_function, generic_literal);
	sole_output : maths_value;
	source_of_domain : maths_space_or_function;
WHERE
	WR1 : no_cyclic_domain_reference(source_of_domain, [SELF]);
	WR2 : expression_is_constant(domain_from(source_of_domain));
END_ENTITY;


ENTITY constant_surface_3d_element_coordinate_system
	SUBTYPE OF (fea_representation_item);
	axis : INTEGER;
	angle : plane_angle_measure;
WHERE
	WR1 : (axis >= 1) AND (axis <= 2);
END_ENTITY;


ENTITY constraint_element
	SUPERTYPE OF (ONEOF (single_point_constraint_element, linear_constraint_equation_element, nodal_dof_reduction, point_constraint, curve_constraint, surface_constraint, solid_constraint));
	element_id : identifier;
	steps : SET [1:?] OF control_analysis_step;
END_ENTITY;


ENTITY constructive_geometry_representation
	SUBTYPE OF (representation);
WHERE
	WR1 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF.context_of_items)) AND ({2 <= SELF.context_of_items\geometric_representation_context. coordinate_space_dimension <= 3});
	WR2 : SIZEOF( QUERY( cgr_i <* SELF.items | SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLACEMENT', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_SURFACE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT'] * TYPEOF(cgr_i)) <> 1 )) = 0;
	WR3 : SIZEOF( USEDIN( SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2') ) > 0;
	WR4 : SIZEOF( USEDIN( SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'REPRESENTATION_MAP.MAPPED_REPRESENTATION') ) = 0;
END_ENTITY;


ENTITY constructive_geometry_representation_relationship
	SUBTYPE OF (representation_relationship);
	SELF\representation_relationship.rep_1 : constructive_geometry_representation_or_shape_represenation;
	SELF\representation_relationship.rep_2 : constructive_geometry_representation;
WHERE
	WR1 : (SELF.rep_1.context_of_items :=: SELF.rep_2.context_of_items) AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF.rep_1.context_of_items));
	WR2 : NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION' IN TYPEOF(SELF));
END_ENTITY;


ENTITY contact_ratio_representation
	SUBTYPE OF (representation);
WHERE
	WR1 : ( SIZEOF ( SELF.items ) =1 ) AND ( SIZEOF ( QUERY ( i <*
        SELF.items | ( SIZEOF ( ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'MEASURE_REPRESENTATION_ITEM' , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'VALUE_RANGE']* TYPEOF ( i ) ) =1 ) AND ( i.name =
        'ratio value' ) ) ) =1 );
	WR2 : ( SIZEOF ( QUERY ( pdr <* USEDIN ( SELF ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
        'USED_REPRESENTATION' ) | pdr. name =
        'contact ratio reference' ) ) =1 ) AND ( SIZEOF ( QUERY (
        pdr <* USEDIN ( SELF ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
        'USED_REPRESENTATION' ) | ( pdr. name =
        'contact ratio reference' ) AND ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'PRODUCT_DEFINITION' IN TYPEOF ( pdr.
        definition.definition ) ) ) ) =1 );
	WR3 : ( SIZEOF ( USEDIN ( SELF ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
        'USED_REPRESENTATION' ) ) =1 ) AND ( SIZEOF ( QUERY ( pdr
        <* USEDIN ( SELF ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
        'USED_REPRESENTATION' ) | SIZEOF ( QUERY ( gpa <* USEDIN (
        pdr. definition ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'GENERAL_PROPERTY_ASSOCIATION.'+
        'DERIVED_DEFINITION' ) | ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'GENERAL_PROPERTY' IN TYPEOF ( gpa. base_definition ) ) AND
        ( gpa. base_definition.name ='surface_condition' ) ) ) =1 )
        ) =1 );
END_ENTITY;


ENTITY context_dependent_invisibility
	SUBTYPE OF (invisibility);
	presentation_context : invisibility_context;
END_ENTITY;


ENTITY context_dependent_over_riding_styled_item
	SUBTYPE OF (over_riding_styled_item);
	style_context : LIST [1:?] OF style_context_select;
WHERE
	WR1 : (SIZEOF(QUERY(sc <* SELF.style_context | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(sc)))= 1) OR
(SIZEOF(QUERY(sc <* SELF.style_context |
     ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF(sc))
  OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REPRESENTATION_RELATIONSHIP' IN TYPEOF(sc)) ))
  = SIZEOF(style_context));
END_ENTITY;


ENTITY context_dependent_shape_representation;
	representation_relation : shape_representation_relationship;
	represented_product_relation : product_definition_shape;
DERIVE
	description : text := get_description_value(SELF);
	name : label := get_name_value(SELF);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(SELF.represented_product_relation.definition);
	WR2 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
	WR3 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;


ENTITY context_dependent_unit
	SUBTYPE OF (named_unit);
	name : label;
END_ENTITY;


ENTITY contract;
	name : label;
	purpose : text;
	kind : contract_type;
END_ENTITY;


ENTITY contract_assignment
	ABSTRACT SUPERTYPE;
	assigned_contract : contract;
DERIVE
	role : object_role := get_role(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;


ENTITY contract_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_contract : contract;
	related_contract : contract;
END_ENTITY;


ENTITY contract_type;
	description : label;
END_ENTITY;


ENTITY control;
	model_ref : fea_model;
	control_id : identifier;
	creating_software : text;
	description : text;
	user_defined_control : SET [1:?] OF text;
	intended_analysis_code : SET [1:?] OF text;
UNIQUE
	UR1 : model_ref, control_id;
END_ENTITY;


ENTITY control_analysis_step
	SUPERTYPE OF (ONEOF (control_linear_static_analysis_step, control_linear_modes_and_frequencies_analysis_step))
	SUBTYPE OF (analysis_step);
	step_id : identifier;
	sequence : INTEGER;
	initial_state : state;
	description : text;
UNIQUE
	UR2 : SELF\analysis_step.analysis_control, step_id;
	UR1 : SELF\analysis_step.analysis_control, sequence;
END_ENTITY;


ENTITY control_linear_modes_and_frequencies_analysis_step
	SUBTYPE OF (control_analysis_step);
	process : control_linear_modes_and_frequencies_process;
	number_of_modes : count_measure;
	frequency_range : ARRAY [1:2] OF context_dependent_measure;
END_ENTITY;


ENTITY control_linear_modes_and_frequencies_process
	SUBTYPE OF (control_process);
	final_input_state : state;
END_ENTITY;


ENTITY control_linear_static_analysis_step
	SUBTYPE OF (control_analysis_step);
	process : control_linear_static_load_increment_process;
END_ENTITY;


ENTITY control_linear_static_analysis_step_with_harmonic
	SUBTYPE OF (control_linear_static_analysis_step);
	symmetry : cylindrical_symmetry_control;
END_ENTITY;


ENTITY control_linear_static_load_increment_process
	SUBTYPE OF (control_process);
	final_input_state : state;
END_ENTITY;


ENTITY control_process
	SUPERTYPE OF (ONEOF (control_linear_static_load_increment_process, control_linear_modes_and_frequencies_process));
	process_id : identifier;
	description : text;
END_ENTITY;


ENTITY control_result_relationship;
	control : control_analysis_step;
	result : result_analysis_step;
END_ENTITY;


ENTITY conversion_based_unit
	SUBTYPE OF (named_unit);
	name : label;
	conversion_factor : measure_with_unit;
WHERE
	WR1 : SELF\named_unit.dimensions = derive_dimensional_exponents(conversion_factor\measure_with_unit.unit_component);
END_ENTITY;


ENTITY coordinated_universal_time_offset;
	hour_offset : INTEGER;
	minute_offset : OPTIONAL INTEGER;
	sense : ahead_or_behind;
DERIVE
	actual_minute_offset : INTEGER := NVL(minute_offset,0);
WHERE
	WR1 : { 0 <= hour_offset < 24 };
	WR2 : { 0 <= actual_minute_offset <= 59 };
	WR3 : NOT (((hour_offset <> 0) OR (actual_minute_offset <>0)) AND (sense = exact));
END_ENTITY;


ENTITY cos_function
	SUBTYPE OF (unary_function_call);
END_ENTITY;


ENTITY csg_shape_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 : SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3;
	WR2 : SIZEOF ( 
QUERY ( it <* SELF.items| ( SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CSG_SOLID', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_REPLICA', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REVOLVED_FACE_SOLID', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EXTRUDED_FACE_SOLID' ] * TYPEOF (it)) <> 1) )) = 0;
	WR3 : SIZEOF ( 
QUERY ( mi <* 
QUERY ( it <* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CSG_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
	WR4 : SIZEOF ( 
QUERY ( sr <* 
QUERY ( it <* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_REPLICA' IN TYPEOF (it)) )| ( SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CSG_SOLID', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REVOLVED_FACE_SOLID', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EXTRUDED_FACE_SOLID' ] * TYPEOF (sr\solid_replica.parent_solid)) = 0) )) = 0;
	WR5 : SIZEOF ( 
QUERY ( it <* SELF.items| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D' IN TYPEOF (it)) )) > 0;
END_ENTITY;


ENTITY csg_solid
	SUBTYPE OF (solid_model);
	tree_root_expression : csg_select;
END_ENTITY;


ENTITY currency
	ABSTRACT SUPERTYPE OF (ONEOF (externally_defined_currency, iso4217_currency))
	SUBTYPE OF (context_dependent_unit);
WHERE
	WR1 : ((SELF\named_unit.dimensions.length_exponent = 0.0) AND
           (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
           (SELF\named_unit.dimensions.time_exponent = 0.0) AND
           (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
           (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
           (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
           (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0));
END_ENTITY;


ENTITY currency_measure_with_unit
	SUBTYPE OF (measure_with_unit);
	SELF\measure_with_unit.unit_component : currency;
END_ENTITY;


ENTITY curve
	SUPERTYPE OF (ONEOF (line, conic, pcurve, surface_curve, offset_curve_2d, offset_curve_3d, curve_replica))
	SUBTYPE OF (geometric_representation_item);
END_ENTITY;


ENTITY curve_2d_element_basis;
	descriptor : curve_2d_element_descriptor;
	variable : curve_element_variable;
END_ENTITY;


ENTITY curve_2d_element_constant_specified_variable_value
	SUBTYPE OF (curve_2d_element_field_variable_definition);
	simple_value : field_value;
	variable : surface_element_variable;
	coordinate_system : OPTIONAL curve_2d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY curve_2d_element_constant_specified_volume_variable_value
	SUBTYPE OF (curve_2d_element_field_variable_definition);
	simple_value : field_value;
	variable : volume_variable;
	coordinate_system : OPTIONAL curve_2d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY curve_2d_element_coordinate_system
	SUBTYPE OF (fea_representation_item);
	orientation : direction;
WHERE
	WR1 : SELF\geometric_representation_item.dim=2;
END_ENTITY;


ENTITY curve_2d_element_field_variable_definition
	SUPERTYPE OF (ONEOF (curve_2d_element_location_point_volume_variable_values, curve_2d_element_location_point_variable_values, curve_2d_whole_element_variable_value, curve_2d_element_constant_specified_variable_value, curve_2d_element_constant_specified_volume_variable_value))
	SUBTYPE OF (field_variable_element_definition);
	element : curve_2d_element_output_reference;
END_ENTITY;


ENTITY curve_2d_element_group
	SUBTYPE OF (element_group);
WHERE
	WR1 : SIZEOF(QUERY(item <* elements |
       (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
             'AXISYMMETRIC_CURVE_2D_ELEMENT_REPRESENTATION'
              IN TYPEOF(item)) AND
        NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
             'PLANE_CURVE_2D_ELEMENT_REPRESENTATION'
              IN TYPEOF(item)))))=0;
END_ENTITY;


ENTITY curve_2d_element_integrated_matrix;
	descriptor : curve_2d_element_descriptor;
	property_type : curve_matrix_property_type;
	integration_description : text;
END_ENTITY;


ENTITY curve_2d_element_integrated_matrix_with_definition
	SUBTYPE OF (curve_2d_element_integrated_matrix);
	integration_definition : curve_2d_element_integration;
END_ENTITY;


ENTITY curve_2d_element_integration;
	section : LIST [1:?] OF curve_section_element_location;
END_ENTITY;


ENTITY curve_2d_element_location_point_variable_values
	SUBTYPE OF (curve_2d_element_field_variable_definition);
	basis : BOOLEAN;
	values_and_locations : SET [1:?] OF curve_2d_element_value_and_location;
	variable : curve_element_variable;
WHERE
	WR1 : consistent_set_values (values_and_locations, variable);
	WR2 : appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY curve_2d_element_location_point_volume_variable_values
	SUBTYPE OF (curve_2d_element_field_variable_definition);
	basis : BOOLEAN;
	values_and_locations : SET [1:?] OF curve_2d_element_value_and_volume_location;
	variable : curve_element_variable;
WHERE
	WR1 : consistent_set_values (values_and_locations, variable);
	WR2 : appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY curve_2d_element_property;
	property_id : identifier;
	description : text;
	section : curve_element_section_definition;
END_ENTITY;


ENTITY curve_2d_element_value_and_location;
	simple_value : field_value;
	location : curve_section_element_location;
	coordinate_system : OPTIONAL curve_2d_state_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;


ENTITY curve_2d_element_value_and_volume_location;
	simple_value : field_value;
	location : curve_volume_element_location;
	coordinate_system : OPTIONAL curve_2d_state_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;


ENTITY curve_2d_node_field_aggregated_variable_values
	SUBTYPE OF (curve_2d_node_field_variable_definition);
	simple_value : field_value;
	variable : volume_aggregated_variable;
	coordinate_system : OPTIONAL curve_2d_state_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY curve_2d_node_field_section_variable_values
	SUBTYPE OF (curve_2d_node_field_variable_definition);
	simple_value : field_value;
	variable : curve_element_variable;
	location : curve_section_element_location;
	coordinate_system : OPTIONAL curve_2d_state_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY curve_2d_node_field_variable_definition
	SUPERTYPE OF (ONEOF (curve_2d_node_field_section_variable_values, curve_2d_node_field_aggregated_variable_values))
	SUBTYPE OF (field_variable_node_definition);
END_ENTITY;


ENTITY curve_2d_substructure_element_reference;
	substructure_element_ref : substructure_element_representation;
	element_ref : curve_2d_element_representation;
END_ENTITY;


ENTITY curve_2d_whole_element_variable_value
	SUBTYPE OF (curve_2d_element_field_variable_definition);
	simple_value : field_value;
	variable : volume_aggregated_variable;
	coordinate_system : OPTIONAL curve_2d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY curve_3d_element_basis;
	descriptor : curve_3d_element_descriptor;
	variable : curve_element_variable;
	variable_order : element_order;
	variable_shape_function : shape_function;
	evaluation_points : LIST [1:?] OF curve_element_location;
END_ENTITY;


ENTITY curve_3d_element_constant_specified_variable_value
	SUBTYPE OF (curve_3d_element_field_variable_definition);
	simple_value : field_value;
	variable : curve_element_variable;
	coordinate_system : OPTIONAL curve_3d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY curve_3d_element_constant_specified_volume_variable_value
	SUBTYPE OF (curve_3d_element_field_variable_definition);
	simple_value : field_value;
	variable : volume_variable;
	coordinate_system : OPTIONAL curve_3d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY curve_3d_element_descriptor
	SUBTYPE OF (element_descriptor);
	purpose : SET [1:?] OF SET [1:?] OF curve_element_purpose;
END_ENTITY;


ENTITY curve_3d_element_field_variable_definition
	SUPERTYPE OF (ONEOF (curve_3d_element_location_point_volume_variable_values, curve_3d_element_location_point_variable_values, curve_3d_whole_element_variable_value, curve_3d_element_constant_specified_variable_value, curve_3d_element_constant_specified_volume_variable_value, curve_3d_element_nodal_specified_variable_values))
	SUBTYPE OF (field_variable_element_definition);
	element : curve_3d_element_output_reference;
END_ENTITY;


ENTITY curve_3d_element_group
	SUBTYPE OF (element_group);
WHERE
	WR1 : SIZEOF(query(item <* elements |
       NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
            'CURVE_3D_ELEMENT_REPRESENTATION' IN TYPEOF (item))))=0;
END_ENTITY;


ENTITY curve_3d_element_integrated_matrix;
	descriptor : curve_3d_element_descriptor;
	property_type : curve_matrix_property_type;
	integration_description : text;
END_ENTITY;


ENTITY curve_3d_element_integrated_matrix_with_definition
	SUBTYPE OF (curve_3d_element_integrated_matrix);
	integration_definition : curve_3d_element_integration;
END_ENTITY;


ENTITY curve_3d_element_integration;
	element_length : curve_3d_element_length_integration;
	section : curve_section_integration_explicit;
END_ENTITY;


ENTITY curve_3d_element_length_integration_explicit;
	integration_positions_and_weights : SET [1:?] OF curve_3d_element_position_weight;
END_ENTITY;


ENTITY curve_3d_element_length_integration_rule;
	integration_method : integration_rule;
	integration_order : INTEGER;
END_ENTITY;


ENTITY curve_3d_element_location_point_variable_values
	SUBTYPE OF (curve_3d_element_field_variable_definition);
	basis : BOOLEAN;
	values_and_locations : SET [1:?] OF curve_3d_element_value_and_location;
	variable : curve_element_variable;
WHERE
	WR1 : consistent_set_values (values_and_locations, variable);
	WR2 : appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY curve_3d_element_location_point_volume_variable_values
	SUBTYPE OF (curve_3d_element_field_variable_definition);
	basis : BOOLEAN;
	values_and_locations : SET [1:?] OF curve_3d_element_value_and_volume_location;
	variable : volume_variable;
WHERE
	WR1 : consistent_set_values (values_and_locations, variable);
	WR2 : appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY curve_3d_element_nodal_specified_variable_values
	SUBTYPE OF (curve_3d_element_field_variable_definition);
	values : LIST [1:?] OF field_value;
	additional_node_values : BOOLEAN;
	variable : curve_element_variable;
WHERE
	WR1 : consistent_list_values (values, variable);
	WR2 : appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY curve_3d_element_position_weight;
	integration_position : curve_volume_element_location;
	integration_weight : context_dependent_measure;
END_ENTITY;


ENTITY curve_3d_element_property;
	property_id : identifier;
	description : text;
	interval_definitions : LIST [1:?] OF curve_element_interval;
	end_offsets : ARRAY [1:2] OF curve_element_end_offset;
	end_releases : ARRAY [1:2] OF curve_element_end_release;
END_ENTITY;


ENTITY curve_3d_element_representation
	SUBTYPE OF (element_representation);
	model_ref : fea_model_3d;
	element_descriptor : curve_3d_element_descriptor;
	property : curve_3d_element_property;
	material : element_material;
UNIQUE
	UR1 : model_ref, SELF\representation.name;
WHERE
	WR1 : SIZEOF (QUERY(item <* SELF\representation.items |
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
              'PARAMETRIC_CURVE_3D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) +
       SIZEOF (QUERY(item <* SELF\representation.items |
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
              'ALIGNED_CURVE_3D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) = 1;
	WR2 : SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_MASS_DENSITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_AREA_DENSITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_MOISTURE_ABSORPTION'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
	WR3 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items);
	FU1 : required_1d_nodes (
        SELF\element_representation.node_list,
        element_descriptor\element_descriptor.topology_order);
END_ENTITY;


ENTITY curve_3d_element_value_and_location;
	simple_value : field_value;
	location : curve_element_location;
	coordinate_system : OPTIONAL curve_3d_state_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;


ENTITY curve_3d_element_value_and_volume_location;
	simple_value : field_value;
	location : curve_volume_element_location;
	coordinate_system : OPTIONAL curve_3d_state_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;


ENTITY curve_3d_node_field_aggregated_variable_values
	SUBTYPE OF (curve_3d_node_field_variable_definition);
	simple_value : field_value;
	variable : volume_aggregated_variable;
	coordinate_system : OPTIONAL curve_3d_state_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY curve_3d_node_field_section_variable_values
	SUBTYPE OF (curve_3d_node_field_variable_definition);
	simple_value : field_value;
	variable : curve_element_variable;
	location : curve_section_element_location;
	coordinate_system : OPTIONAL curve_3d_state_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY curve_3d_node_field_variable_definition
	SUPERTYPE OF (ONEOF (curve_3d_node_field_section_variable_values, curve_3d_node_field_aggregated_variable_values))
	SUBTYPE OF (field_variable_node_definition);
END_ENTITY;


ENTITY curve_3d_substructure_element_reference;
	substructure_element_ref : substructure_element_representation;
	element_ref : curve_3d_element_representation;
END_ENTITY;


ENTITY curve_3d_whole_element_variable_value
	SUBTYPE OF (curve_3d_element_field_variable_definition);
	simple_value : field_value;
	variable : volume_aggregated_variable;
	coordinate_system : OPTIONAL curve_3d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY curve_bounded_surface
	SUBTYPE OF (bounded_surface);
	basis_surface : surface;
	boundaries : SET [1:?] OF boundary_curve;
	implicit_outer : BOOLEAN;
WHERE
	WR1 : (NOT implicit_outer) OR
         (SIZEOF (QUERY (temp <* boundaries |
           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) = 0);
	WR2 : (NOT(implicit_outer)) OR
                ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BOUNDED_SURFACE' IN TYPEOF(basis_surface));
	WR3 : SIZEOF(QUERY(temp <* boundaries |
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OUTER_BOUNDARY_CURVE' IN
                                         TYPEOF(temp))) <= 1;
	WR4 : SIZEOF(QUERY(temp <* boundaries |
            (temp\composite_curve_on_surface.basis_surface [1] <>
                                         SELF.basis_surface))) = 0;
END_ENTITY;


ENTITY curve_constraint
	SUBTYPE OF (constraint_element);
	required_curve : analysis_item_within_representation;
	coordinate_system : fea_axis2_placement_3d;
	freedoms_and_coefficients : SET [1:?] OF freedom_and_coefficient;
	description : text;
WHERE
	WR1 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE' IN TYPEOF (required_curve.item)) OR
       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_CURVE' IN TYPEOF (required_curve.item));
END_ENTITY;


ENTITY curve_dimension
	SUBTYPE OF (dimension_curve_directed_callout);
END_ENTITY;


ENTITY curve_element_end_offset;
	coordinate_system : curve_element_end_coordinate_system;
	offset_vector : ARRAY [1:3] OF context_dependent_measure;
END_ENTITY;


ENTITY curve_element_end_release;
	coordinate_system : curve_element_end_coordinate_system;
	releases : LIST [1:?] OF curve_element_end_release_packet;
END_ENTITY;


ENTITY curve_element_end_release_packet;
	release_freedom : curve_element_freedom;
	release_stiffness : context_dependent_measure;
END_ENTITY;


ENTITY curve_element_interval
	SUPERTYPE OF (ONEOF (curve_element_interval_constant, curve_element_interval_linearly_varying));
	finish_position : curve_element_location;
	eu_angles : euler_angles;
END_ENTITY;


ENTITY curve_element_interval_constant
	SUBTYPE OF (curve_element_interval);
	section : curve_element_section_definition;
END_ENTITY;


ENTITY curve_element_interval_linearly_varying
	SUBTYPE OF (curve_element_interval);
	sections : ARRAY [1:2] OF curve_element_section_definition;
END_ENTITY;


ENTITY curve_element_location;
	coordinate : fea_parametric_point;
END_ENTITY;


ENTITY curve_element_section_definition
	SUPERTYPE OF (curve_element_section_derived_definitions);
	description : text;
	section_angle : plane_angle_measure;
END_ENTITY;


ENTITY curve_element_section_derived_definitions
	SUBTYPE OF (curve_element_section_definition);
	cross_sectional_area : context_dependent_measure;
	shear_area : ARRAY [1:2] OF measure_or_unspecified_value;
	second_moment_of_area : ARRAY [1:3] OF context_dependent_measure;
	torsional_constant : context_dependent_measure;
	warping_constant : measure_or_unspecified_value;
	location_of_centroid : ARRAY [1:2] OF measure_or_unspecified_value;
	location_of_shear_centre : ARRAY [1:2] OF measure_or_unspecified_value;
	location_of_non_structural_mass : ARRAY [1:2] OF measure_or_unspecified_value;
	non_structural_mass : measure_or_unspecified_value;
	polar_moment : measure_or_unspecified_value;
END_ENTITY;


ENTITY curve_freedom_action_definition
	SUBTYPE OF (curve_freedom_and_value_definition);
	action : action_type;
END_ENTITY;


ENTITY curve_freedom_and_value_definition
	SUPERTYPE OF (ONEOF (curve_freedom_values, curve_freedom_action_definition))
	SUBTYPE OF (state_definition);
	required_curve : analysis_item_within_representation;
	coordinate_system : fea_axis2_placement_3d;
	degrees_of_freedom : freedoms_list;
	values : LIST [1:?] OF measure_or_unspecified_value;
WHERE
	WR1 : SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (values);
	WR2 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE' IN TYPEOF (required_curve.item)) OR
       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_CURVE' IN TYPEOF (required_curve.item));
END_ENTITY;


ENTITY curve_freedom_values
	SUBTYPE OF (curve_freedom_and_value_definition);
END_ENTITY;


ENTITY curve_replica
	SUBTYPE OF (curve);
	parent_curve : curve;
	transformation : cartesian_transformation_operator;
WHERE
	WR1 : transformation.dim = parent_curve.dim;
	WR2 : acyclic_curve_replica (SELF, parent_curve);
END_ENTITY;


ENTITY curve_section_element_location;
	offsets : ARRAY [1:2] OF context_dependent_measure;
END_ENTITY;


ENTITY curve_section_integration_explicit;
	integration_positions : SET [1:?] OF curve_section_element_location;
END_ENTITY;


ENTITY curve_style
	SUBTYPE OF (founded_item);
	name : label;
	curve_font : curve_font_or_scaled_curve_font_select;
	curve_width : size_select;
	curve_colour : colour;
END_ENTITY;


ENTITY curve_style_font
	SUBTYPE OF (founded_item);
	name : label;
	pattern_list : LIST [1:?] OF curve_style_font_pattern;
END_ENTITY;


ENTITY curve_style_font_and_scaling
	SUBTYPE OF (founded_item);
	name : label;
	curve_font : curve_style_font_select;
	curve_font_scaling : REAL;
END_ENTITY;


ENTITY curve_style_font_pattern
	SUBTYPE OF (founded_item);
	visible_segment_length : positive_length_measure;
	invisible_segment_length : positive_length_measure;
END_ENTITY;


ENTITY curve_style_rendering;
	rendering_method : shading_curve_method;
	rendering_properties : surface_rendering_properties;
END_ENTITY;


ENTITY curve_swept_solid_shape_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 : SIZEOF (QUERY (it <* SELF.items |
          NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SWEPT_AREA_SOLID',
                'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SWEPT_DISK_SOLID',
                'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM',
                'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D'] *
                   TYPEOF(it)) = 1))) = 0;
	WR2 : SIZEOF (QUERY (it <* SELF.items |
         SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SWEPT_AREA_SOLID',
                'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SWEPT_DISK_SOLID',
          'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'] * TYPEOF(it)) =1 )) > 0;
	WR3 : SIZEOF (QUERY (mi <*  QUERY (it <* items |
                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF(it)) |
   NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_SWEPT_SOLID_SHAPE_REPRESENTATION' IN
             TYPEOF(mi\mapped_item.mapping_source.
                           mapped_representation)))) = 0;
	WR4 : SIZEOF (QUERY (scsas <* QUERY (it <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE_SWEPT_AREA_SOLID' IN
              TYPEOF(it)) |
          NOT(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE' IN
                 TYPEOF(scsas\surface_curve_swept_area_solid.directrix)) OR
                   ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN
                   TYPEOF(scsas\surface_curve_swept_area_solid.directrix))))) = 0;
END_ENTITY;


ENTITY curve_volume_element_location;
	field_location : curve_element_location;
	section_location : curve_section_element_location;
END_ENTITY;


ENTITY cylindrical_point
	SUBTYPE OF (cartesian_point);
	r : length_measure;
	theta : plane_angle_measure;
	z : length_measure;
DERIVE
	SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure := [r*cos(theta), r*sin(theta), z];
WHERE
	WR1 : r >= 0.0;
END_ENTITY;


ENTITY cylindrical_surface
	SUBTYPE OF (elementary_surface);
	radius : positive_length_measure;
END_ENTITY;


ENTITY cylindrical_symmetry_control
	SUBTYPE OF (symmetry_control);
	harmonic : cylindrical_harmonic_number;
	phase : measure_or_unspecified_value;
END_ENTITY;


ENTITY cylindricity_tolerance
	SUBTYPE OF (geometric_tolerance);
WHERE
	WR1 : NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF));
END_ENTITY;


ENTITY data_environment;
	name : label;
	description : text;
	elements : SET [1:?] OF property_definition_representation;
END_ENTITY;


ENTITY date
	SUPERTYPE OF (ONEOF (calendar_date, ordinal_date, week_of_year_and_day_date, year_month));
	year_component : year_number;
END_ENTITY;


ENTITY date_and_time;
	date_component : date;
	time_component : local_time;
END_ENTITY;


ENTITY date_and_time_assignment
	ABSTRACT SUPERTYPE;
	assigned_date_and_time : date_and_time;
	role : date_time_role;
END_ENTITY;


ENTITY date_assignment
	ABSTRACT SUPERTYPE;
	assigned_date : date;
	role : date_role;
END_ENTITY;


ENTITY date_representation_item
	SUBTYPE OF (representation_item, date);
END_ENTITY;


ENTITY date_role;
	name : label;
DERIVE
	description : text := get_description_value (SELF);
WHERE
	WR1 : SIZEOF (USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;


ENTITY date_time_representation_item
	SUBTYPE OF (representation_item, date_and_time);
END_ENTITY;


ENTITY date_time_role;
	name : label;
DERIVE
	description : text := get_description_value (SELF);
WHERE
	WR1 : SIZEOF (USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;


ENTITY dated_effectivity
	SUBTYPE OF (effectivity);
	effectivity_end_date : OPTIONAL date_time_or_event_occurrence;
	effectivity_start_date : date_time_or_event_occurrence;
END_ENTITY;


ENTITY datum
	SUBTYPE OF (shape_aspect);
	identification : identifier;
INVERSE
	established_by_relationships: SET [1:?] OF shape_aspect_relationship FOR related_shape_aspect;
WHERE
	WR1 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMMON_DATUM' IN TYPEOF(SELF)) XOR
       ((SIZEOF(QUERY(x <* SELF\datum.established_by_relationships |
       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DATUM_FEATURE' IN TYPEOF(x\shape_aspect_relationship.relating_shape_aspect)))) = 1) XOR
       (SIZEOF(QUERY(x <* SELF\datum.established_by_relationships |
       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DATUM_TARGET' IN TYPEOF(x\shape_aspect_relationship.relating_shape_aspect)))) >= 1));
END_ENTITY;


ENTITY datum_feature
	SUBTYPE OF (shape_aspect);
INVERSE
	feature_basis_relationship: SET [1:?] OF shape_aspect_relationship FOR relating_shape_aspect;
WHERE
	WR1 : SIZEOF(QUERY(sar <* SELF\datum_feature.feature_basis_relationship 
       | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DATUM' IN TYPEOF
       (sar\shape_aspect_relationship.related_shape_aspect)))) = 1;
	WR2 : SELF\shape_aspect.product_definitional = TRUE;
END_ENTITY;


ENTITY datum_feature_callout
	SUBTYPE OF (draughting_callout);
END_ENTITY;


ENTITY datum_reference;
	precedence : INTEGER;
	referenced_datum : datum;
WHERE
	WR1 : precedence > 0;
END_ENTITY;


ENTITY datum_target
	SUBTYPE OF (shape_aspect);
	target_id : identifier;
INVERSE
	target_basis_relationship: SET [1:?] OF shape_aspect_relationship FOR relating_shape_aspect;
WHERE
	WR1 : SIZEOF(QUERY(sar <* SELF\datum_target.target_basis_relationship 
       | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DATUM' IN TYPEOF
       (sar\shape_aspect_relationship.related_shape_aspect)))) = 1;
	WR2 : SELF\shape_aspect.product_definitional = TRUE;
END_ENTITY;


ENTITY datum_target_callout
	SUBTYPE OF (draughting_callout);
END_ENTITY;


ENTITY default_tolerance_table
	SUBTYPE OF (representation);
WHERE
	WR1 : SIZEOF( QUERY( i <* SELF.items | NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DEFAULT_TOLERANCE_TABLE_CELL' IN TYPEOF(i)) )) = 0;
	WR2 : (SIZEOF( QUERY( rr <* USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_1') | rr.name < 'general tolerance definition' )) = 0) AND (SIZEOF( QUERY( rr <* USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_1') | (rr.name = 'general tolerance definition') AND (rr.rep_2.name < 'default tolerance') )) = 0) AND (SIZEOF( USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2') ) = 0);
END_ENTITY;


ENTITY default_tolerance_table_cell
	SUBTYPE OF (compound_representation_item);
WHERE
	WR1 : SIZEOF(QUERY( x <* USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'REPRESENTATION.ITEMS') | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DEFAULT_TOLERANCE_TABLE' IN TYPEOF(x)))=1;
	WR2 : default_tolerance_table_cell_wr2(SELF\compound_representation_item.item_element);
	WR3 : default_tolerance_table_cell_wr3(SELF\compound_representation_item.item_element);
	WR4 : default_tolerance_table_cell_wr4(SELF\compound_representation_item.item_element);
	WR5 : default_tolerance_table_cell_wr5(SELF\compound_representation_item.item_element);
END_ENTITY;


ENTITY defined_function
	ABSTRACT SUPERTYPE OF ((ONEOF (numeric_defined_function, string_defined_function, boolean_defined_function) ANDOR SQL_mappable_defined_function));
END_ENTITY;


ENTITY defined_maths_space_context
	SUBTYPE OF (maths_space_context);
END_ENTITY;


ENTITY defined_symbol
	SUBTYPE OF (geometric_representation_item);
	definition : defined_symbol_select;
	target : symbol_target;
END_ENTITY;


ENTITY definite_integral_expression
	SUBTYPE OF (quantifier_expression);
	lower_limit_neg_infinity : BOOLEAN;
	upper_limit_pos_infinity : BOOLEAN;
DERIVE
	integrand : generic_expression := SELF\multiple_arity_generic_expression.operands[1];
	variable_of_integration : maths_variable := SELF\multiple_arity_generic_expression.operands[2];
	SELF\quantifier_expression.variables : LIST [1:1] OF  UNIQUE generic_variable := [variable_of_integration];
WHERE
	WR1 : has_values_space (integrand);
	WR2 : space_is_continuum (values_space_of (integrand));
	WR3 : definite_integral_expr_check (SELF\multiple_arity_generic_expression.operands,
    lower_limit_neg_infinity, upper_limit_pos_infinity);
END_ENTITY;


ENTITY definite_integral_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	variable_of_integration : input_selector;
	lower_limit_neg_infinity : BOOLEAN;
	upper_limit_pos_infinity : BOOLEAN;
	SELF\unary_generic_expression.operand : maths_function;
DERIVE
	integrand : maths_function := SELF\unary_generic_expression.operand;
WHERE
	WR1 : space_is_continuum (integrand.range);
	WR2 : definite_integral_check (integrand.domain, variable_of_integration,
    lower_limit_neg_infinity, upper_limit_pos_infinity);
END_ENTITY;


ENTITY definitional_representation
	SUBTYPE OF (representation);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT' IN
          TYPEOF (SELF\representation.context_of_items );
END_ENTITY;


ENTITY definitional_representation_relationship
	SUBTYPE OF (representation_relationship);
WHERE
	WR1 : acyclic_representation_relationship(SELF,
         [SELF\representation_relationship.rep_2],
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'REPRESENTATION');
END_ENTITY;


ENTITY definitional_representation_relationship_with_same_context
	SUBTYPE OF (definitional_representation_relationship);
WHERE
	WR1 : SELF\representation_relationship.rep_1.context_of_items :=: 
            SELF\representation_relationship.rep_2.context_of_items;
END_ENTITY;


ENTITY degenerate_pcurve
	SUBTYPE OF (point);
	basis_surface : surface;
	reference_to_curve : definitional_representation;
WHERE
	WR1 : SIZEOF(reference_to_curve\representation.items) = 1;
	WR2 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE' IN TYPEOF
                    (reference_to_curve\representation.items[1]);
	WR3 : reference_to_curve\representation.
                   items[1]\geometric_representation_item.dim =2;
END_ENTITY;


ENTITY degenerate_toroidal_surface
	SUBTYPE OF (toroidal_surface);
	select_outer : BOOLEAN;
WHERE
	WR1 : major_radius <   minor_radius;
END_ENTITY;


ENTITY dependent_variable_definition
	SUBTYPE OF (unary_generic_expression);
	name : label;
	description : text;
END_ENTITY;


ENTITY derived_shape_aspect
	SUPERTYPE OF (ONEOF (apex, centre_of_symmetry, geometric_alignment, geometric_intersection, parallel_offset, perpendicular_to, extension, tangent))
	SUBTYPE OF (shape_aspect);
INVERSE
	deriving_relationships: SET [1:?] OF shape_aspect_relationship FOR relating_shape_aspect;
WHERE
	WR1 : SIZEOF (QUERY (dr <*
          SELF\derived_shape_aspect.deriving_relationships |
          NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
               'SHAPE_ASPECT_DERIVING_RELATIONSHIP'
          IN TYPEOF (dr)))) = 0;
END_ENTITY;


ENTITY derived_unit
	SUPERTYPE OF (ONEOF (absorbed_dose_unit, acceleration_unit, radioactivity_unit, area_unit, capacitance_unit, dose_equivalent_unit, electric_charge_unit, conductance_unit, electric_potential_unit, energy_unit, magnetic_flux_density_unit, force_unit, frequency_unit, illuminance_unit, inductance_unit, magnetic_flux_unit, power_unit, pressure_unit, resistance_unit, velocity_unit, volume_unit));
	elements : SET [1:?] OF derived_unit_element;
DERIVE
	name : label := get_name_value(SELF);
WHERE
	WR1 : (SIZEOF(elements) > 1) OR ((SIZEOF(elements) = 1) AND (elements[1].exponent <> 1.0));
	WR2 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;


ENTITY derived_unit_element;
	unit : named_unit;
	exponent : REAL;
END_ENTITY;


ENTITY description_attribute;
	attribute_value : text;
	described_item : description_attribute_select;
END_ENTITY;


ENTITY descriptive_representation_item
	SUPERTYPE OF (ONEOF (tagged_text_item, uniform_resource_identifier))
	SUBTYPE OF (representation_item);
	description : text;
END_ENTITY;


ENTITY design_context
	SUBTYPE OF (product_definition_context);
WHERE
	WR1 : SELF.life_cycle_stage = 'design';
END_ENTITY;


ENTITY design_make_from_relationship
	SUBTYPE OF (product_definition_relationship);
END_ENTITY;


ENTITY diameter_dimension
	SUBTYPE OF (dimension_curve_directed_callout);
END_ENTITY;


ENTITY dielectric_constant_measure_with_unit
	SUBTYPE OF (ratio_measure_with_unit);
END_ENTITY;


ENTITY dimension_callout
	SUBTYPE OF (draughting_callout);
WHERE
	WR1 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_DIRECTED_CALLOUT'
        IN (TYPEOF (SELF))) XOR
       (SIZEOF (QUERY(dce_1 <* SELF\draughting_callout.contents |
       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_CURVE'
        IN (TYPEOF(dce_1))))) = 0);
	WR2 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROJECTION_DIRECTED_CALLOUT'
        IN (TYPEOF (SELF))) XOR
       (SIZEOF (QUERY(dce_1 <* SELF\draughting_callout.contents |
       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROJECTION_CURVE'
        IN (TYPEOF(dce_1))))) = 0);
	WR3 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIMENSION_CURVE_DIRECTED_CALLOUT'
        IN (TYPEOF (SELF))) XOR
       (SIZEOF (QUERY(dce_1 <* SELF\draughting_callout.contents |
       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIMENSION_CURVE'
        IN (TYPEOF(dce_1))))) = 0);
END_ENTITY;


ENTITY dimension_callout_component_relationship
	SUBTYPE OF (draughting_callout_relationship);
WHERE
	WR1 : SELF.name IN ['prefix', 'suffix'];
	WR2 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRUCTURED_DIMENSION_CALLOUT'
           IN TYPEOF (SELF.relating_draughting_callout);
	WR3 : SIZEOF (TYPEOF (SELF.related_draughting_callout) *
       ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_DIRECTED_CALLOUT',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROJECTION_DIRECTED_CALLOUT',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIMENSION_CURVE_DIRECTED_CALLOUT',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRUCTURED_DIMENSION_CALLOUT']) = 0;
	WR4 : SELF.related_draughting_callout.contents *
       SELF.relating_draughting_callout.contents =
       SELF.related_draughting_callout.contents;
	WR5 : ((SELF.name = 'prefix') AND
       (SIZEOF (QUERY (ato <* QUERY (con <*
                 SELF.related_draughting_callout.contents |
         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(con))) |
         NOT (ato.name = 'prefix text')
       )) = 0));
	WR6 : ((SELF.name = 'suffix') AND
       (SIZEOF (QUERY (ato <* QUERY (con <*
                 SELF.related_draughting_callout.contents |
         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(con))) |
         NOT (ato.name = 'suffix text')
       )) = 0));
END_ENTITY;


ENTITY dimension_callout_relationship
	SUBTYPE OF (draughting_callout_relationship);
WHERE
	WR1 : SELF.name IN ['primary', 'secondary'];
	WR2 : SIZEOF (TYPEOF (SELF.relating_draughting_callout) * 
       ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANGULAR_DIMENSION',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_DIMENSION',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIAMETER_DIMENSION',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_DIRECTED_DIMENSION',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINEAR_DIMENSION',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORDINATE_DIMENSION',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.RADIUS_DIMENSION'])>=1;
	WR3 : SIZEOF (TYPEOF (SELF.related_draughting_callout) *
       ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIMENSION_CURVE_DIRECTED_CALLOUT',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROJECTION_DIRECTED_CALLOUT',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_DIRECTED_CALLOUT']) = 0;
	WR4 : SELF.related_draughting_callout.contents *
       SELF.relating_draughting_callout.contents =
       SELF.related_draughting_callout.contents;
END_ENTITY;


ENTITY dimension_curve
	SUBTYPE OF (annotation_curve_occurrence);
WHERE
	WR1 : (SIZEOF(
          QUERY(dct <* USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                'TERMINATOR_SYMBOL.ANNOTATED_CURVE')
               | (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
                  'DIMENSION_CURVE_TERMINATOR' IN TYPEOF(dct))
                  ))
          ) <= 2);
	WR2 : SIZEOF(
            QUERY( dcdc <* USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                   'DRAUGHTING_CALLOUT.CONTENTS') |
                   ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
                    'DIMENSION_CURVE_DIRECTED_CALLOUT' IN TYPEOF(dcdc)))
          )>= 1;
	WR3 : (SIZEOF(
            QUERY(dct1 <* USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                  'TERMINATOR_SYMBOL.ANNOTATED_CURVE') 
               | (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
                  'DIMENSION_CURVE_TERMINATOR' IN TYPEOF(dct1)) 
                  AND (dct1\dimension_curve_terminator.role = dimension_extent_usage.origin)))
          ) <= 1)
        AND 
        (SIZEOF(
            QUERY (dct2 <* USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
                   'TERMINATOR_SYMBOL.ANNOTATED_CURVE') 
                 | (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
                   'DIMENSION_CURVE_TERMINATOR' IN TYPEOF(dct2))
                   AND (dct2\dimension_curve_terminator.role = dimension_extent_usage.target)))
         ) <= 1);
END_ENTITY;


ENTITY dimension_curve_directed_callout
	SUBTYPE OF (draughting_callout);
WHERE
	WR1 : SIZEOF(QUERY(d_c<*SELF\draughting_callout.contents | 
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIMENSION_CURVE' IN (TYPEOF(d_c))))=1;
	WR2 : SIZEOF(SELF\draughting_callout.contents) >= 2;
END_ENTITY;


ENTITY dimension_curve_terminator
	SUBTYPE OF (terminator_symbol);
	role : dimension_extent_usage;
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIMENSION_CURVE' IN TYPEOF
        (SELF\terminator_symbol.annotated_curve);
END_ENTITY;


ENTITY dimension_curve_terminator_to_projection_curve_associativity
	SUBTYPE OF (annotation_occurrence_associativity);
	SELF\annotation_occurrence_relationship.related_annotation_occurrence : projection_curve;
	SELF\annotation_occurrence_relationship.relating_annotation_occurrence : dimension_curve_terminator;
END_ENTITY;


ENTITY dimension_pair
	SUBTYPE OF (draughting_callout_relationship);
WHERE
	WR1 : SELF.name IN ['chained', 'parallel'];
	WR2 : SIZEOF (TYPEOF (SELF.relating_draughting_callout) *
       ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANGULAR_DIMENSION',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_DIMENSION',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIAMETER_DIMENSION',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINEAR_DIMENSION',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORDINATE_DIMENSION',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.RADIUS_DIMENSION'])=1;
	WR3 : SIZEOF (TYPEOF (SELF.related_draughting_callout) *
       ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANGULAR_DIMENSION',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_DIMENSION',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIAMETER_DIMENSION',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINEAR_DIMENSION',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORDINATE_DIMENSION',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.RADIUS_DIMENSION'])=1;
END_ENTITY;


ENTITY dimension_related_tolerance_zone_element;
	related_dimension : dimensional_location;
	related_element : tolerance_zone_definition;
END_ENTITY;


ENTITY dimension_text_associativity
	SUBTYPE OF (text_literal, mapped_item);
WHERE
	WR1 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHAPE_DIMENSION_REPRESENTATION'
          IN TYPEOF (SELF\mapped_item.
                          mapping_source.mapped_representation));
	WR2 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAUGHTING_CALLOUT'
          IN TYPEOF (SELF\mapped_item.mapping_target));
	WR3 : SIZEOF (QUERY (ato <* QUERY (si <* 
          USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM.ITEM') |
            ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
              IN TYPEOF(si))) |
          NOT (SIZEOF( QUERY (dc <*
             USEDIN (ato, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                          'DRAUGHTING_CALLOUT.CONTENTS') |
               ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAUGHTING_CALLOUT'
             IN TYPEOF (dc)))
            * [SELF\mapped_item.mapping_target]) = 1)
          )) = 0;
END_ENTITY;


ENTITY dimensional_characteristic_representation;
	dimension : dimensional_characteristic;
	representation : shape_dimension_representation;
END_ENTITY;


ENTITY dimensional_exponents;
	length_exponent : REAL;
	mass_exponent : REAL;
	time_exponent : REAL;
	electric_current_exponent : REAL;
	thermodynamic_temperature_exponent : REAL;
	amount_of_substance_exponent : REAL;
	luminous_intensity_exponent : REAL;
END_ENTITY;


ENTITY dimensional_location
	SUPERTYPE OF (ONEOF (angular_location, dimensional_location_with_path))
	SUBTYPE OF (shape_aspect_relationship);
END_ENTITY;


ENTITY dimensional_location_with_path
	SUBTYPE OF (dimensional_location);
	path : shape_aspect;
END_ENTITY;


ENTITY dimensional_size
	SUPERTYPE OF (ONEOF (angular_size, dimensional_size_with_path));
	applies_to : shape_aspect;
	name : label;
WHERE
	WR1 : applies_to.product_definitional = TRUE;
END_ENTITY;


ENTITY dimensional_size_with_path
	SUBTYPE OF (dimensional_size);
	path : shape_aspect;
END_ENTITY;


ENTITY directed_action
	SUBTYPE OF (executed_action);
	directive : action_directive;
END_ENTITY;


ENTITY directed_dimensional_location
	SUBTYPE OF (dimensional_location);
END_ENTITY;


ENTITY direction
	SUBTYPE OF (geometric_representation_item);
	direction_ratios : LIST [2:3] OF REAL;
WHERE
	WR1 : SIZEOF(QUERY(tmp <* direction_ratios | tmp <> 0.0)) > 0;
END_ENTITY;


ENTITY direction_node
	SUBTYPE OF (direction);
	node_1 : node_representation;
	node_2 : node_representation;
DERIVE
	SELF\direction.direction_ratios : LIST [2:3] OF REAL := build_direction_node (node_1, node_2);
WHERE
	WR1 : SIZEOF (QUERY(item <* node_1\representation.items |
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT' IN TYPEOF (item))) = 1;
	WR2 : SIZEOF (QUERY(item <* node_2\representation.items |
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT' IN TYPEOF (item))) = 1;
	WR3 : NOT ((direction_ratios[1] = 0.0) AND
            (direction_ratios[2] = 0.0) AND
            (direction_ratios[3] = 0.0));
END_ENTITY;


ENTITY directionally_explicit_element_coefficient;
	property_type : matrix_property_type;
	coefficient : context_dependent_measure;
END_ENTITY;


ENTITY directionally_explicit_element_coordinate_system_aligned
	SUBTYPE OF (fea_representation_item);
	aligned_system : curve_3d_element_coordinate_system;
END_ENTITY;


ENTITY directionally_explicit_element_coordinate_system_arbitrary
	SUBTYPE OF (fea_representation_item);
	arbitrary_system : fea_axis2_placement_3d;
END_ENTITY;


ENTITY directionally_explicit_element_representation
	SUBTYPE OF (element_representation);
	model_ref : fea_model;
	systems_and_freedoms : LIST [2:2] OF system_and_freedom;
	coefficient : directionally_explicit_element_coefficient;
UNIQUE
	UR1 : model_ref, SELF\representation.name;
WHERE
	FU1 : required_1d_nodes (
        SELF\element_representation.node_list,
        linear);
END_ENTITY;


ENTITY distribution_view_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	discretised_model : discretised_distribution_model_select;
	idealised_distribution : idealised_distribution_select;
END_ENTITY;


ENTITY div_expression
	SUBTYPE OF (binary_numeric_expression);
END_ENTITY;


ENTITY document;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	kind : document_type;
INVERSE
	representation_types: SET [0:?] OF document_representation_type FOR represented_document;
END_ENTITY;


ENTITY document_file
	SUBTYPE OF (characterized_object, document);
WHERE
	WR1 : SELF\characterized_object.name = '';
	WR2 : NOT EXISTS(SELF\characterized_object.description);
	WR3 : SIZEOF(QUERY(drt <* SELF\document.representation_types | drt.name IN ['digital', 'physical'])) = 1;
END_ENTITY;


ENTITY document_identifier
	SUBTYPE OF (group);
UNIQUE
	UR1 : SELF\group.name, SELF\group.description;
END_ENTITY;


ENTITY document_identifier_assignment
	SUBTYPE OF (group_assignment);
	items : SET [1:?] OF document_identifier_assigned_item;
	SELF\group_assignment.assigned_group : document_identifier;
END_ENTITY;


ENTITY document_product_association;
	name : label;
	description : OPTIONAL text;
	relating_document : document;
	related_product : product_or_formation_or_definition;
END_ENTITY;


ENTITY document_product_equivalence
	SUBTYPE OF (document_product_association);
WHERE
	WR1 : SELF\document_product_association.name = 'equivalence';
	WR2 : NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT' IN TYPEOF(SELF\document_product_association.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document') AND (SIZEOF(QUERY(prpc <* USEDIN(SELF\document_product_association.related_product, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document')) = 1));
	WR3 : NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION_FORMATION' IN TYPEOF(SELF.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document version') AND (SIZEOF(QUERY(prpc <* USEDIN(SELF.related_product\product_definition_formation.of_product, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document')) = 1));
	WR4 : NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(SELF.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document definition') AND (SIZEOF(QUERY(prpc <* USEDIN(SELF\document_product_association.related_product\product_definition.formation.of_product, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document')) = 1));
END_ENTITY;


ENTITY document_reference
	ABSTRACT SUPERTYPE;
	assigned_document : document;
	source : label;
DERIVE
	role : object_role := get_role(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;


ENTITY document_relationship;
	name : label;
	description : OPTIONAL text;
	relating_document : document;
	related_document : document;
END_ENTITY;


ENTITY document_representation_type;
	name : label;
	represented_document : document;
END_ENTITY;


ENTITY document_type;
	product_data_type : label;
END_ENTITY;


ENTITY document_usage_constraint;
	source : document;
	subject_element : label;
	subject_element_value : text;
END_ENTITY;


ENTITY document_usage_constraint_assignment
	ABSTRACT SUPERTYPE;
	assigned_document_usage : document_usage_constraint;
	role : document_usage_role;
END_ENTITY;


ENTITY document_usage_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY;


ENTITY domain_property;
	domain : temporal_spatial_domain;
	property_type : general_property;
END_ENTITY;


ENTITY dose_equivalent_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DOSE_EQUIVALENT_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY dose_equivalent_unit
	SUBTYPE OF (derived_unit);
WHERE
	WR1 : derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.sievert);
END_ENTITY;


ENTITY double_offset_shelled_solid
	SUBTYPE OF (shelled_solid);
	thickness2 : length_measure;
WHERE
	WR1 : thickness2 <> 0;
	WR2 : SELF\shelled_solid.thickness <> thickness2;
END_ENTITY;


ENTITY draped_defined_transformation
	SUBTYPE OF (transformation_with_derived_angle);
END_ENTITY;


ENTITY draughting_annotation_occurrence
	SUBTYPE OF (annotation_occurrence);
WHERE
	WR1 : (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_CURVE_OCCURRENCE'
            IN TYPEOF (SELF))) OR
    (SIZEOF (QUERY (sty <* SELF.styles |
       NOT ((SIZEOF (sty.styles) = 1)
         AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE'
                 IN TYPEOF (sty.styles[1]))) )) = 0);
	WR2 : (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_FILL_AREA_OCCURRENCE'
            IN TYPEOF (SELF))) OR    (SIZEOF (QUERY (sty <* SELF.styles |
      NOT ((SIZEOF (sty.styles) = 1)
        AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FILL_AREA_STYLE'
                IN TYPEOF (sty.styles[1]))) )) = 0);
	WR3 : (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_FILL_AREA_OCCURRENCE'
            IN TYPEOF (SELF))) OR    (SIZEOF (QUERY (bound <*
                     SELF.item\annotation_fill_area.boundaries |
       NOT (SIZEOF (QUERY (si <*
                   USEDIN (bound, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                  'STYLED_ITEM.ITEM') |
         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
             'ANNOTATION_CURVE_OCCURRENCE' IN TYPEOF (si)))) > 0))) = 0);
	WR4 : (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_SYMBOL_OCCURRENCE'
            IN TYPEOF (SELF))) OR    (SIZEOF (QUERY (sty <* SELF.styles |
       NOT ((SIZEOF (sty.styles) = 1)           AND
            (SIZEOF (TYPEOF (sty.styles[1]) *
                ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SYMBOL_STYLE',
                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NULL_STYLE']) = 1)) )) = 0);
	WR5 : (NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_SYMBOL_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_SYMBOL'
             IN TYPEOF(SELF.item)))) OR
         (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                   'DRAUGHTING_SYMBOL_REPRESENTATION',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                  'DRAUGHTING_SUBFIGURE_REPRESENTATION'] *
          TYPEOF (SELF.item\mapped_item.mapping_source.
                  mapped_representation)) = 1);
	WR6 : (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
            IN TYPEOF (SELF))) OR
    (SIZEOF (QUERY (sty <* SELF.styles |
       NOT ((SIZEOF (sty.styles) = 1)
        AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TEXT_STYLE'
                IN TYPEOF (sty.styles[1]))) )) = 0);
	WR7 : (NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF))) OR
         (SIZEOF (TYPEOF(SELF.item) *
             ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_TEXT',
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TEXT_LITERAL']) = 1);
	WR8 : (NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_TEXT'
             IN TYPEOF (SELF.item)))) OR    (SIZEOF (QUERY (tl <*
                   SELF.item\composite_text.collected_text |
             NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TEXT_LITERAL' 
             IN TYPEOF (tl)) )) = 0);
	WR9 : (NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TEXT_LITERAL'
             IN TYPEOF (SELF.item)))) OR (SELF.item\text_literal.alignment 
             IN ['baseline left', 'baseline centre', 'baseline right']);
	WR10 : (NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_TEXT'
             IN TYPEOF (SELF.item)))) OR
         (SIZEOF (QUERY (tl <* QUERY (text <* SELF.
                  item\composite_text.collected_text
             |('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TEXT_LITERAL' IN TYPEOF(text))) |
          NOT (tl\text_literal.alignment IN
         ['baseline left', 'baseline centre', 'baseline right']) )) = 0);
	WR11 : NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(SELF)) AND
         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_TEXT'
             IN TYPEOF (SELF.item))) OR check_text_alignment(SELF.item);
	WR12 : NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(SELF)) AND
         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_TEXT'
             IN TYPEOF (SELF.item))) OR check_text_font(SELF.item);
	WR13 : (NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(SELF)) AND
         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_TEXT'
               IN TYPEOF (SELF.item)))) OR
         (SIZEOF (QUERY (tl <* QUERY (text <*
            SELF.item\composite_text.collected_text |
            ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TEXT_LITERAL' IN TYPEOF (text))) |
             NOT (SIZEOF (TYPEOF(tl) *
                  ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                   'TEXT_LITERAL_WITH_BLANKING_BOX',
                   'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                   'TEXT_LITERAL_WITH_ASSOCIATED_CURVES']) = 0) )) = 0);
	WR14 : (NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TEXT_LITERAL_WITH_ASSOCIATED_CURVES'
             IN TYPEOF (SELF.item)))) OR
    (SIZEOF (QUERY (crv <*
                   SELF.item\text_literal_with_associated_curves.
                   associated_curves |
      NOT (SIZEOF (QUERY (si <*  USEDIN (crv, 
             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM.ITEM') |
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_CURVE_OCCURRENCE'
            IN TYPEOF (si)) )) > 0) )) = 0);
	WR15 : (NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_TEXT_WITH_ASSOCIATED_CURVES'
             IN TYPEOF (SELF.item)))) OR
          (SIZEOF (QUERY (crv <*
                SELF.item\composite_text_with_associated_curves.
                associated_curves |
           NOT (SIZEOF (QUERY (si <*  USEDIN (crv,
                'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM.ITEM') |
               ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_CURVE_OCCURRENCE'
           IN TYPEOF (si)) )) > 0) )) = 0);
	WR16 : SIZEOF (QUERY (cs <* QUERY (sty <* SELF.styles |
      ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE' IN TYPEOF (sty.styles[1])))
      | NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE_WITH_UNIT'
        IN TYPEOF (cs.styles[1]\curve_style.curve_width)) AND
       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POSITIVE_LENGTH_MEASURE'
        IN TYPEOF (cs.styles[1]\curve_style.
        curve_width\measure_with_unit.value_component))))) = 0;
	WR17 : SIZEOF (QUERY (fas <* QUERY (sty <* SELF.styles |
      ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FILL_AREA_STYLE'
          IN TYPEOF (sty.styles[1]))) |
      NOT ((SIZEOF (QUERY (fs <* fas.styles[1]\fill_area_style.fill_styles
                    | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FILL_AREA_STYLE_TILES'
                       IN TYPEOF (fs)))) <= 1)
       AND (SIZEOF (QUERY (fst <* QUERY (fs <*
                           fas.styles[1]\fill_area_style.fill_styles |
              ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FILL_AREA_STYLE_TILES'
                  IN TYPEOF (fs))) |
                 NOT (SIZEOF (fst\fill_area_style_tiles.tiles) = 1)
           )) = 0))
    )) = 0;
	WR18 : SIZEOF (QUERY (fas <* QUERY (sty <* SELF.styles |
           ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FILL_AREA_STYLE' 
            IN TYPEOF (sty.styles[1]))) |
             NOT (SIZEOF (QUERY (fsh <* QUERY (fs <*
                          fas.styles[1]\fill_area_style.fill_styles |
             ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FILL_AREA_STYLE_HATCHING'
               IN TYPEOF (fs))) |
        NOT (fsh\fill_area_style_hatching.point_of_reference_hatch_line :=:
             fsh\fill_area_style_hatching.pattern_start)  )) = 0)  )) = 0;
	WR19 : SIZEOF (QUERY (ts <* QUERY (sty <* SELF.styles |
         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TEXT_STYLE' 
         IN TYPEOF(sty.styles[1]))) |
             NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                  'TEXT_STYLE_WITH_BOX_CHARACTERISTICS'
             IN TYPEOF (ts.styles[1])))) = 0;
	WR20 : SIZEOF (QUERY (ts <* QUERY (sty <* SELF.styles |
         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TEXT_STYLE_WITH_BOX_CHARACTERISTICS'
             IN TYPEOF (sty.styles[1]))) |
           NOT (SIZEOF (ts.styles[1]\text_style_with_box_characteristics.
                characteristics) = 4) )) = 0;
END_ENTITY;


ENTITY draughting_callout
	SUPERTYPE OF ((ONEOF (datum_feature_callout, datum_target_callout, dimension_curve_directed_callout, draughting_elements, geometrical_tolerance_callout, leader_directed_callout, projection_directed_callout, structured_dimension_callout) ANDOR surface_condition_callout))
	SUBTYPE OF (geometric_representation_item);
	contents : SET [1:?] OF draughting_callout_element;
WHERE
	WR1 : (SIZEOF (QUERY (l_1 <* SELF\draughting_callout.contents |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_CURVE' IN (TYPEOF(l_1)))) = 0) OR
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_DIRECTED_CALLOUT' IN (TYPEOF(SELF))) AND
        (SIZEOF (QUERY (l_1 <* SELF\draughting_callout.contents |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROJECTION_CURVE' IN (TYPEOF(l_1)))) = 0) OR
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROJECTION_DIRECTED_CALLOUT' IN (TYPEOF(SELF))) AND  
        (SIZEOF (QUERY (l_1 <* SELF\draughting_callout.contents |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIMENSION_CURVE' IN (TYPEOF(l_1)))) = 0) OR
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIMENSION_CURVE_DIRECTED_CALLOUT' IN (TYPEOF(SELF)));
END_ENTITY;


ENTITY draughting_callout_relationship;
	name : label;
	description : text;
	relating_draughting_callout : draughting_callout;
	related_draughting_callout : draughting_callout;
END_ENTITY;


ENTITY draughting_elements
	SUBTYPE OF (draughting_callout);
WHERE
	WR1 : SIZEOF (QUERY (l_c <* QUERY (con <* SELF.contents |
              ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_CURVE' IN TYPEOF(con))) |
              NOT (SIZEOF (QUERY (ldc <* USEDIN (l_c,
               'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DRAUGHTING_CALLOUT.CONTENTS') |
              ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_DIRECTED_CALLOUT'
              IN TYPEOF (ldc)))) <= 1)))=0;
	WR2 : NOT    ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIMENSION_CURVE_DIRECTED_CALLOUT'
              IN TYPEOF(SELF)) OR
              (SIZEOF (QUERY (con <* SELF.contents |
              ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROJECTION_CURVE' IN
               TYPEOF (con)))) <= 2);
	WR3 : SIZEOF (QUERY (rc <* USEDIN (SELF,
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAUGHTING_CALLOUT_' +
              'RELATIONSHIP.RELATING_DRAUGHTING_CALLOUT') |
              ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
               'DIMENSION_CALLOUT_RELATIONSHIP' IN TYPEOF (rc)) AND
              (rc.name = 'primary') )) <= 1;
	WR4 : SIZEOF (QUERY (rc <* USEDIN (SELF,
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAUGHTING_CALLOUT_' +
              'RELATIONSHIP.RELATING_DRAUGHTING_CALLOUT') |
               ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                'DIMENSION_CALLOUT_RELATIONSHIP' IN TYPEOF (rc)) AND
                (rc.name = 'secondary') )) <= 1;
	WR5 : SIZEOF (QUERY (sec <* QUERY (rc <* USEDIN (SELF,
               'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAUGHTING_CALLOUT_' +
               'RELATIONSHIP.RELATING_DRAUGHTING_CALLOUT') |
               ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                'DIMENSION_CALLOUT_RELATIONSHIP' IN TYPEOF (rc)) AND         
                (rc.name = 'secondary') ) |
         NOT (SIZEOF (QUERY (prim <* USEDIN (SELF,
               'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAUGHTING_CALLOUT_' +
               'RELATIONSHIP.RELATING_DRAUGHTING_CALLOUT') |
               ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                'DIMENSION_CALLOUT_RELATIONSHIP' IN TYPEOF (prim)) AND         
                (prim.name = 'primary') )) = 1))) = 0;
END_ENTITY;


ENTITY draughting_model
	SUBTYPE OF (representation);
	SELF\representation.items : SET [1:?] OF draughting_model_item_select;
UNIQUE
	UR1 : SELF\representation.name;
WHERE
	WR1 : SIZEOF (QUERY (mi <* QUERY (it <* SELF.items |
         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF(it))) |
         NOT (
           SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHAPE_REPRESENTATION',
                    'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAUGHTING_MODEL'] *
              TYPEOF (mi\mapped_item.mapping_source.
                      mapped_representation)) = 1
        ))) = 0;
	WR2 : SIZEOF (QUERY (smi <* QUERY (si <* QUERY (it <* SELF.items |
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM' IN TYPEOF(it))) |
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN
            TYPEOF(si\styled_item.item))) |
        (NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHAPE_REPRESENTATION' IN
                 TYPEOF(smi\styled_item.item\mapped_item.
                        mapping_source.mapped_representation))
            AND
             (SIZEOF (QUERY (sty <* smi\styled_item.styles |
               (NOT (SIZEOF (QUERY (psa <* sty.styles |
                       (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE' IN TYPEOF(psa))))) = 1
             )))) = 1)))
        )) = 0;
END_ENTITY;


ENTITY draughting_model_item_association
	SUBTYPE OF (item_identified_representation_usage);
	SELF\item_identified_representation_usage.definition : shape_definition;
	SELF\item_identified_representation_usage.identified_item : draughting_model_item_association_select;
	SELF\item_identified_representation_usage.used_representation : draughting_model;
END_ENTITY;


ENTITY draughting_pre_defined_colour
	SUBTYPE OF (pre_defined_colour);
WHERE
	WR1 : SELF.name IN
      ['red',
       'green',
       'blue',
       'yellow',
       'magenta',
       'cyan',
       'black',
       'white'];
END_ENTITY;


ENTITY draughting_pre_defined_curve_font
	SUBTYPE OF (pre_defined_curve_font);
WHERE
	WR1 : SELF.name IN
        ['continuous',
         'chain',
         'chain double dash',
         'dashed',
         'dotted'];
END_ENTITY;


ENTITY draughting_pre_defined_text_font
	SUBTYPE OF (pre_defined_text_font);
WHERE
	WR1 : SELF.name[1:8] = 'ISO 3098';
END_ENTITY;


ENTITY draughting_subfigure_representation
	SUBTYPE OF (symbol_representation);
	SELF\representation.items : SET [1:?] OF draughting_subfigure_representation_item;
WHERE
	WR1 : SIZEOF (QUERY (item <* SELF\representation.items |
         SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_OCCURRENCE',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAUGHTING_CALLOUT'] *
           TYPEOF (item)) = 1)) >= 1;
	WR2 : SIZEOF (QUERY (srm <* QUERY (rm <*
          USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                        'REPRESENTATION_MAP.MAPPED_REPRESENTATION') |
          ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SYMBOL_REPRESENTATION_MAP'
             IN TYPEOF(rm))) | 
            NOT (SIZEOF (QUERY (a_s <* QUERY (mi <* srm.map_usage |
            ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_SYMBOL' IN TYPEOF(mi)))
          | NOT (SIZEOF (QUERY (aso <*
            USEDIN (a_s, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                         'STYLED_ITEM.ITEM') |
          NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_SUBFIGURE_OCCURRENCE'
            IN TYPEOF(aso)))) = 0))) = 0))) > 0;
	WR3 : SIZEOF (SELF.context_of_items.representations_in_context) = 1;
END_ENTITY;


ENTITY draughting_symbol_representation
	SUBTYPE OF (symbol_representation);
	SELF\representation.items : SET [1:?] OF draughting_symbol_representation_item;
UNIQUE
	UR1 : SELF\representation.name;
WHERE
	WR1 : SIZEOF (QUERY (item <* SELF\representation.items |
         (SIZEOF (TYPEOF (item) *
            ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_CURVE_OCCURRENCE',
             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_SYMBOL_OCCURRENCE',
             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_FILL_AREA_OCCURRENCE',
             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE']) = 1)
       )) >= 1;
	WR2 : SIZEOF (QUERY (item <* SELF\representation.items |
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_SUBFIGURE_OCCURRENCE'
          IN TYPEOF (item))) = 0;
	WR3 : SIZEOF ( QUERY (rm <*
          USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                        'REPRESENTATION_MAP.MAPPED_REPRESENTATION') |
          NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SYMBOL_REPRESENTATION_MAP'
             IN TYPEOF(rm)))) = 0;
	WR4 : SIZEOF (SELF.context_of_items.representations_in_context) = 1;
END_ENTITY;


ENTITY draughting_text_literal_with_delineation
	SUBTYPE OF (text_literal_with_delineation);
WHERE
	WR1 : SELF.delineation IN ['underline', 'overline'];
END_ENTITY;


ENTITY draughting_title;
	items : SET [1:?] OF draughting_titled_item;
	language : label;
	contents : text;
END_ENTITY;


ENTITY drawing_definition;
	drawing_number : identifier;
	drawing_type : OPTIONAL label;
END_ENTITY;


ENTITY drawing_revision
	SUBTYPE OF (presentation_set);
	revision_identifier : identifier;
	drawing_identifier : drawing_definition;
	intended_scale : OPTIONAL text;
UNIQUE
	UR1 : revision_identifier, drawing_identifier;
END_ENTITY;


ENTITY drawing_revision_sequence;
	predecessor : drawing_revision;
	successor : drawing_revision;
WHERE
	WR1 : predecessor :<>: successor;
END_ENTITY;


ENTITY drawing_sheet_revision
	SUBTYPE OF (presentation_area);
	revision_identifier : identifier;
WHERE
	WR1 : SIZEOF( QUERY(item <* SELF\representation.items |
       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN (TYPEOF(item)))
       AND
       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAWING_SHEET_REVISION' IN
       (TYPEOF(item\mapped_item.mapping_source.mapped_representation)))))=0;
END_ENTITY;


ENTITY drawing_sheet_revision_sequence
	SUBTYPE OF (representation_relationship);
WHERE
	WR1 : SELF\representation_relationship.rep_1 :<>:                            
       SELF\representation_relationship.rep_2;
	WR2 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAWING_SHEET_REVISION'
       IN TYPEOF (SELF\representation_relationship.rep_1);
	WR3 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAWING_SHEET_REVISION'
       IN TYPEOF (SELF\representation_relationship.rep_2);
END_ENTITY;


ENTITY drawing_sheet_revision_usage
	SUBTYPE OF (area_in_set);
	sheet_number : identifier;
UNIQUE
	UR1 : sheet_number, SELF\area_in_set.in_set;
WHERE
	WR1 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAWING_SHEET_REVISION' IN 
                  TYPEOF(SELF\area_in_set.area)) 
              AND
              ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAWING_REVISION' 
               IN TYPEOF (SELF\area_in_set.in_set));
END_ENTITY;


ENTITY dummy_node
	SUBTYPE OF (node_representation);
END_ENTITY;


ENTITY edge
	SUPERTYPE OF (ONEOF (edge_curve, oriented_edge, subedge))
	SUBTYPE OF (topological_representation_item);
	edge_start : vertex;
	edge_end : vertex;
END_ENTITY;


ENTITY edge_based_wireframe_model
	SUBTYPE OF (geometric_representation_item);
	ebwm_boundary : SET [1:?] OF connected_edge_set;
END_ENTITY;


ENTITY edge_based_wireframe_shape_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 : SIZEOF ( 
QUERY ( it <* SELF.items| NOT ( SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_BASED_WIREFRAME_MODEL', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D' ] * TYPEOF (it)) = 1) )) = 0;
	WR2 : SIZEOF ( 
QUERY ( it <* SELF.items| ( SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_BASED_WIREFRAME_MODEL', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' ] * TYPEOF (it)) = 1) )) >= 1;
	WR3 : SIZEOF ( 
QUERY ( ebwm <* 
QUERY ( it <* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT ( SIZEOF ( 
QUERY ( edges <* eb.ces_edges| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_CURVE' IN TYPEOF (edges)) )) = 0) )) = 0) )) = 0;
	WR4 : SIZEOF ( 
QUERY ( ebwm <* 
QUERY ( it <* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT ( SIZEOF ( 
QUERY ( pline_edges <* 
QUERY ( edges <* eb.ces_edges| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN TYPEOF (edges\edge_curve.edge_geometry)) )| NOT ( SIZEOF (pline_edges\edge_curve.edge_geometry\polyline.points) > 2) )) = 0) )) = 0) )) = 0;
	WR5 : SIZEOF ( 
QUERY ( ebwm <* 
QUERY ( it <* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT ( SIZEOF ( 
QUERY ( edges <* eb.ces_edges| NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF (edges.edge_start)) AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF (edges.edge_end))) )) = 0) )) = 0) )) = 0;
	WR6 : SIZEOF ( 
QUERY ( ebwm <* 
QUERY ( it <* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT ( SIZEOF ( 
QUERY ( edges <* eb.ces_edges| NOT valid_wireframe_edge_curve(edges\edge_curve.edge_geometry) )) = 0) )) = 0) )) = 0;
	WR7 : SIZEOF ( 
QUERY ( ebwm <* 
QUERY ( it <* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT ( SIZEOF ( 
QUERY ( edges <* eb.ces_edges| NOT (valid_wireframe_vertex_point(edges.edge_start\vertex_point.vertex_geometry) AND valid_wireframe_vertex_point(edges.edge_end\vertex_point.vertex_geometry)) )) = 0) )) = 0) )) = 0;
	WR8 : SIZEOF ( 
QUERY ( mi <* 
QUERY ( it <* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
	WR9 : SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3;
END_ENTITY;


ENTITY edge_blended_solid
	ABSTRACT SUPERTYPE OF ((track_blended_solid ANDOR ONEOF (solid_with_constant_radius_edge_blend, solid_with_variable_radius_edge_blend, solid_with_chamfered_edges)))
	SUBTYPE OF (modified_solid);
	blended_edges : LIST [1:?] OF  UNIQUE edge_curve;
END_ENTITY;


ENTITY edge_curve
	SUBTYPE OF (edge, geometric_representation_item);
	edge_geometry : curve;
	same_sense : BOOLEAN;
END_ENTITY;


ENTITY edge_loop
	SUBTYPE OF (loop, path);
DERIVE
	ne : INTEGER := SIZEOF(SELF\path.edge_list);
WHERE
	WR1 : (SELF\path.edge_list[1].edge_start) :=:
        (SELF\path.edge_list[ne].edge_end);
END_ENTITY;


ENTITY effectivity
	SUPERTYPE OF (ONEOF (serial_numbered_effectivity, dated_effectivity, lot_effectivity, time_interval_based_effectivity));
	id : identifier;
DERIVE
	description : text := get_description_value(SELF);
	name : label := get_name_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
	WR2 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;


ENTITY effectivity_assignment
	ABSTRACT SUPERTYPE;
	assigned_effectivity : effectivity;
DERIVE
	role : object_role := get_role(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;


ENTITY effectivity_context_assignment
	ABSTRACT SUPERTYPE;
	assigned_effectivity_assignment : effectivity_assignment;
	role : effectivity_context_role;
END_ENTITY;


ENTITY effectivity_context_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY;


ENTITY effectivity_relationship;
	name : label;
	description : OPTIONAL text;
	related_effectivity : effectivity;
	relating_effectivity : effectivity;
END_ENTITY;


ENTITY electric_charge_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELECTRIC_CHARGE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY electric_charge_unit
	SUBTYPE OF (derived_unit);
WHERE
	WR1 : derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.coulomb);
END_ENTITY;


ENTITY electric_current_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELECTRIC_CURRENT_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY electric_current_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 1.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;


ENTITY electric_potential_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELECTRIC_POTENTIAL_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY electric_potential_unit
	SUBTYPE OF (derived_unit);
WHERE
	WR1 : derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.volt);
END_ENTITY;


ENTITY element_analysis_message
	SUBTYPE OF (analysis_message);
	element : element_representation;
END_ENTITY;


ENTITY element_definition
	SUBTYPE OF (shape_aspect);
END_ENTITY;


ENTITY element_descriptor
	SUPERTYPE OF (ONEOF (volume_3d_element_descriptor, axisymmetric_volume_2d_element_descriptor, plane_volume_2d_element_descriptor, surface_3d_element_descriptor, axisymmetric_surface_2d_element_descriptor, plane_surface_2d_element_descriptor, curve_3d_element_descriptor, axisymmetric_curve_2d_element_descriptor, plane_curve_2d_element_descriptor));
	topology_order : element_order;
	description : text;
END_ENTITY;


ENTITY element_geometric_relationship;
	element_ref : element_or_element_group;
	item : analysis_item_within_representation;
	aspect : element_aspect;
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(item.item);
	WR2 : consistent_geometric_reference (aspect, item.item);
	WR3 : consistent_element_or_group_reference (aspect, element_ref);
END_ENTITY;


ENTITY element_group
	SUBTYPE OF (fea_group);
	elements : SET [1:?] OF element_representation;
END_ENTITY;


ENTITY element_group_analysis_message
	SUBTYPE OF (analysis_message);
	group : element_group;
END_ENTITY;


ENTITY element_material;
	material_id : identifier;
	description : text;
	properties : SET [1:?] OF material_property_representation;
END_ENTITY;


ENTITY element_nodal_freedom_actions
	SUBTYPE OF (state_definition);
	element : model_or_control_element;
	nodal_action : LIST [1:?] OF element_nodal_freedom_terms;
END_ENTITY;


ENTITY element_nodal_freedom_terms;
	coordinate_system : fea_axis2_placement_3d;
	degrees_of_freedom : freedoms_list;
	values : LIST [1:?] OF measure_or_unspecified_value;
WHERE
	WR1 : SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (values);
END_ENTITY;


ENTITY element_representation
	SUPERTYPE OF (ONEOF (volume_3d_element_representation, axisymmetric_volume_2d_element_representation, plane_volume_2d_element_representation, surface_3d_element_representation, axisymmetric_surface_2d_element_representation, plane_surface_2d_element_representation, curve_3d_element_representation, axisymmetric_curve_2d_element_representation, plane_curve_2d_element_representation, point_element_representation, directionally_explicit_element_representation, explicit_element_representation, substructure_element_representation))
	SUBTYPE OF (representation);
	node_list : LIST [1:?] OF node_representation;
WHERE
	WR1 : SIZEOF (QUERY(item <* node_list |
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
              'GEOMETRIC_NODE' 
              IN TYPEOF (item))) = 0;
END_ENTITY;


ENTITY element_sequence;
	order_id : identifier;
	control_ref : control;
	purpose : text;
	elements : LIST [1:?] OF model_or_control_element;
UNIQUE
	UR1 : order_id, control_ref;
END_ENTITY;


ENTITY element_topological_relationship;
	aspect : element_aspect;
	element_ref : element_representation;
	item : analysis_item_within_representation;
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TOPOLOGICAL_REPRESENTATION_ITEM' IN TYPEOF (item.item);
	WR2 : consistent_topological_reference (aspect, item.item);
	WR3 : consistent_element_reference (aspect, element_ref);
END_ENTITY;


ENTITY elementary_brep_shape_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 : SIZEOF (QUERY (it <* SELF.items |
          NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP',
                'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACETED_BREP',
                'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM',
                'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D'] *
                   TYPEOF(it)) = 1))) = 0;
	WR2 : SIZEOF (QUERY (it <* SELF.items |
         SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP',
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'] * TYPEOF(it)) =1 )) > 0;
	WR3 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
            NOT (SIZEOF (QUERY(fcs <* csh.cfs_faces |
              NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_SURFACE' IN TYPEOF(fcs)))) = 0
                 ))) = 0
                   ))) = 0;
	WR4 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
            NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
              NOT(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELEMENTARY_SURFACE' IN
                   TYPEOF(fcs\face_surface.face_geometry))
             ))) = 0
                 ))) = 0
                   ))) = 0;
	WR5 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
             NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                  NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_CURVE' IN
            TYPEOF(oe.edge_element)))) = 0
                   ))) = 0
                 ))) = 0
               ))) = 0
             ))) = 0;
	WR6 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
             NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                 NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                   NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE',
                         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONIC',
                         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE'] *
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) = 1 )
               )) = 0
               ))) = 0
                 ))) = 0
                   ))) = 0
                    ))) = 0;
	WR7 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
             NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                 NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
            NOT(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF(oe.edge_start))
                AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN
                 TYPEOF(oe.edge_end))
            ))) = 0
              ))) = 0
               ))) = 0
                 ))) = 0
                   ))) = 0;
	WR8 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
             NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                   ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND
            (NOT (SIZEOF (oe\oriented_edge.edge_element\
                  edge_curve.edge_geometry\polyline.points) >= 3))
               )) = 0
               ))) = 0
                 ))) = 0
                   ))) = 0
                    ))) = 0;
	WR9 : SIZEOF (QUERY (msb <* QUERY (it <* items |
          'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
          'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_CLOSED_SHELL' IN TYPEOF
              (msb\manifold_solid_brep.outer)))
             = 0;
	WR10 : SIZEOF (QUERY (brv <* QUERY (it <* items |
          'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BREP_WITH_VOIDS' IN TYPEOF(it)) |
          NOT (SIZEOF (QUERY (csh <* brv\brep_with_voids.voids |
           csh\oriented_closed_shell.orientation)) = 0))) = 0;
	WR11 : SIZEOF (QUERY (mi <*  QUERY (it <* items |
                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF(it)) |
          NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELEMENTARY_BREP_SHAPE_REPRESENTATION' IN
             TYPEOF(mi\mapped_item.mapping_source.
                           mapped_representation)))) = 0;
	WR12 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
            'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
            NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
              NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (vlp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_LOOP' IN TYPEOF(bnds.bound)) |
           NOT(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN
               TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND
                ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT' IN
                   TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.
                     loop_vertex\vertex_point.vertex_geometry))
            ))) = 0))) = 0))) = 0))) =0;
END_ENTITY;


ENTITY elementary_function
	SUBTYPE OF (maths_function, generic_literal);
	func_id : elementary_function_enumerators;
END_ENTITY;


ENTITY elementary_space
	SUBTYPE OF (maths_space, generic_literal);
	space_id : elementary_space_enumerators;
END_ENTITY;


ENTITY elementary_surface
	SUPERTYPE OF (ONEOF (plane, cylindrical_surface, conical_surface, spherical_surface, toroidal_surface))
	SUBTYPE OF (surface);
	position : axis2_placement_3d;
END_ENTITY;


ENTITY elements_bc
	SUBTYPE OF (mbna_bc);
	elements : LIST [0:?] OF vertex_defined_cell;
END_ENTITY;


ENTITY ellipse
	SUBTYPE OF (conic);
	semi_axis_1 : positive_length_measure;
	semi_axis_2 : positive_length_measure;
END_ENTITY;


ENTITY energy_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ENERGY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY energy_unit
	SUBTYPE OF (derived_unit);
WHERE
	WR1 : derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.joule);
END_ENTITY;


ENTITY entity_assertion
	SUBTYPE OF (fact_type);
END_ENTITY;


ENTITY enum_reference_prefix
	SUBTYPE OF (descriptive_representation_item);
END_ENTITY;


ENTITY environment;
	syntactic_representation : generic_variable;
	semantics : variable_semantics;
END_ENTITY;


ENTITY equals_expression
	SUBTYPE OF (binary_boolean_expression);
END_ENTITY;


ENTITY euler_angles;
	angles : ARRAY [1:3] OF plane_angle_measure;
END_ENTITY;


ENTITY evaluated_characteristic
	SUBTYPE OF (representation, representation_relationship);
UNIQUE
	UR1 : SELF\representation_relationship.rep_1, SELF\representation_relationship.rep_2;
WHERE
	WR1 : SELF\representation_relationship.rep_1 <> 
       SELF\representation_relationship.rep_2;
END_ENTITY;


ENTITY evaluated_degenerate_pcurve
	SUBTYPE OF (degenerate_pcurve);
	equivalent_point : cartesian_point;
END_ENTITY;


ENTITY evaluation_product_definition
	SUBTYPE OF (product_definition);
END_ENTITY;


ENTITY event_occurrence;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY;


ENTITY event_occurrence_assignment
	ABSTRACT SUPERTYPE;
	assigned_event_occurrence : event_occurrence;
	role : event_occurrence_role;
END_ENTITY;


ENTITY event_occurrence_relationship;
	name : label;
	description : OPTIONAL text;
	relating_event : event_occurrence;
	related_event : event_occurrence;
END_ENTITY;


ENTITY event_occurrence_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY;


ENTITY exclusive_product_concept_feature_category
	SUBTYPE OF (product_concept_feature_category);
END_ENTITY;


ENTITY executed_action
	SUBTYPE OF (action);
END_ENTITY;


ENTITY exp_function
	SUBTYPE OF (unary_function_call);
END_ENTITY;


ENTITY expanded_uncertainty
	SUBTYPE OF (standard_uncertainty);
	coverage_factor : REAL;
END_ENTITY;


ENTITY explicit_element_matrix;
	property_type : matrix_property_type;
	symmetry : matrix_symmetry;
	node_dof_list : LIST [1:?] OF LIST [1:?] OF degree_of_freedom;
	matrix_values : LIST [1:?] OF context_dependent_measure;
WHERE
	WR1 : SIZEOF (matrix_values) = number_of_terms (node_dof_list, symmetry);
END_ENTITY;


ENTITY explicit_element_representation
	SUBTYPE OF (element_representation);
	model_ref : fea_model;
	matrix : explicit_element_matrix;
UNIQUE
	UR1 : model_ref, SELF\representation.name;
WHERE
	WR1 : SIZEOF (QUERY(item <* SELF\representation.items |
              ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
              'FEA_AXIS2_PLACEMENT_3D') 
              IN TYPEOF (item))) = 1;
	WR2 : SIZEOF (matrix.node_dof_list) = 
        SIZEOF (SELF\element_representation.node_list);
END_ENTITY;


ENTITY explicit_procedural_geometric_representation_item_relationship
	SUBTYPE OF (explicit_procedural_representation_item_relationship);
	SELF\representation_item_relationship.related_representation_item : geometric_representation_item;
	SELF\representation_item_relationship.relating_representation_item : procedural_shape_representation_sequence;
WHERE
	WR1 : NOT (
    'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROCEDURAL_SHAPE_REPRESENTATION_SEQUENCE'
    IN TYPEOF(
      SELF\representation_item_relationship.related_representation_item));
END_ENTITY;


ENTITY explicit_procedural_representation_item_relationship
	SUBTYPE OF (representation_item_relationship);
	SELF\representation_item_relationship.relating_representation_item : procedural_representation_sequence;
WHERE
	WR1 : NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROCEDURAL_REPRESENTATION_SEQUENCE'
    IN TYPEOF(
      SELF\representation_item_relationship.related_representation_item));
	WR2 : SIZEOF(QUERY(q <* using_representations(
    SELF\representation_item_relationship.related_representation_item) |
    item_in_context(
      SELF\representation_item_relationship.relating_representation_item,
      q.context_of_items))) > 0;
END_ENTITY;


ENTITY explicit_procedural_representation_relationship
	SUBTYPE OF (representation_relationship);
	SELF\representation_relationship.rep_1 : procedural_representation;
WHERE
	WR1 : (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROCEDURAL_REPRESENTATION' 
    IN TYPEOF(SELF\representation_relationship.rep_2))) AND 
    (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VARIATIONAL_REPRESENTATION'
    IN TYPEOF(SELF\representation_relationship.rep_2)));
	WR2 : SELF\representation_relationship.rep_1.context_of_items :=:
    SELF\representation_relationship.rep_2.context_of_items;
END_ENTITY;


ENTITY explicit_procedural_shape_representation_relationship
	SUBTYPE OF (explicit_procedural_representation_relationship);
	SELF\representation_relationship.rep_1 : procedural_shape_representation;
	SELF\representation_relationship.rep_2 : shape_representation;
END_ENTITY;


ENTITY explicit_table_function
	ABSTRACT SUPERTYPE OF (ONEOF (listed_real_data, listed_integer_data, listed_logical_data, listed_string_data, listed_complex_number_data, listed_data, externally_listed_data, linearized_table_function, basic_sparse_matrix))
	SUBTYPE OF (maths_function);
	index_base : zero_or_one;
	shape : LIST [1:?] OF positive_integer;
END_ENTITY;


ENTITY explicit_unstructured_mesh
	SUBTYPE OF (unstructured_mesh);
	explicit_model : fea_model;
	cells : ARRAY [1:cell_count] OF  UNIQUE element_representation;
END_ENTITY;


ENTITY explicitly_enumerated_maths_space_context
	SUBTYPE OF (maths_space_context);
	members : SET [1:?] OF maths_value_context;
END_ENTITY;


ENTITY expression
	ABSTRACT SUPERTYPE OF (ONEOF (numeric_expression, boolean_expression, string_expression))
	SUBTYPE OF (generic_expression);
END_ENTITY;


ENTITY expression_conversion_based_unit
	SUBTYPE OF (context_dependent_unit, variable_semantics);
INVERSE
	associated_variable_environment: environment FOR semantics;
END_ENTITY;


ENTITY expression_denoted_function
	SUBTYPE OF (maths_function, unary_generic_expression);
DERIVE
	expr : generic_expression := SELF\unary_generic_expression.operand;
WHERE
	WR1 : (schema_prefix + 'FUNCTION_SPACE') IN TYPEOF (values_space_of(expr));
END_ENTITY;


ENTITY extended_tuple_space
	SUBTYPE OF (maths_space, generic_literal);
	base : product_space;
	extender : maths_space;
WHERE
	WR1 : expression_is_constant(base) AND
       expression_is_constant(extender);
	WR2 : no_cyclic_space_reference(SELF, []);
	WR3 : extender <> the_empty_space;
END_ENTITY;


ENTITY extension
	SUBTYPE OF (derived_shape_aspect);
WHERE
	WR1 : SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;


ENTITY extent
	SUBTYPE OF (characterized_object);
END_ENTITY;


ENTITY external_class_library
	SUBTYPE OF (external_source);
END_ENTITY;


ENTITY external_identification_assignment
	ABSTRACT SUPERTYPE
	SUBTYPE OF (identification_assignment);
	source : external_source;
END_ENTITY;


ENTITY external_source;
	source_id : source_item;
DERIVE
	description : text := get_description_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;


ENTITY external_source_relationship;
	name : label;
	description : OPTIONAL text;
	relating_source : external_source;
	related_source : external_source;
END_ENTITY;


ENTITY externally_defined_class
	SUBTYPE OF (class, externally_defined_item);
END_ENTITY;


ENTITY externally_defined_colour
	SUBTYPE OF (colour_specification, externally_defined_item);
END_ENTITY;


ENTITY externally_defined_context_dependent_unit
	SUBTYPE OF (context_dependent_unit, externally_defined_item);
END_ENTITY;


ENTITY externally_defined_conversion_based_unit
	SUBTYPE OF (conversion_based_unit, externally_defined_item);
END_ENTITY;


ENTITY externally_defined_currency
	SUBTYPE OF (currency, externally_defined_context_dependent_unit);
END_ENTITY;


ENTITY externally_defined_curve_font
	SUBTYPE OF (externally_defined_item);
END_ENTITY;


ENTITY externally_defined_dimension_definition
	SUBTYPE OF (dimensional_size, externally_defined_item);
WHERE
	WR1 : (SELF\externally_defined_item.item_id = 'external size dimension') AND (SELF\externally_defined_item.source.source_id = 'external size dimension specification');
	WR2 : 1 >= SIZEOF(QUERY ( adr <* USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.APPLIED_DOCUMENT_REFERENCE.ITEMS')| (adr.assigned_document.description = 'external size dimension specification') ));
END_ENTITY;


ENTITY externally_defined_general_property
	SUBTYPE OF (general_property, externally_defined_item);
END_ENTITY;


ENTITY externally_defined_hatch_style
	SUBTYPE OF (externally_defined_item, geometric_representation_item);
END_ENTITY;


ENTITY externally_defined_item;
	item_id : source_item;
	source : external_source;
END_ENTITY;


ENTITY externally_defined_item_relationship;
	name : label;
	description : OPTIONAL text;
	relating_item : externally_defined_item;
	related_item : externally_defined_item;
END_ENTITY;


ENTITY externally_defined_marker
	SUBTYPE OF (externally_defined_symbol, pre_defined_marker);
END_ENTITY;


ENTITY externally_defined_picture_representation_item
	SUBTYPE OF (picture_representation_item);
INVERSE
	source: applied_external_identification_assignment FOR items;
WHERE
	WR1 : NOT (SELF\representation_item.name IN pre_defined_picture_representation_types);
END_ENTITY;


ENTITY externally_defined_representation_item
	SUBTYPE OF (representation_item, externally_defined_item);
END_ENTITY;


ENTITY externally_defined_string
	SUBTYPE OF (externally_defined_representation_item);
END_ENTITY;


ENTITY externally_defined_symbol
	SUBTYPE OF (externally_defined_item);
END_ENTITY;


ENTITY externally_defined_terminator_symbol
	SUBTYPE OF (externally_defined_symbol);
END_ENTITY;


ENTITY externally_defined_text_font
	SUBTYPE OF (externally_defined_item);
END_ENTITY;


ENTITY externally_defined_tile
	SUBTYPE OF (externally_defined_item);
END_ENTITY;


ENTITY externally_defined_tile_style
	SUBTYPE OF (externally_defined_item, geometric_representation_item);
END_ENTITY;


ENTITY externally_listed_data
	SUBTYPE OF (explicit_table_function, generic_literal, externally_defined_item);
	value_range : maths_space;
WHERE
	WR1 : expression_is_constant(value_range);
END_ENTITY;


ENTITY extraction_of_structured_submesh
	SUBTYPE OF (extraction_of_submesh);
	lower_vertex : ARRAY [1:whole_indices] OF INTEGER;
	used_indices : ARRAY [1:part_indices] OF INTEGER;
	used_senses : ARRAY [1:part_indices] OF BOOLEAN;
DERIVE
	part_indices : INTEGER := part\mesh.index_count;
	whole_indices : INTEGER := whole\mesh.index_count;
WHERE
	WR1 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRUCTURED_MESH' IN  TYPEOF(
             SELF\extraction_of_submesh.whole));
	WR2 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRUCTURED_MESH' IN  TYPEOF(
             SELF\extraction_of_submesh.part));
END_ENTITY;


ENTITY extraction_of_submesh;
	whole : mesh;
	part : submesh;
END_ENTITY;


ENTITY extraction_of_submesh_by_cells
	SUBTYPE OF (extraction_of_submesh);
	cell_count : INTEGER;
	cells : ARRAY [1:cell_count] OF cell;
END_ENTITY;


ENTITY extraction_of_submesh_by_vertices
	SUBTYPE OF (extraction_of_submesh);
	vertex_count : INTEGER;
	vertices : ARRAY [1:vertex_count] OF vertex;
END_ENTITY;


ENTITY extruded_area_solid
	SUBTYPE OF (swept_area_solid);
	extruded_direction : direction;
	depth : positive_length_measure;
WHERE
	WR1 : dot_product(
        (SELF\swept_area_solid.swept_area.basis_surface\
        elementary_surface.position.p[3]), extruded_direction) <> 0.0;
END_ENTITY;


ENTITY extruded_face_solid
	SUBTYPE OF (swept_face_solid);
	extruded_direction : direction;
	depth : positive_length_measure;
WHERE
	WR1 : dot_product(
        (SELF\swept_face_solid.swept_face.face_geometry\
        elementary_surface.position.p[3]), extruded_direction) <> 0.0;
END_ENTITY;


ENTITY extruded_face_solid_with_draft_angle
	SUBTYPE OF (extruded_face_solid_with_trim_conditions);
	draft_angle : plane_angle_measure;
WHERE
	WR1 : draft_angle <> 0;
END_ENTITY;


ENTITY extruded_face_solid_with_multiple_draft_angles
	SUBTYPE OF (extruded_face_solid_with_trim_conditions);
	drafted_edges : LIST [2:?] OF SET [1:?] OF edge_curve;
	draft_angles : LIST [2:?] OF plane_angle_measure;
WHERE
	WR1 : SIZEOF(drafted_edges) = SIZEOF(draft_angles);
	WR2 : SIZEOF(QUERY(q <* draft_angles | q = 0)) = 0;
	WR3 : SIZEOF(QUERY(q <* drafted_edges | (SIZEOF(QUERY(r <* q | NOT 
         (SELF\swept_face_solid.swept_face IN 
          using_items(r,[])))) > 0))) = 0;
END_ENTITY;


ENTITY extruded_face_solid_with_trim_conditions
	SUPERTYPE OF (ONEOF (extruded_face_solid_with_draft_angle, extruded_face_solid_with_multiple_draft_angles))
	SUBTYPE OF (extruded_face_solid);
	first_trim_condition : trim_condition_select;
	second_trim_condition : trim_condition_select;
	first_trim_intent : trim_intent;
	second_trim_intent : trim_intent;
	first_offset : non_negative_length_measure;
	second_offset : non_negative_length_measure;
WHERE
	WR1 : NOT(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLANE_ANGLE_MEASURE' 
         IN TYPEOF(first_trim_condition)) OR
         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLANE_ANGLE_MEASURE' 
         IN TYPEOF(second_trim_condition)));
	WR2 : NOT ((('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE' 
         IN TYPEOF(first_trim_condition)) AND 
         ((first_trim_intent = trim_intent.offset) 
         OR (first_trim_intent = trim_intent.up_to_next))) OR  
         (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE' 
         IN TYPEOF(second_trim_condition)) AND 
         ((second_trim_intent = trim_intent.offset) 
         OR (second_trim_intent = trim_intent.up_to_next))));
	WR3 : NOT (((NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE' 
         IN TYPEOF(first_trim_condition))) AND 
         ((first_trim_intent = trim_intent.blind) 
         OR (first_trim_intent = trim_intent.through_all))) OR  
         ((NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE' 
         IN TYPEOF(second_trim_condition))) AND 
         ((second_trim_intent = trim_intent.blind) 
         OR (second_trim_intent = trim_intent.through_all))));
	WR4 : (((first_trim_intent = trim_intent.offset) 
           AND (first_offset > 0)) XOR
         ((first_trim_intent <> trim_intent.offset) 
           AND (first_offset = 0))) AND 
         (((second_trim_intent = trim_intent.offset) 
           AND (second_offset > 0)) XOR
         ((second_trim_intent <> trim_intent.offset) 
            AND (second_offset = 0)));
	WR5 : NOT((('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE' 
         IN TYPEOF(first_trim_condition)) AND
            ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE' 
         IN TYPEOF(second_trim_condition))) AND
         (first_trim_condition = second_trim_condition));
END_ENTITY;


ENTITY face
	SUPERTYPE OF (ONEOF (face_surface, subface, oriented_face))
	SUBTYPE OF (topological_representation_item);
	bounds : SET [1:?] OF face_bound;
WHERE
	WR1 : NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF))));
	WR2 : SIZEOF(QUERY(temp <* bounds | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_OUTER_BOUND' IN
                                               TYPEOF(temp))) <= 1;
END_ENTITY;


ENTITY face_based_surface_model
	SUBTYPE OF (geometric_representation_item);
	fbsm_faces : SET [1:?] OF connected_face_set;
END_ENTITY;


ENTITY face_bound
	SUBTYPE OF (topological_representation_item);
	bound : loop;
	orientation : BOOLEAN;
END_ENTITY;


ENTITY face_outer_bound
	SUBTYPE OF (face_bound);
END_ENTITY;


ENTITY face_surface
	SUBTYPE OF (face, geometric_representation_item);
	face_geometry : surface;
	same_sense : BOOLEAN;
WHERE
	WR1 : NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_SURFACE' IN TYPEOF(face_geometry));
END_ENTITY;


ENTITY faceted_brep
	SUBTYPE OF (manifold_solid_brep);
END_ENTITY;


ENTITY faceted_brep_shape_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 : SIZEOF ( 
QUERY ( it <* items| NOT ( SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACETED_BREP', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D' ] * TYPEOF (it)) = 1) )) = 0;
	WR2 : SIZEOF ( 
QUERY ( it <* items| ( SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACETED_BREP', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' ] * TYPEOF (it)) = 1) )) > 0;
	WR3 : SIZEOF ( 
QUERY ( fbrep <* 
QUERY ( it <* items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACETED_BREP' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( csh <* msb_shells(fbrep)| NOT ( SIZEOF ( 
QUERY ( fcs <* csh\connected_face_set.cfs_faces| NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_SURFACE' IN TYPEOF (fcs)) AND (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLANE' IN TYPEOF (fcs\face_surface.face_geometry)) AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT' IN TYPEOF (fcs\face_surface.face_geometry\elementary_surface.position.location)))) )) = 0) )) = 0) )) = 0;
	WR4 : SIZEOF ( 
QUERY ( fbrep <* 
QUERY ( it <* items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACETED_BREP' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( csh <* msb_shells(fbrep)| NOT ( SIZEOF ( 
QUERY ( fcs <* csh\connected_face_set.cfs_faces| NOT ( SIZEOF ( 
QUERY ( bnds <* fcs.bounds| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_OUTER_BOUND' IN TYPEOF (bnds)) )) = 1) )) = 0) )) = 0) )) = 0;
	WR5 : SIZEOF ( 
QUERY ( msb <* 
QUERY ( it <* items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF (it)) )| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_CLOSED_SHELL' IN TYPEOF (msb\manifold_solid_brep.outer)) )) = 0;
	WR6 : SIZEOF ( 
QUERY ( brv <* 
QUERY ( it <* items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BREP_WITH_VOIDS' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( csh <* brv\brep_with_voids.voids| csh\oriented_closed_shell.orientation )) = 0) )) = 0;
	WR7 : SIZEOF ( 
QUERY ( mi <* 
QUERY ( it <* items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACETED_BREP_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
END_ENTITY;


ENTITY fact_type
	SUBTYPE OF (property_definition);
END_ENTITY;


ENTITY fd_bc
	SUBTYPE OF (mbna_bc);
	SELF\mbna_bc.datasets : SET [0:?] OF fd_bc_dataset;
END_ENTITY;


ENTITY fd_bc_dataset
	SUBTYPE OF (mbna_bc_dataset);
	SELF\mbna_bc_dataset.the_type : fd_bc_type_simple;
END_ENTITY;


ENTITY fd_diffusion_equation
	SUBTYPE OF (fd_governing_equation);
	diffusion_model : fd_diffusion_model;
END_ENTITY;


ENTITY fd_diffusion_model;
	terms : ARRAY [1:diff] OF BOOLEAN;
	diff : INTEGER;
END_ENTITY;


ENTITY fd_governing_equation
	SUBTYPE OF (mbna_governing_equation);
	SELF\mbna_governing_equation.equation_type : fd_governing_equation_type;
END_ENTITY;


ENTITY fd_step
	SUBTYPE OF (mbna_step);
	SELF\mbna_step.equations : SET [0:?] OF flow_equation_set;
	SELF\mbna_step.zones : LIST [0:?] OF fd_zone;
END_ENTITY;


ENTITY fd_zone
	SUBTYPE OF (mbna_zone);
	SELF\mbna_zone.conditions : SET [0:?] OF fd_zone_bc;
	SELF\mbna_zone.equations : SET [0:?] OF flow_equation_set;
END_ENTITY;


ENTITY fd_zone_bc
	SUBTYPE OF (mbna_zone_bc);
	SELF\mbna_zone_bc.conditions : SET [0:?] OF fd_bc;
END_ENTITY;


ENTITY fea_area_density
	SUBTYPE OF (fea_material_property_representation_item);
	fea_constant : scalar;
END_ENTITY;


ENTITY fea_axis2_placement_2d
	SUBTYPE OF (axis2_placement_2d);
	system_type : coordinate_system_type;
	description : text;
END_ENTITY;


ENTITY fea_axis2_placement_3d
	SUBTYPE OF (axis2_placement_3d);
	system_type : coordinate_system_type;
	description : text;
END_ENTITY;


ENTITY fea_beam_section_idealisation_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	idealised : general_property;
	idealising : curve_element_section_definition;
END_ENTITY;


ENTITY fea_curve_section_geometric_relationship;
	section_ref : curve_element_section_definition;
	item : analysis_item_within_representation;
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(item.item);
END_ENTITY;


ENTITY fea_group
	SUPERTYPE OF (ONEOF (element_group, node_group))
	SUBTYPE OF (group);
	model_ref : fea_model;
END_ENTITY;


ENTITY fea_group_relation
	SUBTYPE OF (group_relationship);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FEA_GROUP'
        IN TYPEOF (SELF\group_relationship.relating_group);
	WR2 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FEA_GROUP'
        IN TYPEOF (SELF\group_relationship.related_group);
END_ENTITY;


ENTITY fea_linear_elasticity
	SUBTYPE OF (fea_material_property_representation_item);
	fea_constants : symmetric_tensor4_3d;
END_ENTITY;


ENTITY fea_mass_density
	SUBTYPE OF (fea_material_property_representation_item);
	fea_constant : scalar;
END_ENTITY;


ENTITY fea_material_property_geometric_relationship;
	material_ref : fea_material_property_representation;
	item : analysis_item_within_representation;
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(item.item);
END_ENTITY;


ENTITY fea_material_property_representation
	SUBTYPE OF (material_property_representation);
WHERE
	WR1 : SIZEOF (QUERY (item <* 
       SELF\property_definition_representation.used_representation.items |
         SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_MASS_DENSITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_AREA_DENSITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_MOISTURE_ABSORPTION',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_SHELL_MEMBRANE_STIFFNESS',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_SHELL_BENDING_STIFFNESS',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_SHELL_MEMBRANE_BENDING_COUPLING_STIFFNESS',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_SHELL_SHEAR_STIFFNESS'] * TYPEOF (item)
                  ) = 1
       )) = 1;
	WR2 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MATERIAL_PROPERTY' IN 
       TYPEOF (SELF\property_definition_representation.definition);
END_ENTITY;


ENTITY fea_material_property_representation_item
	SUPERTYPE OF (ONEOF (fea_linear_elasticity, fea_mass_density, fea_area_density, fea_tangential_coefficient_of_linear_thermal_expansion, fea_secant_coefficient_of_linear_thermal_expansion, fea_moisture_absorption, fea_shell_membrane_stiffness, fea_shell_bending_stiffness, fea_shell_membrane_bending_coupling_stiffness, fea_shell_shear_stiffness))
	SUBTYPE OF (representation_item);
END_ENTITY;


ENTITY fea_model
	SUPERTYPE OF (ONEOF (fea_model_2d, fea_model_3d))
	SUBTYPE OF (representation);
	creating_software : text;
	intended_analysis_code : SET [1:?] OF text;
	analysis_type : text;
UNIQUE
	UR1 : SELF\representation.name;
END_ENTITY;


ENTITY fea_model_2d
	SUBTYPE OF (fea_model);
	type_of_2d_analysis : axi_or_plane;
WHERE
	WR1 : SELF\representation.context_of_items\
       geometric_representation_context.coordinate_space_dimension = 2;
END_ENTITY;


ENTITY fea_model_3d
	SUBTYPE OF (fea_model);
WHERE
	WR1 : SELF\representation.context_of_items\
       geometric_representation_context.coordinate_space_dimension = 3;
END_ENTITY;


ENTITY fea_model_definition
	SUBTYPE OF (shape_aspect);
END_ENTITY;


ENTITY fea_model_topological_relationship;
	item : analysis_item_within_representation;
	model_ref : fea_model;
WHERE
	WR1 : 'TOPOLOGICAL_DEFINITION_AND_MESH_SCHEMA.MESH' IN TYPEOF (item.item);
END_ENTITY;


ENTITY fea_moisture_absorption
	SUBTYPE OF (fea_material_property_representation_item);
	fea_constants : symmetric_tensor2_3d;
END_ENTITY;


ENTITY fea_parametric_point
	SUBTYPE OF (point);
	coordinates : LIST [1:3] OF parameter_value;
WHERE
	WR1 : valid_parametric_coordinate (coordinates);
	WR2 : SIZEOF (TYPEOF (SELF) *
         ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT',
          'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_CURVE',
          'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_SURFACE',
          'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DEGENERATE_PCURVE',
          'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_REPLICA',
          'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SPHERICAL_POINT',
          'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CYLINDRICAL_POINT'])
         = 0;
END_ENTITY;


ENTITY fea_representation_item
	SUPERTYPE OF (ONEOF (arbitrary_volume_3d_element_coordinate_system, parametric_volume_3d_element_coordinate_system, arbitrary_volume_2d_element_coordinate_system, parametric_volume_2d_element_coordinate_system, aligned_surface_3d_element_coordinate_system, parametric_surface_3d_element_coordinate_system, constant_surface_3d_element_coordinate_system, aligned_surface_2d_element_coordinate_system, parametric_surface_2d_element_coordinate_system, aligned_curve_3d_element_coordinate_system, parametric_curve_3d_element_coordinate_system, parametric_curve_3d_element_coordinate_direction, curve_2d_element_coordinate_system, directionally_explicit_element_coordinate_system_arbitrary, directionally_explicit_element_coordinate_system_aligned))
	SUBTYPE OF (representation_item);
END_ENTITY;


ENTITY fea_secant_coefficient_of_linear_thermal_expansion
	SUBTYPE OF (fea_material_property_representation_item);
	fea_constants : symmetric_tensor2_3d;
	reference_temperature : thermodynamic_temperature_measure;
END_ENTITY;


ENTITY fea_shell_bending_stiffness
	SUBTYPE OF (fea_material_property_representation_item);
	fea_constants : symmetric_tensor4_2d;
END_ENTITY;


ENTITY fea_shell_membrane_bending_coupling_stiffness
	SUBTYPE OF (fea_material_property_representation_item);
	fea_constants : symmetric_tensor4_2d;
END_ENTITY;


ENTITY fea_shell_membrane_stiffness
	SUBTYPE OF (fea_material_property_representation_item);
	fea_constants : symmetric_tensor4_2d;
END_ENTITY;


ENTITY fea_shell_section_distribution_idealisation_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	idealised : property_definition;
	idealising : surface_section_field;
END_ENTITY;


ENTITY fea_shell_section_idealisation_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	idealised : general_property;
	idealising : surface_section;
END_ENTITY;


ENTITY fea_shell_shear_stiffness
	SUBTYPE OF (fea_material_property_representation_item);
	fea_constants : symmetric_tensor2_2d;
END_ENTITY;


ENTITY fea_surface_section_geometric_relationship;
	section_ref : surface_section;
	item : analysis_item_within_representation;
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(item.item);
END_ENTITY;


ENTITY fea_tangential_coefficient_of_linear_thermal_expansion
	SUBTYPE OF (fea_material_property_representation_item);
	fea_constants : symmetric_tensor2_3d;
END_ENTITY;


ENTITY field_variable_definition
	SUPERTYPE OF (ONEOF (field_variable_element_definition, field_variable_element_group_value, field_variable_whole_model_value, field_variable_node_definition))
	SUBTYPE OF (state_definition);
END_ENTITY;


ENTITY field_variable_element_definition
	SUPERTYPE OF (ONEOF (volume_3d_element_field_variable_definition, volume_2d_element_field_variable_definition, surface_3d_element_field_variable_definition, surface_2d_element_field_variable_definition, curve_3d_element_field_variable_definition, curve_2d_element_field_variable_definition))
	SUBTYPE OF (field_variable_definition);
END_ENTITY;


ENTITY field_variable_element_group_value
	SUBTYPE OF (field_variable_definition);
	group : element_group;
	simple_value : field_value;
	variable : volume_aggregated_variable;
	coordinate_system : OPTIONAL fea_axis2_placement_3d;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY field_variable_node_definition
	SUPERTYPE OF (ONEOF (volume_3d_node_field_variable_definition, volume_2d_node_field_variable_definition, surface_3d_node_field_variable_definition, surface_2d_node_field_variable_definition, curve_3d_node_field_variable_definition, curve_2d_node_field_variable_definition))
	SUBTYPE OF (field_variable_definition);
	node : node_output_reference;
	group : OPTIONAL element_group;
END_ENTITY;


ENTITY field_variable_whole_model_value
	SUBTYPE OF (field_variable_definition);
	simple_value : field_value;
	variable : volume_aggregated_variable;
	coordinate_system : OPTIONAL fea_axis2_placement_3d;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY fill_area_style
	SUBTYPE OF (founded_item);
	name : label;
	fill_styles : SET [1:?] OF fill_style_select;
WHERE
	WR1 : SIZEOF(QUERY(fill_style <* SELF.fill_styles |
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
         'FILL_AREA_STYLE_COLOUR' IN
         TYPEOF(fill_style)
         )) <= 1;
END_ENTITY;


ENTITY fill_area_style_colour;
	name : label;
	fill_colour : colour;
END_ENTITY;


ENTITY fill_area_style_hatching
	SUBTYPE OF (geometric_representation_item);
	hatch_line_appearance : curve_style;
	start_of_next_hatch_line : one_direction_repeat_factor;
	point_of_reference_hatch_line : cartesian_point;
	pattern_start : cartesian_point;
	hatch_line_angle : plane_angle_measure;
END_ENTITY;


ENTITY fill_area_style_tile_coloured_region
	SUBTYPE OF (geometric_representation_item);
	closed_curve : curve_or_annotation_curve_occurrence;
	region_colour : colour;
WHERE
	WR1 : (NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE' IN TYPEOF (closed_curve))) OR 
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CIRCLE' IN TYPEOF (closed_curve)) OR 
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELLIPSE' IN TYPEOF (closed_curve)) OR 
        ( ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE' IN TYPEOF (closed_curve)) 
             AND (closed_curve\b_spline_curve.closed_curve = TRUE) ) OR 
        ( ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_CURVE' IN TYPEOF (closed_curve)) 
             AND (closed_curve\composite_curve.closed_curve = TRUE) ) OR 
        ( ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN TYPEOF (closed_curve)) 
             AND (closed_curve\polyline.points[LOINDEX(closed_curve\polyline.points)] = 
                  closed_curve\polyline.points[HIINDEX(closed_curve\polyline.points)]) );
END_ENTITY;


ENTITY fill_area_style_tile_curve_with_style
	SUBTYPE OF (geometric_representation_item);
	styled_curve : annotation_curve_occurrence;
END_ENTITY;


ENTITY fill_area_style_tile_symbol_with_style
	SUBTYPE OF (geometric_representation_item);
	symbol : annotation_symbol_occurrence;
END_ENTITY;


ENTITY fill_area_style_tiles
	SUBTYPE OF (geometric_representation_item);
	tiling_pattern : two_direction_repeat_factor;
	tiles : SET [1:?] OF fill_area_style_tile_shape_select;
	tiling_scale : positive_ratio_measure;
END_ENTITY;


ENTITY finite_function
	SUBTYPE OF (maths_function, generic_literal);
	pairs : SET [1:?] OF LIST [2:2] OF maths_value;
WHERE
	WR1 : VALUE_UNIQUE(list_selected_components(pairs, 1));
END_ENTITY;


ENTITY finite_integer_interval
	SUBTYPE OF (maths_space, generic_literal);
	min : INTEGER;
	max : INTEGER;
DERIVE
	size : positive_integer := max - min + 1;
WHERE
	WR1 : min <= max;
END_ENTITY;


ENTITY finite_real_interval
	SUBTYPE OF (maths_space, generic_literal);
	min : REAL;
	min_closure : open_closed;
	max : REAL;
	max_closure : open_closed;
WHERE
	WR1 : min < max;
END_ENTITY;


ENTITY finite_space
	SUBTYPE OF (maths_space, generic_literal);
	members : SET [0:?] OF maths_value;
WHERE
	WR1 : VALUE_UNIQUE(members);
	WR2 : SIZEOF (QUERY (expr <* QUERY (member <* members |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GENERIC_EXPRESSION' IN TYPEOF (member))
       | NOT expression_is_constant(expr))) = 0;
	WR3 : no_cyclic_space_reference(SELF, []);
END_ENTITY;


ENTITY flat_pattern_ply_representation_relationship
	SUBTYPE OF (shape_representation_relationship);
WHERE
	WR1 : 'STRUCTURAL_ANALYSIS_DESIGN.SHAPE_REPRESENTATION' IN
        (TYPEOF (SELF\representation_relationship.rep_1) *
         TYPEOF (SELF\representation_relationship.rep_2));
	WR2 : SELF\representation_relationship.rep_1.
        context_of_items\geometric_representation_context.
        coordinate_space_dimension = 3;
END_ENTITY;


ENTITY flatness_tolerance
	SUBTYPE OF (geometric_tolerance);
WHERE
	WR1 : NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF));
END_ENTITY;


ENTITY flow_equation_set
	SUBTYPE OF (mbna_equation_set);
	fd_models : SET [0:?] OF fd_behaviour_models;
	SELF\mbna_equation_set.equations : fd_governing_equation;
END_ENTITY;


ENTITY force_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FORCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY force_unit
	SUBTYPE OF (derived_unit);
WHERE
	WR1 : derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.newton);
END_ENTITY;


ENTITY format_function
	SUBTYPE OF (string_expression, binary_generic_expression);
DERIVE
	format_string : generic_expression := SELF\binary_generic_expression.operands[2];
	value_to_format : generic_expression := SELF\binary_generic_expression.operands[1];
WHERE
	WR1 : (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NUMERIC_EXPRESSION') 
					IN TYPEOF(value_to_format)) 
			AND (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRING_EXPRESSION') 
					IN TYPEOF(format_string));
END_ENTITY;


ENTITY forward_chaining_rule
	SUBTYPE OF (rule_definition);
END_ENTITY;


ENTITY forward_chaining_rule_premise
	SUBTYPE OF (property_definition, property_definition_representation, representation);
END_ENTITY;


ENTITY founded_item;
DERIVE
	users : SET [0:?] OF founded_item_select := using_items(SELF,[]);
WHERE
	WR1 : SIZEOF(users) > 0;
	WR2 : NOT(SELF IN users);
END_ENTITY;


ENTITY free_variable_semantics
	SUBTYPE OF (variable_semantics);
END_ENTITY;


ENTITY freedom_and_coefficient;
	freedom : degree_of_freedom;
	a : measure_or_unspecified_value;
END_ENTITY;


ENTITY freedoms_list;
	freedoms : LIST [1:?] OF degree_of_freedom;
END_ENTITY;


ENTITY frequency_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FREQUENCY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY frequency_unit
	SUBTYPE OF (derived_unit);
WHERE
	WR1 : derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.hertz);
END_ENTITY;


ENTITY func
	SUBTYPE OF (compound_representation_item);
END_ENTITY;


ENTITY function_application
	SUBTYPE OF (multiple_arity_generic_expression);
	func : maths_function_select;
	arguments : LIST [1:?] OF maths_expression;
DERIVE
	SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF generic_expression := [convert_to_maths_function(func)] + convert_to_operands(arguments);
WHERE
	WR1 : function_applicability(func, arguments);
END_ENTITY;


ENTITY function_space
	SUBTYPE OF (maths_space, generic_literal);
	domain_constraint : space_constraint_type;
	domain_argument : maths_space;
	range_constraint : space_constraint_type;
	range_argument : maths_space;
WHERE
	WR1 : expression_is_constant(domain_argument) AND
       expression_is_constant(range_argument);
	WR2 : (domain_argument <> the_empty_space) AND
       (range_argument <> the_empty_space);
	WR3 : (domain_constraint <> sc_member) OR NOT
       member_of(the_empty_space,domain_argument);
	WR4 : (range_constraint <> sc_member) OR NOT
       member_of(the_empty_space,range_argument);
	WR5 : NOT (any_space_satisfies(domain_constraint,domain_argument) AND
       any_space_satisfies(range_constraint,range_argument));
END_ENTITY;


ENTITY functional_breakdown_context
	SUBTYPE OF (breakdown_context);
END_ENTITY;


ENTITY functional_element_usage
	SUBTYPE OF (breakdown_element_usage);
END_ENTITY;


ENTITY functionally_defined_transformation;
	name : label;
	description : OPTIONAL text;
END_ENTITY;


ENTITY gas_model
	SUBTYPE OF (mbna_behaviour_model);
	model_type : gas_model_type;
END_ENTITY;


ENTITY general_linear_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	sum_index : one_or_two;
	SELF\unary_generic_expression.operand : maths_function;
DERIVE
	mat : maths_function := SELF\unary_generic_expression.operand;
WHERE
	WR1 : function_is_2d_table(mat);
	WR2 : (space_dimension(mat.range) = 1) AND
       subspace_of_es(factor1(mat.range),es_numbers);
END_ENTITY;


ENTITY general_material_property
	SUBTYPE OF (general_property);
WHERE
	WR1 : SIZEOF( QUERY( gpa <* USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GENERAL_PROPERTY_ASSOCIATION.BASE_DEFINITION') | 
        NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MATERIAL_PROPERTY' IN TYPEOF(gpa.derived_definition)) )) = 0;
END_ENTITY;


ENTITY general_property;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY;


ENTITY general_property_association;
	name : label;
	description : OPTIONAL text;
	base_definition : general_property;
	derived_definition : derived_property_select;
WHERE
	WR1 : SIZEOF(USEDIN(derived_definition, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'GENERAL_PROPERTY_ASSOCIATION.' + 'DERIVED_DEFINITION')) = 1;
	WR2 : derived_definition.name = base_definition.name;
END_ENTITY;


ENTITY general_property_relationship;
	name : label;
	description : OPTIONAL text;
	relating_property : general_property;
	related_property : general_property;
END_ENTITY;


ENTITY generic_character_glyph_symbol
	ABSTRACT SUPERTYPE
	SUBTYPE OF (symbol_representation);
END_ENTITY;


ENTITY generic_expression
	ABSTRACT SUPERTYPE OF (ONEOF (simple_generic_expression, unary_generic_expression, binary_generic_expression, multiple_arity_generic_expression));
WHERE
	WR1 : is_acyclic(SELF);
END_ENTITY;


ENTITY generic_literal
	ABSTRACT SUPERTYPE
	SUBTYPE OF (simple_generic_expression);
END_ENTITY;


ENTITY generic_variable
	ABSTRACT SUPERTYPE
	SUBTYPE OF (simple_generic_expression);
INVERSE
	interpretation: environment FOR syntactic_representation;
END_ENTITY;


ENTITY geometric_alignment
	SUBTYPE OF (derived_shape_aspect);
WHERE
	WR1 : SIZEOF (SELF\derived_shape_aspect.deriving_relationships)> 1;
END_ENTITY;


ENTITY geometric_curve_set
	SUBTYPE OF (geometric_set);
WHERE
	WR1 : SIZEOF(QUERY(temp <* SELF\geometric_set.elements |
                            'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE' IN TYPEOF(temp))) = 0;
END_ENTITY;


ENTITY geometric_intersection
	SUBTYPE OF (derived_shape_aspect);
WHERE
	WR1 : SIZEOF (SELF\derived_shape_aspect.deriving_relationships)> 1;
END_ENTITY;


ENTITY geometric_item_specific_usage
	SUBTYPE OF (item_identified_representation_usage);
	SELF\item_identified_representation_usage.definition : geometric_item_specific_usage_select;
	SELF\item_identified_representation_usage.identified_item : geometric_representation_item;
	SELF\item_identified_representation_usage.used_representation : shape_representation;
END_ENTITY;


ENTITY geometric_model_element_relationship
	SUBTYPE OF (geometric_representation_item, representation_item_relationship);
	SELF\representation_item_relationship.related_representation_item : geometric_representation_item;
	SELF\representation_item_relationship.relating_representation_item : geometric_representation_item;
UNIQUE
	UR1 : relating_representation_item, related_representation_item;
WHERE
	WR1 : SELF\representation_item_relationship.relating_representation_item :<>: 
        SELF\representation_item_relationship.related_representation_item;
END_ENTITY;


ENTITY geometric_node
	SUBTYPE OF (node_representation);
WHERE
	WR1 : SIZEOF (QUERY(item <* SELF\representation.items |
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT' 
              IN TYPEOF (item))) = 1;
END_ENTITY;


ENTITY geometric_representation_context
	SUBTYPE OF (representation_context);
	coordinate_space_dimension : dimension_count;
END_ENTITY;


ENTITY geometric_representation_item
	SUPERTYPE OF (ONEOF (point, direction, vector, placement, cartesian_transformation_operator, curve, surface, edge_curve, face_surface, poly_loop, vertex_point, solid_model, boolean_result, sphere, right_circular_cone, right_circular_cylinder, torus, block, right_angular_wedge, volume, half_space_solid, shell_based_surface_model, face_based_surface_model, shell_based_wireframe_model, edge_based_wireframe_model, geometric_set))
	SUBTYPE OF (representation_item);
DERIVE
	dim : dimension_count := dimension_of(SELF);
WHERE
	WR1 : SIZEOF (QUERY (using_rep <* using_representations (SELF) |
      NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' IN
      TYPEOF (using_rep.context_of_items)))) = 0;
END_ENTITY;


ENTITY geometric_set
	SUBTYPE OF (geometric_representation_item);
	elements : SET [1:?] OF geometric_set_select;
END_ENTITY;


ENTITY geometric_tolerance;
	name : label;
	description : text;
	magnitude : measure_with_unit;
	toleranced_shape_aspect : shape_aspect;
WHERE
	WR1 : ('NUMBER' IN TYPEOF
       (magnitude\measure_with_unit.value_component)) AND
       (magnitude\measure_with_unit.value_component >= 0.0);
END_ENTITY;


ENTITY geometric_tolerance_relationship;
	name : label;
	description : text;
	relating_geometric_tolerance : geometric_tolerance;
	related_geometric_tolerance : geometric_tolerance;
END_ENTITY;


ENTITY geometric_tolerance_with_datum_reference
	SUBTYPE OF (geometric_tolerance);
	datum_system : SET [1:?] OF datum_reference;
END_ENTITY;


ENTITY geometric_tolerance_with_defined_unit
	SUBTYPE OF (geometric_tolerance);
	unit_size : measure_with_unit;
WHERE
	WR1 : ('NUMBER' IN TYPEOF
       (unit_size\measure_with_unit.value_component)) AND
       (unit_size\measure_with_unit.value_component > 0.0);
END_ENTITY;


ENTITY geometrical_tolerance_callout
	SUBTYPE OF (draughting_callout);
END_ENTITY;


ENTITY geometrically_bounded_2d_wireframe_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 : SELF.context_of_items\geometric_representation_context.
            coordinate_space_dimension = 2;
	WR2 : SIZEOF (QUERY (item <* SELF.items |
         NOT (SIZEOF (TYPEOF (item) *
['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_CURVE_SET',          
'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_2D',
            'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM']) = 1)
       )) = 0;
	WR3 : SIZEOF (QUERY (item <* SELF.items |
         SIZEOF (TYPEOF (item) *          
['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_CURVE_SET',
            'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM']) = 1
       )) >= 1;
	WR4 : SIZEOF (QUERY (mi <* QUERY (item <* SELF.items |
     ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'
           IN TYPEOF (item))) |
         NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
              'GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION'
           IN TYPEOF
              (mi\mapped_item.mapping_source.mapped_representation))
       )) = 0;
	WR5 : SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |
     ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_CURVE_SET'
                IN TYPEOF (item))) |
         NOT (SIZEOF (QUERY (elem <* gcs\geometric_set.elements |
           NOT (SIZEOF (TYPEOF (elem) *
             ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE',
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CIRCLE',
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_CURVE',
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELLIPSE',
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_CURVE_2D',
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT',
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE',
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TRIMMED_CURVE']) =
               1)
         )) = 0)
       )) = 0;
	WR6 : SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |
     ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_CURVE_SET'
                IN TYPEOF (item))) |
         NOT (SIZEOF (QUERY (crv <* 
           QUERY (elem <* gcs\geometric_set.elements |
              ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE'
                   IN TYPEOF (elem))) |
           NOT (valid_basis_curve_in_2d_wireframe
              (crv))
         )) = 0)
       )) = 0;
	WR7 : SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |         
       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_CURVE_SET'
                IN TYPEOF (item))) |
         NOT (SIZEOF (QUERY (pnt <*
           QUERY (elem <* gcs\geometric_set.elements |
             ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT'
                  IN TYPEOF(elem))) |
             NOT (SIZEOF (TYPEOF (pnt) *
               ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT',
                'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_CURVE'])
          = 1)
         )) = 0)
       )) = 0;
END_ENTITY;


ENTITY geometrically_bounded_surface_shape_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 : SIZEOF(QUERY(it <* SELF.items | NOT (SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_SET', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1))) = 0;
	WR2 : SIZEOF(QUERY(it <* SELF.items | SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_SET', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'] * TYPEOF(it)) = 1)) > 0;
	WR3 : SIZEOF(QUERY(mi <* QUERY(it <* SELF.items | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF(it)) | NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)) AND (SIZEOF(QUERY(mr_it <* mi\mapped_item.mapping_source.mapped_representation.items | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_SET' IN TYPEOF(mr_it)))) > 0)))) = 0;
	WR4 : SIZEOF(QUERY(gs <* QUERY(it <* SELF.items | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_SET' IN TYPEOF(it)) | NOT (SIZEOF(QUERY(pnt <* QUERY(gsel <* gs\geometric_set.elements | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT' IN TYPEOF(gsel)) | NOT (gbsf_check_point(pnt)))) = 0))) = 0;
	WR5 : SIZEOF(QUERY(gs <* QUERY(it <* SELF.items | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_SET' IN TYPEOF(it)) | NOT (SIZEOF(QUERY(cv <* QUERY(gsel <* gs\geometric_set.elements | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE' IN TYPEOF(gsel)) | NOT (gbsf_check_curve(cv)))) = 0))) = 0;
	WR6 : SIZEOF(QUERY(gs <* QUERY(it <* SELF.items | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_SET' IN TYPEOF(it)) | NOT (SIZEOF(QUERY(sf <* QUERY(gsel <* gs\geometric_set.elements | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE' IN TYPEOF(gsel)) | NOT (gbsf_check_surface(sf)))) = 0))) = 0;
	WR7 : SIZEOF(QUERY(gs <* QUERY(it <* SELF.items | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_SET' IN TYPEOF(it)) | SIZEOF(QUERY(gsel <* gs\geometric_set.elements | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE' IN TYPEOF(gsel))) > 0)) > 0;
END_ENTITY;


ENTITY geometrically_bounded_wireframe_shape_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 : SIZEOF ( 
QUERY ( it <* SELF.items| NOT ( SIZEOF ( TYPEOF (it) * [ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_CURVE_SET', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' ]) = 1) )) = 0;
	WR2 : SIZEOF ( 
QUERY ( it <* SELF.items| ( SIZEOF ( TYPEOF (it) * [ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_CURVE_SET', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' ]) = 1) )) >= 1;
	WR3 : SIZEOF ( 
QUERY ( gcs <* 
QUERY ( it <* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( crv <* 
QUERY ( elem <* gcs\geometric_set.elements| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE' IN TYPEOF (elem)) )| NOT valid_geometrically_bounded_wf_curve(crv) )) = 0) )) = 0;
	WR4 : SIZEOF ( 
QUERY ( gcs <* 
QUERY ( it <* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( pnts <* 
QUERY ( elem <* gcs\geometric_set.elements| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT' IN TYPEOF (elem)) )| NOT valid_geometrically_bounded_wf_point(pnts) )) = 0) )) = 0;
	WR5 : SIZEOF ( 
QUERY ( gcs <* 
QUERY ( it <* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( cnc <* 
QUERY ( elem <* gcs\geometric_set.elements| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONIC' IN TYPEOF (elem)) )| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D' IN TYPEOF (cnc\conic.position)) )) = 0) )) = 0;
	WR6 : SIZEOF ( 
QUERY ( gcs <* 
QUERY ( it <* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( pline <* 
QUERY ( elem <* gcs\geometric_set.elements| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN TYPEOF (elem)) )| NOT ( SIZEOF (pline\polyline.points) > 2) )) = 0) )) = 0;
	WR7 : SIZEOF ( 
QUERY ( mi <* 
QUERY ( it <* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
END_ENTITY;


ENTITY geometry_reference;
	description : text;
	data : choose_geometry_location;
END_ENTITY;


ENTITY global_assignment
	SUBTYPE OF (representation_item_relationship);
END_ENTITY;


ENTITY global_uncertainty_assigned_context
	SUBTYPE OF (representation_context);
	uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY;


ENTITY global_unit_assigned_context
	SUBTYPE OF (representation_context);
	units : SET [1:?] OF unit;
END_ENTITY;


ENTITY grid_coordinates
	SUBTYPE OF (model_property_distribution);
	SELF\model_property_distribution.domain : model_product_domain_with_mesh;
	SELF\model_property_distribution.range : specified_general_property;
INVERSE
	data: SET [0:?] OF property_distribution_description FOR physical_function;
WHERE
	wr1 : is_coordinate_property(range);
END_ENTITY;


ENTITY grid_coordinates_with_rind
	SUBTYPE OF (grid_coordinates);
	rind_planes : rind;
END_ENTITY;


ENTITY ground_fact
	SUBTYPE OF (atomic_formula);
END_ENTITY;


ENTITY grounded_damper
	SUBTYPE OF (point_element_matrix);
	damping_coefficients : ARRAY [1:6] OF context_dependent_measure;
END_ENTITY;


ENTITY grounded_spring
	SUBTYPE OF (point_element_matrix);
	stiffness_coefficients : ARRAY [1:6] OF context_dependent_measure;
END_ENTITY;


ENTITY group;
	name : label;
	description : OPTIONAL text;
DERIVE
	id : identifier := get_id_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;


ENTITY group_assignment
	ABSTRACT SUPERTYPE;
	assigned_group : group;
DERIVE
	role : object_role := get_role(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;


ENTITY group_relationship;
	name : label;
	description : OPTIONAL text;
	relating_group : group;
	related_group : group;
END_ENTITY;


ENTITY half_space_solid
	SUBTYPE OF (geometric_representation_item);
	base_surface : surface;
	agreement_flag : BOOLEAN;
END_ENTITY;


ENTITY hardness_representation
	SUBTYPE OF (representation);
WHERE
	WR1 : ( {2<= SIZEOF ( SELF.items ) <=4} ) AND ( SIZEOF ( QUERY (
        i <* items | ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND (
        i.name IN [ 'measuring method' , 'measuring position' ] ) )
        ) + SIZEOF ( QUERY ( i <* items | ( SIZEOF (
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'MEASURE_REPRESENTATION_ITEM' ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'VALUE_RANGE']* TYPEOF ( i ) ) =1 )
        AND ( i.name IN ['depth' , 'hardness'] ) ) ) = SIZEOF (
        SELF.items ) );
	WR2 : SIZEOF ( QUERY ( i <* SELF.items | i.name =
        'measuring method' ) ) =1;
	WR3 : SIZEOF ( QUERY ( i <* SELF.items | i.name ='hardness' ) )
        =1;
	WR4 : SIZEOF ( QUERY ( i <* SELF.items | i.name =
        'measuring position' ) ) <=1;
	WR5 : SIZEOF ( QUERY ( i <* SELF.items | i.name ='depth' ) )
        <=1;
	WR6 : ( SIZEOF ( USEDIN ( SELF ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
        'USED_REPRESENTATION' ) ) =1 ) AND ( SIZEOF ( QUERY ( pdr
        <* USEDIN ( SELF ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
        'USED_REPRESENTATION' ) | SIZEOF ( QUERY ( gpa <* USEDIN (
        pdr. definition ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'GENERAL_PROPERTY_ASSOCIATION.'+
        'DERIVED_DEFINITION' ) | ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'GENERAL_PROPERTY' IN TYPEOF ( gpa. base_definition ) ) AND
        ( gpa. base_definition.name ='surface_condition' ) ) ) =1 )
        ) =1 );
END_ENTITY;


ENTITY hidden_element_over_riding_styled_item
	SUBTYPE OF (context_dependent_over_riding_styled_item);
	SELF\styled_item.item : camera_image;
	SELF\context_dependent_over_riding_styled_item.style_context : LIST [1:1] OF presentation_view;
INVERSE
	container: SET [1:?] OF presentation_view FOR items;
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CAMERA_MODEL_D3_WITH_HLHSR' IN TYPEOF
                (SELF.item\mapped_item.mapping_source.mapping_origin);
END_ENTITY;


ENTITY homogeneous_linear_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	sum_index : one_or_two;
	SELF\unary_generic_expression.operand : maths_function;
DERIVE
	mat : maths_function := SELF\unary_generic_expression.operand;
WHERE
	WR1 : function_is_2d_table(mat);
	WR2 : (space_dimension(mat.range) = 1) AND
       subspace_of_es(factor1(mat.range),es_numbers);
END_ENTITY;


ENTITY hyperbola
	SUBTYPE OF (conic);
	semi_axis : positive_length_measure;
	semi_imag_axis : positive_length_measure;
END_ENTITY;


ENTITY id_attribute;
	attribute_value : identifier;
	identified_item : id_attribute_select;
END_ENTITY;


ENTITY idealisation_relationship;
	id : identifier;
	name : label;
	description : text;
	idealised : product_definition;
	idealisation : temporal_spatial_domain;
END_ENTITY;


ENTITY identification_assignment
	ABSTRACT SUPERTYPE;
	assigned_id : identifier;
	role : identification_role;
END_ENTITY;


ENTITY identification_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY;


ENTITY illuminance_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ILLUMINANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY illuminance_unit
	SUBTYPE OF (derived_unit);
WHERE
	WR1 : derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.lux);
END_ENTITY;


ENTITY imported_curve_function
	SUBTYPE OF (maths_function, generic_literal);
	geometry : curve;
	parametric_domain : tuple_space;
WHERE
	WR1 : expression_is_constant(parametric_domain);
END_ENTITY;


ENTITY imported_point_function
	SUBTYPE OF (maths_function, generic_literal);
	geometry : point;
END_ENTITY;


ENTITY imported_surface_function
	SUBTYPE OF (maths_function, generic_literal);
	geometry : surface;
	parametric_domain : tuple_space;
WHERE
	WR1 : expression_is_constant(parametric_domain);
END_ENTITY;


ENTITY imported_volume_function
	SUBTYPE OF (maths_function, generic_literal);
	geometry : volume;
	parametric_domain : tuple_space;
WHERE
	WR1 : expression_is_constant(parametric_domain);
END_ENTITY;


ENTITY included_text_block
	SUBTYPE OF (mapped_item);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRUCTURED_TEXT_REPRESENTATION' IN TYPEOF(SELF\mapped_item.mapping_source.mapped_representation);
END_ENTITY;


ENTITY inclusion_product_concept_feature
	SUBTYPE OF (conditional_concept_feature);
WHERE
	WR1 : NOT ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'PACKAGE_PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( SELF ) );
	WR2 : SIZEOF (QUERY
									( cfr <* USEDIN 
											( SELF ,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP.RELATING_PRODUCT_CONCEPT_FEATURE' ) 
											| 
											'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF( cfr ) 
									) 
								) + 
				 SIZEOF(QUERY
				 					( cfr <* USEDIN 
				 							(SELF , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP.RELATED_PRODUCT_CONCEPT_FEATURE' ) 
				 							| 
											'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF(cfr)
									)
								)= 0;
	WR3 : SELF.condition.conditional_operator.name = 'implication';
END_ENTITY;


ENTITY index_expression
	SUBTYPE OF (string_expression, binary_generic_expression);
DERIVE
	index : generic_expression := SELF\binary_generic_expression.operands[2];
	operand : generic_expression := SELF\binary_generic_expression.operands[1];
WHERE
	WR1 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRING_EXPRESSION' 
			IN TYPEOF(operand))
		AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NUMERIC_EXPRESSION' 
			IN TYPEOF(index));
	WR2 : is_int_expr (index);
END_ENTITY;


ENTITY indexed_elements_bc
	SUBTYPE OF (mbna_bc);
	element_indices : indices_group;
END_ENTITY;


ENTITY indexed_points_bc
	SUBTYPE OF (mbna_bc);
	point_indices : indices_group;
END_ENTITY;


ENTITY indices_list;
	nindices : INTEGER;
	indices : LIST [1:?] OF ARRAY [1:nindices] OF INTEGER;
END_ENTITY;


ENTITY indices_range;
	nindices : INTEGER;
	start : ARRAY [1:nindices] OF INTEGER;
	finish : ARRAY [1:nindices] OF INTEGER;
END_ENTITY;


ENTITY indirectly_selected_elements
	SUBTYPE OF (user_selected_elements);
	indirectly_picked_items : SET [1:?] OF representation_item;
END_ENTITY;


ENTITY indirectly_selected_shape_elements
	SUBTYPE OF (indirectly_selected_elements, user_selected_shape_elements);
WHERE
	WR1 : SIZEOF(QUERY(q <*
    SELF\indirectly_selected_elements.indirectly_picked_items
    | NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHAPE_REPRESENTATION_ITEM'
    IN TYPEOF(q)))) = 0;
END_ENTITY;


ENTITY inductance_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.INDUCTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY inductance_unit
	SUBTYPE OF (derived_unit);
WHERE
	WR1 : derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.henry);
END_ENTITY;


ENTITY information_right
	SUBTYPE OF (action_method);
END_ENTITY;


ENTITY information_usage_right
	SUBTYPE OF (action_method);
END_ENTITY;


ENTITY instance_usage_context_assignment
	SUBTYPE OF (product_definition_context);
	items : SET [1:?] OF instance_usage_context_select;
END_ENTITY;


ENTITY instanced_feature
	SUBTYPE OF (shape_aspect, shape_feature_definition);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION' IN
         TYPEOF(SELF\shape_aspect.of_shape.definition);
	WR2 : SELF\shape_aspect.product_definitional;
END_ENTITY;


ENTITY int_literal
	SUBTYPE OF (literal_number);
	SELF\literal_number.the_value : INTEGER;
END_ENTITY;


ENTITY int_numeric_variable
	SUBTYPE OF (numeric_variable);
END_ENTITY;


ENTITY int_value_function
	SUBTYPE OF (value_function);
END_ENTITY;


ENTITY integer_defined_function
	ABSTRACT SUPERTYPE
	SUBTYPE OF (numeric_defined_function);
END_ENTITY;


ENTITY integer_interval_from_min
	SUBTYPE OF (maths_space, generic_literal);
	min : INTEGER;
END_ENTITY;


ENTITY integer_interval_to_max
	SUBTYPE OF (maths_space, generic_literal);
	max : INTEGER;
END_ENTITY;


ENTITY integer_representation_item
	SUBTYPE OF (representation_item, int_literal);
END_ENTITY;


ENTITY integer_tuple_literal
	SUBTYPE OF (generic_literal);
	lit_value : LIST [1:?] OF INTEGER;
END_ENTITY;


ENTITY intersection_curve
	SUBTYPE OF (surface_curve);
WHERE
	WR1 : SIZEOF(SELF\surface_curve.associated_geometry) = 2;
	WR2 : associated_surface(SELF\surface_curve.associated_geometry[1]) <>
             associated_surface(SELF\surface_curve.associated_geometry[2]);
END_ENTITY;


ENTITY interval_expression
	SUBTYPE OF (boolean_expression, multiple_arity_generic_expression);
DERIVE
	interval_high : generic_expression := SELF\multiple_arity_generic_expression.operands[3];
	interval_item : generic_expression := SELF\multiple_arity_generic_expression.operands[2];
	interval_low : generic_expression := SELF\multiple_arity_generic_expression.operands[1];
WHERE
	WR1 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EXPRESSION' 
				IN TYPEOF(interval_low))
		AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EXPRESSION' 
				IN TYPEOF(interval_item) )
		AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EXPRESSION' 
				IN TYPEOF(interval_high));
	WR2 : (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRING_EXPRESSION' 
				IN TYPEOF (SELF.interval_low)) 
			AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRING_EXPRESSION'  
				IN TYPEOF (SELF.interval_high)) 
			AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRING_EXPRESSION' 
				IN TYPEOF (SELF.interval_item))) 
		OR
		(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRING_EXPRESSION' 
				IN TYPEOF(SELF.interval_low)) 
			AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NUMERIC_EXPRESSION' 
				IN TYPEOF(SELF.interval_item)) 
			AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NUMERIC_EXPRESSION' 
				IN TYPEOF(SELF.interval_high)));
END_ENTITY;


ENTITY invisibility;
	invisible_items : SET [1:?] OF invisible_item;
END_ENTITY;


ENTITY iso4217_currency
	SUBTYPE OF (currency);
END_ENTITY;


ENTITY item_defined_transformation;
	name : label;
	description : OPTIONAL text;
	transform_item_1 : representation_item;
	transform_item_2 : representation_item;
END_ENTITY;


ENTITY item_identified_representation_usage;
	name : label;
	description : OPTIONAL text;
	definition : represented_definition;
	used_representation : representation;
	identified_item : representation_item;
WHERE
	WR1 : SELF.used_representation IN using_representations(SELF.identified_item);
END_ENTITY;


ENTITY known_source
	SUBTYPE OF (external_source, pre_defined_item);
END_ENTITY;


ENTITY laid_defined_transformation
	SUBTYPE OF (transformation_with_derived_angle);
END_ENTITY;


ENTITY laminate_table
	SUPERTYPE OF (ONEOF (part_laminate_table, zone_structural_makeup))
	SUBTYPE OF (product_definition);
END_ENTITY;


ENTITY language
	SUBTYPE OF (group);
WHERE
	WR1 : SELF\group.name <> '';
END_ENTITY;


ENTITY leader_curve
	SUBTYPE OF (annotation_curve_occurrence);
WHERE
	WR1 : SIZEOF( 
          QUERY(ldc <* USEDIN( SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                       'DRAUGHTING_CALLOUT.CONTENTS')
                   |   'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                       'LEADER_DIRECTED_CALLOUT'  IN TYPEOF(ldc))) >= 1;
END_ENTITY;


ENTITY leader_directed_callout
	SUBTYPE OF (draughting_callout);
WHERE
	WR1 : SIZEOF (QUERY (l_1 <* SELF\draughting_callout.contents |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_CURVE' IN (TYPEOF(l_1)))) >= 1;
	WR2 : SIZEOF(SELF\draughting_callout.contents) >=2;
END_ENTITY;


ENTITY leader_directed_dimension
	SUBTYPE OF (leader_directed_callout);
WHERE
	WR1 : SIZEOF (QUERY (con <* SELF.contents |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_CURVE' IN TYPEOF (con)))=1;
END_ENTITY;


ENTITY leader_terminator
	SUBTYPE OF (terminator_symbol);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_CURVE' IN TYPEOF
        (SELF\terminator_symbol.annotated_curve);
END_ENTITY;


ENTITY length_function
	SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand : string_expression;
END_ENTITY;


ENTITY length_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY length_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF\named_unit.dimensions.length_exponent = 1.0) AND 
    (SELF\named_unit.dimensions.mass_exponent = 0.0) AND 
    (SELF\named_unit.dimensions.time_exponent = 0.0) AND 
    (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND 
    (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND 
    (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND 
    (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;


ENTITY light_source
	SUPERTYPE OF (ONEOF (light_source_ambient, light_source_directional, light_source_positional, light_source_spot))
	SUBTYPE OF (geometric_representation_item);
	light_colour : colour;
WHERE
	WR1 : SIZEOF(USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
                              'STYLED_ITEM.ITEM')) = 0;
END_ENTITY;


ENTITY light_source_ambient
	SUBTYPE OF (light_source);
END_ENTITY;


ENTITY light_source_directional
	SUBTYPE OF (light_source);
	orientation : direction;
END_ENTITY;


ENTITY light_source_positional
	SUBTYPE OF (light_source);
	position : cartesian_point;
	constant_attenuation : REAL;
	distance_attenuation : REAL;
END_ENTITY;


ENTITY light_source_spot
	SUBTYPE OF (light_source);
	position : cartesian_point;
	orientation : direction;
	concentration_exponent : REAL;
	constant_attenuation : REAL;
	distance_attenuation : REAL;
	spread_angle : positive_plane_angle_measure;
END_ENTITY;


ENTITY like_expression
	SUBTYPE OF (comparison_expression);
WHERE
	WR1 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRING_EXPRESSION' 
		IN TYPEOF(SELF\binary_generic_expression.operands[1])) AND 
		('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRING_EXPRESSION' 
		IN TYPEOF(SELF\binary_generic_expression.operands[2]));
END_ENTITY;


ENTITY limits_and_fits;
	form_variance : label;
	zone_variance : label;
	grade : label;
	source : text;
END_ENTITY;


ENTITY line
	SUBTYPE OF (curve);
	pnt : cartesian_point;
	dir : vector;
WHERE
	WR1 : dir.dim  = pnt.dim;
END_ENTITY;


ENTITY line_profile_tolerance
	SUBTYPE OF (geometric_tolerance);
WHERE
	WR1 : NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF)) OR ( SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) <= 3);
	WR2 : SIZEOF ( 
QUERY ( sar <* USEDIN (SELF\geometric_tolerance.toleranced_shape_aspect, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar.name IN [ 'affected plane association', 'resulting intersection curve association' ]) )) = 1;
END_ENTITY;


ENTITY linear_constraint_equation_element
	SUBTYPE OF (constraint_element);
	freedoms_and_coefficients : SET [1:?] OF linear_constraint_equation_nodal_term;
	description : text;
END_ENTITY;


ENTITY linear_constraint_equation_element_value
	SUBTYPE OF (state_definition);
	element : linear_constraint_equation_element;
	b : measure_or_unspecified_value;
END_ENTITY;


ENTITY linear_constraint_equation_nodal_term;
	node : node_representation;
	coordinate_system : fea_axis2_placement_3d;
	freedom_and_coefficient_term : freedom_and_coefficient;
	dependent : LOGICAL;
END_ENTITY;


ENTITY linear_dimension
	SUBTYPE OF (dimension_curve_directed_callout);
END_ENTITY;


ENTITY linearized_table_function
	SUPERTYPE OF (ONEOF (standard_table_function, regular_table_function, triangular_matrix, symmetric_matrix, banded_matrix))
	SUBTYPE OF (explicit_table_function, unary_generic_expression);
	first : INTEGER;
	SELF\unary_generic_expression.operand : maths_function;
DERIVE
	source : maths_function := SELF\unary_generic_expression.operand;
WHERE
	WR1 : function_is_1d_array(source);
	WR2 : member_of(first, source.domain);
END_ENTITY;


ENTITY linearly_superimposed_state
	SUBTYPE OF (state);
INVERSE
	components: SET [1:?] OF state_component FOR state;
END_ENTITY;


ENTITY listed_complex_number_data
	SUBTYPE OF (explicit_table_function, generic_literal);
	values : LIST [2:?] OF REAL;
DERIVE
	SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer := [ SIZEOF(values) DIV 2 ];
WHERE
	WR1 : NOT ODD(SIZEOF(values));
END_ENTITY;


ENTITY listed_data
	SUBTYPE OF (explicit_table_function, generic_literal);
	values : LIST [1:?] OF maths_value;
	value_range : maths_space;
DERIVE
	SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer := [SIZEOF (values)];
WHERE
	WR1 : expression_is_constant(value_range);
	WR2 : SIZEOF (QUERY (val <* values | NOT (member_of( val, value_range)))) = 0;
END_ENTITY;


ENTITY listed_integer_data
	SUBTYPE OF (explicit_table_function, generic_literal);
	values : LIST [1:?] OF INTEGER;
DERIVE
	SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer := [SIZEOF (values)];
END_ENTITY;


ENTITY listed_logical_data
	SUBTYPE OF (explicit_table_function, generic_literal);
	values : LIST [1:?] OF LOGICAL;
DERIVE
	SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer := [SIZEOF (values)];
END_ENTITY;


ENTITY listed_product_space
	SUBTYPE OF (maths_space, generic_literal);
	factors : LIST [0:?] OF maths_space;
WHERE
	WR1 : SIZEOF (QUERY (space <* factors |
       NOT (expression_is_constant(space)))) = 0;
	WR2 : no_cyclic_space_reference(SELF, []);
	WR3 : NOT (the_empty_space IN factors);
END_ENTITY;


ENTITY listed_real_data
	SUBTYPE OF (explicit_table_function, generic_literal);
	values : LIST [1:?] OF REAL;
DERIVE
	SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer := [SIZEOF (values)];
END_ENTITY;


ENTITY listed_string_data
	SUBTYPE OF (explicit_table_function, generic_literal);
	values : LIST [1:?] OF STRING;
DERIVE
	SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer := [SIZEOF (values)];
END_ENTITY;


ENTITY literal_conjunction
	SUBTYPE OF (simple_clause);
END_ENTITY;


ENTITY literal_disjunction
	SUBTYPE OF (simple_clause);
END_ENTITY;


ENTITY literal_number
	ABSTRACT SUPERTYPE OF (ONEOF (int_literal, real_literal))
	SUBTYPE OF (simple_numeric_expression, generic_literal);
	the_value : NUMBER;
END_ENTITY;


ENTITY local_time;
	hour_component : hour_in_day;
	minute_component : OPTIONAL minute_in_hour;
	second_component : OPTIONAL second_in_minute;
	zone : coordinated_universal_time_offset;
WHERE
	WR1 : valid_time (SELF);
END_ENTITY;


ENTITY log10_function
	SUBTYPE OF (unary_function_call);
END_ENTITY;


ENTITY log2_function
	SUBTYPE OF (unary_function_call);
END_ENTITY;


ENTITY log_function
	SUBTYPE OF (unary_function_call);
END_ENTITY;


ENTITY logical_literal
	SUBTYPE OF (generic_literal);
	lit_value : LOGICAL;
END_ENTITY;


ENTITY logical_representation_item
	SUBTYPE OF (representation_item, logical_literal);
END_ENTITY;


ENTITY loop
	SUPERTYPE OF (ONEOF (vertex_loop, edge_loop, poly_loop))
	SUBTYPE OF (topological_representation_item);
END_ENTITY;


ENTITY loss_tangent_measure_with_unit
	SUBTYPE OF (ratio_measure_with_unit);
END_ENTITY;


ENTITY lot_effectivity
	SUBTYPE OF (effectivity);
	effectivity_lot_id : identifier;
	effectivity_lot_size : measure_with_unit;
END_ENTITY;


ENTITY luminous_flux_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LUMINOUS_FLUX_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY luminous_flux_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.lumen);
END_ENTITY;


ENTITY luminous_intensity_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LUMINOUS_INTENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY luminous_intensity_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 1.0);
END_ENTITY;


ENTITY magnetic_flux_density_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAGNETIC_FLUX_DENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY magnetic_flux_density_unit
	SUBTYPE OF (derived_unit);
WHERE
	WR1 : derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.tesla);
END_ENTITY;


ENTITY magnetic_flux_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAGNETIC_FLUX_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY magnetic_flux_unit
	SUBTYPE OF (derived_unit);
WHERE
	WR1 : derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.weber);
END_ENTITY;


ENTITY make_from_usage_option
	SUBTYPE OF (product_definition_usage);
	ranking : INTEGER;
	ranking_rationale : text;
	quantity : measure_with_unit;
WHERE
	WR1 : (NOT ('NUMBER' IN TYPEOF(quantity.value_component)))
       OR (quantity.value_component > 0);
END_ENTITY;


ENTITY manifold_solid_brep
	SUBTYPE OF (solid_model);
	outer : closed_shell;
END_ENTITY;


ENTITY manifold_subsurface_shape_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 : SIZEOF (QUERY (it <* SELF.items |
          NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET',
                'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM',
                'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D'] *
                   TYPEOF(it)) = 1))) = 0;
	WR2 : SIZEOF (QUERY (it <* SELF.items |
         SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET',
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'] * TYPEOF(it)) =1 )) > 0;
	WR3 : SIZEOF (QUERY (mi <*  QUERY (it <* items |
                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF(it)) |
   NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION' IN
             TYPEOF(mi\mapped_item.mapping_source.
                           mapped_representation)))) = 0;
	WR4 : SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
          NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OPEN_SHELL' IN TYPEOF(cfss)))) = 0;
	WR5 : SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
          NOT( (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN
                   TYPEOF(cfss\connected_face_sub_set.parent_face_set))AND
           (SIZEOF(QUERY(fac <* cfss\connected_face_sub_set.parent_face_set\connected_face_set.cfs_faces | NOT
                 advanced_face_properties(fac))) = 0)) OR
            (SIZEOF(QUERY(fac <* cfss\connected_face_sub_set.parent_face_set\connected_face_set.cfs_faces | NOT
              ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF(fac)))) = 0)
                    ))) = 0;
	WR6 : SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
          ( SIZEOF (QUERY (fac <* cfss\connected_face_set.cfs_faces  | NOT
              advanced_face_properties(fac))) = 0))) = 0;
	WR7 : SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
          'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
               ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SUBFACE' IN TYPEOF(fcs)) AND
            NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                  NOT(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_CURVE' IN
            TYPEOF(oe.edge_element)) OR
           ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SUBEDGE' IN
            TYPEOF(oe.edge_element)) ))) = 0
                   ))) = 0
                 ))) = 0
             ))) = 0;
	WR8 : SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
           ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SUBFACE' IN TYPEOF(fcs)) AND
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                 NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
          NOT(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF(oe.edge_start))
                AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN
                 TYPEOF(oe.edge_end))
            ))) = 0
              ))) = 0
               ))) = 0
                   ))) = 0;
	WR9 : SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
              ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SUBFACE' IN TYPEOF(fcs)) AND
              ( NOT (SIZEOF(QUERY  (bnds <* fcs.bounds |
         NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP',
                'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_LOOP'] *
                   TYPEOF(bnds.bound)) = 1 )
                   )) = 0)
                 ))) = 0
             ))) = 0;
	WR10 : SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
              ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SUBFACE' IN TYPEOF(fcs)) AND
              ( NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                 NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                   NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE',
                         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONIC',
                         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE',
                         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE',
                         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE' ] *
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) = 1 )
               )) = 0
               ))) = 0
                 )))) = 0
                    ))) = 0;
	WR11 : SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
              ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SUBFACE' IN TYPEOF(fcs)) AND
               (NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                   ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE' IN
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND
            (NOT ((SIZEOF (QUERY (sc_ag <*
            oe.edge_element\edge_curve.edge_geometry\
            surface_curve.associated_geometry |
            NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN
            TYPEOF(sc_ag)))) = 0)))
               )) = 0
               ))) = 0
                   )))) = 0
                    ))) = 0;
	WR12 : SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
              ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SUBFACE' IN TYPEOF(fcs)) AND
               (NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                   ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND
            (NOT (SIZEOF (oe\oriented_edge.edge_element\
                  edge_curve.edge_geometry\polyline.points) >= 3))
               )) = 0
               ))) = 0
                   )))) = 0
                    ))) = 0;
END_ENTITY;


ENTITY manifold_surface_shape_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 : SIZEOF (QUERY (it <* SELF.items |
       NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D'] * TYPEOF (it)) = 1))) = 0;
	WR2 : SIZEOF (QUERY (it <* SELF.items |
       SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'] * TYPEOF (it)) = 1)) > 0;
	WR3 : SIZEOF (QUERY (mi <* QUERY (it <* SELF.items |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF (it)) |
       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SURFACE_SHAPE_REPRESENTATION'
       IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))
       AND
       (SIZEOF(QUERY (mr_it <*
       mi\mapped_item.mapping_source.mapped_representation.items |
       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL'
       IN TYPEOF (mr_it)))) > 0 )))) = 0;
	WR4 : SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (sh <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OPEN_SHELL',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_CLOSED_SHELL',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CLOSED_SHELL']
       * TYPEOF (sh)) = 1))) = 0))) = 0;
	WR5 : SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_SURFACE' IN TYPEOF (fa)) )) = 0)))
       = 0))) = 0;
	WR6 : SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (msf_surface_check(fa\face_surface.face_geometry))))) = 0))) 
       = 0))) = 0;
	WR7 : SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (bnds <* fa.bounds |
       NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_LOOP']
       * TYPEOF (bnds.bound)) = 1))) = 0)))) = 0))) = 0))) = 0;
	WR8 : SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items|
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_CURVE' IN TYPEOF 
       (oe.edge_element)))) = 0))) = 0)))) = 0))) = 0))) = 0;
	WR9 : SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe_cv <* QUERY (oe <* 
       elp_fbnds\path.edge_list |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_CURVE' IN TYPEOF (oe.edge_element)) |
       NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONIC',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_REPLICA',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_CURVE_3D',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE'] * 
       TYPEOF (oe_cv.edge_element\edge_curve.edge_geometry)) 
       = 1))) = 0))) = 0)))) = 0))) = 0))) = 0;
	WR10 : SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT (msf_curve_check (oe.edge_element\edge_curve.edge_geometry)))) 
       = 0))) = 0)))) = 0))) = 0))) = 0;
	WR11 : SIZEOF (QUERY(sbsm <* QUERY (it <* SELF.items |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list|
       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF
       (oe.edge_element.edge_start))
       AND
       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN
       TYPEOF (oe.edge_element.edge_end))))) 
       = 0))) = 0)))) = 0))) = 0))) = 0;
	WR12 : SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT ((SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DEGENERATE_PCURVE',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_CURVE',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_SURFACE'] * TYPEOF
       (oe.edge_element.edge_start\vertex_point.vertex_geometry)) = 1)
       AND
       (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DEGENERATE_PCURVE',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_CURVE',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_SURFACE'] * TYPEOF
       (oe.edge_element.edge_end\vertex_point.vertex_geometry)) = 1
       )))) = 0))) = 0)))) = 0))) = 0))) = 0;
	WR13 : SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <* 
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |
       NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF
       (vlp_fbnds\vertex_loop.loop_vertex)))) = 0)))) = 0))) 
       = 0))) = 0;
	WR14 : SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <* 
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DEGENERATE_PCURVE',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_CURVE',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_SURFACE'] * TYPEOF
       (vlp_fbnds\vertex_loop.loop_vertex\vertex_point.vertex_geometry)) 
       = 1))) = 0)))) = 0))) = 0))) = 0;
END_ENTITY;


ENTITY mapped_item
	SUBTYPE OF (representation_item);
	mapping_source : representation_map;
	mapping_target : representation_item;
WHERE
	WR1 : acyclic_mapped_representation(SELF);
END_ENTITY;


ENTITY mass_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MASS_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY mass_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 1.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;


ENTITY matched_mesh_connection
	SUBTYPE OF (mesh_connectivity);
	range : indices_range;
	donor : structured_mesh;
	donor_range : indices_range;
	transform : ARRAY [1:index_count] OF INTEGER;
	SELF\mesh_connectivity.current : structured_mesh;
WHERE
	wr1 : current :<>: donor;
	wr2 : donor.index_count = index_count;
	wr3 : range.nindices = index_count;
	wr4 : donor_range.nindices = index_count;
END_ENTITY;


ENTITY material_designation;
	name : label;
	definitions : SET [1:?] OF characterized_definition;
END_ENTITY;


ENTITY material_designation_characterization;
	name : label;
	description : text;
	designation : material_designation;
	property : characterized_material_property;
END_ENTITY;


ENTITY material_property
	SUBTYPE OF (property_definition);
UNIQUE
	UR1 : SELF\property_definition.name, SELF\property_definition.definition;
WHERE
	WR1 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CHARACTERIZED_OBJECT' IN
          TYPEOF(SELF\property_definition.definition)) OR
       (SIZEOF(bag_to_set(USEDIN(SELF ,
                     'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                     'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) -
              QUERY(temp <* bag_to_set(USEDIN(SELF ,
                       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
                       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                      'MATERIAL_PROPERTY_REPRESENTATION' IN
                      TYPEOF(temp)))) = 0);
END_ENTITY;


ENTITY material_property_representation
	SUBTYPE OF (property_definition_representation);
	dependent_environment : data_environment;
END_ENTITY;


ENTITY mathematical_description;
	described : maths_expression;
	describing : STRING;
	encoding : label;
END_ENTITY;


ENTITY maths_boolean_variable
	SUBTYPE OF (maths_variable, boolean_variable);
WHERE
	WR1 : subspace_of_es(SELF\maths_variable.values_space,es_booleans);
END_ENTITY;


ENTITY maths_enum_literal
	SUBTYPE OF (generic_literal);
	lit_value : maths_enum_atom;
END_ENTITY;


ENTITY maths_function
	ABSTRACT SUPERTYPE OF (ONEOF (finite_function, constant_function, selector_function, elementary_function, restriction_function, repackaging_function, reindexed_array_function, series_composed_function, parallel_composed_function, explicit_table_function, homogeneous_linear_function, general_linear_function, b_spline_basis, b_spline_function, rationalize_function, partial_derivative_function, definite_integral_function, abstracted_expression_function, expression_denoted_function, imported_point_function, imported_curve_function, imported_surface_function, imported_volume_function, application_defined_function))
	SUBTYPE OF (generic_expression);
DERIVE
	domain : tuple_space := derive_function_domain(SELF);
	range : tuple_space := derive_function_range(SELF);
END_ENTITY;


ENTITY maths_integer_variable
	SUBTYPE OF (maths_variable, int_numeric_variable);
WHERE
	WR1 : subspace_of_es(SELF\maths_variable.values_space,es_integers);
END_ENTITY;


ENTITY maths_real_variable
	SUBTYPE OF (maths_variable, real_numeric_variable);
WHERE
	WR1 : subspace_of_es(SELF\maths_variable.values_space,es_reals);
END_ENTITY;


ENTITY maths_space
	ABSTRACT SUPERTYPE OF (ONEOF (elementary_space, finite_integer_interval, integer_interval_from_min, integer_interval_to_max, finite_real_interval, real_interval_from_min, real_interval_to_max, cartesian_complex_number_region, polar_complex_number_region, finite_space, uniform_product_space, listed_product_space, extended_tuple_space, function_space))
	SUBTYPE OF (generic_expression);
END_ENTITY;


ENTITY maths_space_context
	SUPERTYPE OF (ONEOF (compound_maths_space_context, defined_maths_space_context, explicitly_enumerated_maths_space_context));
	id : identifier;
	name : label;
	description : OPTIONAL text;
	abstract_space : maths_space;
	physical_space : space_context_select;
END_ENTITY;


ENTITY maths_string_variable
	SUBTYPE OF (maths_variable, string_variable);
WHERE
	WR1 : subspace_of_es(SELF\maths_variable.values_space,es_strings);
END_ENTITY;


ENTITY maths_tuple_literal
	SUBTYPE OF (generic_literal);
	lit_value : LIST [0:?] OF maths_value;
END_ENTITY;


ENTITY maths_value_context;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	abstract_value : maths_value;
	physical_value : value_context_select;
END_ENTITY;


ENTITY maths_variable
	SUBTYPE OF (generic_variable);
	values_space : maths_space;
	name : label;
WHERE
	WR1 : expression_is_constant(values_space);
END_ENTITY;


ENTITY maximum_function
	SUBTYPE OF (multiple_arity_function_call);
END_ENTITY;


ENTITY mbna_bc
	SUPERTYPE OF (ONEOF (elements_bc, indexed_elements_bc, indexed_points_bc))
	SUBTYPE OF (mbna_condition);
	datasets : SET [0:?] OF mbna_bc_dataset;
	gridloc : mesh_location;
	inward_normal_index : OPTIONAL ijk_minmax;
	inward_normal_list : OPTIONAL indices_list;
	rstate : SET [0:?] OF mbna_reference_state;
	the_type : mbna_bc_type;
END_ENTITY;


ENTITY mbna_bc_data
	SUBTYPE OF (mbna_condition);
END_ENTITY;


ENTITY mbna_bc_data_global
	SUBTYPE OF (mbna_bc_data);
INVERSE
	data_global: SET [0:?] OF model_property_distribution FOR domain;
END_ENTITY;


ENTITY mbna_bc_data_local
	SUBTYPE OF (mbna_bc_data);
INVERSE
	data_local: SET [0:?] OF model_property_distribution FOR domain;
END_ENTITY;


ENTITY mbna_bc_dataset
	SUPERTYPE OF (ONEOF (mbna_Dirichlet_bc_dataset, mbna_Neumann_bc_dataset))
	SUBTYPE OF (mbna_condition);
	gridloc : mesh_location;
	rstate : SET [0:?] OF mbna_reference_state;
	the_type : mbna_bc_type_simple;
END_ENTITY;


ENTITY mbna_behaviour_model
	SUPERTYPE OF (ONEOF (thermal_conductivity_model, gas_model, turbulence_closure, turbulence_model, viscosity_model))
	SUBTYPE OF (mbna_equation);
INVERSE
	data: SET [0:?] OF model_property_distribution FOR domain;
END_ENTITY;


ENTITY mbna_condition
	ABSTRACT SUPERTYPE OF (ONEOF (mbna_zone_bc, mbna_bc, mbna_bc_dataset, mbna_bc_data, mbna_reference_state))
	SUBTYPE OF (model_state_domain);
END_ENTITY;


ENTITY mbna_Dirichlet_bc_dataset
	SUBTYPE OF (mbna_bc_dataset);
	data : mbna_bc_data;
END_ENTITY;


ENTITY mbna_discrete_data
	SUBTYPE OF (mbna_result);
	gridloc : mesh_location;
INVERSE
	data: SET [0:?] OF property_distribution_description FOR physical_function;
END_ENTITY;


ENTITY mbna_discrete_data_with_rind
	SUBTYPE OF (mbna_discrete_data);
	rind_planes : rind;
END_ENTITY;


ENTITY mbna_equation
	SUPERTYPE OF (ONEOF (mbna_equation_set, mbna_governing_equation, mbna_behaviour_model))
	SUBTYPE OF (model_product_domain);
END_ENTITY;


ENTITY mbna_equation_set
	SUBTYPE OF (mbna_equation);
	dimension : INTEGER;
	equations : mbna_governing_equation;
	mbna_models : SET [0:?] OF mbna_behaviour_models;
END_ENTITY;


ENTITY mbna_governing_equation
	SUBTYPE OF (mbna_equation);
	equation_type : mbna_governing_equation_type;
END_ENTITY;


ENTITY mbna_history
	SUBTYPE OF (mbna_result);
	notes : LIST [0:?] OF text;
INVERSE
	data: SET [0:?] OF property_distribution_description FOR physical_function;
END_ENTITY;


ENTITY mbna_model
	SUBTYPE OF (model_product_domain);
	equations : SET [0:?] OF mbna_equation_set;
	SELF\model_product_domain.temporal_parts : LIST [0:?] OF mbna_step;
INVERSE
	history: SET [0:?] OF mbna_history FOR domain;
END_ENTITY;


ENTITY mbna_Neumann_bc_dataset
	SUBTYPE OF (mbna_bc_dataset);
	data : mbna_bc_data;
END_ENTITY;


ENTITY mbna_reference_state
	SUBTYPE OF (mbna_condition);
INVERSE
	data: SET [0:?] OF model_property_distribution FOR domain;
END_ENTITY;


ENTITY mbna_result
	SUPERTYPE OF (ONEOF (mbna_solution, mbna_history, mbna_discrete_data))
	SUBTYPE OF (model_property_distribution);
END_ENTITY;


ENTITY mbna_solution
	SUBTYPE OF (mbna_result);
	gridloc : mesh_location;
INVERSE
	solution: SET [0:?] OF property_distribution_description FOR physical_function;
END_ENTITY;


ENTITY mbna_solution_with_rind
	SUBTYPE OF (mbna_solution);
	rind_planes : rind;
END_ENTITY;


ENTITY mbna_state
	SUBTYPE OF (model_state_domain);
END_ENTITY;


ENTITY mbna_step
	SUBTYPE OF (model_action_domain);
	equations : SET [0:?] OF mbna_equation_set;
	refstate : SET [0:?] OF mbna_reference_state;
	zones : LIST [0:?] OF mbna_zone;
	SELF\model_action_domain.final : mbna_state;
INVERSE
	history: SET [0:?] OF mbna_history FOR domain;
END_ENTITY;


ENTITY mbna_zone
	SUBTYPE OF (model_product_domain_with_mesh);
	conditions : SET [0:?] OF mbna_zone_bc;
	equations : SET [0:?] OF mbna_equation_set;
	grid_connectivity : OPTIONAL multiple_mesh_block;
	rstate : SET [0:?] OF mbna_reference_state;
INVERSE
	coordinates: SET [0:?] OF grid_coordinates FOR domain;
	field_data: SET [0:?] OF mbna_discrete_data FOR domain;
	history: SET [0:?] OF mbna_history FOR domain;
	solution: SET [0:?] OF mbna_solution FOR domain;
END_ENTITY;


ENTITY mbna_zone_bc
	SUBTYPE OF (mbna_condition);
	conditions : SET [0:?] OF mbna_bc;
	rstate : SET [0:?] OF mbna_reference_state;
END_ENTITY;


ENTITY measure_qualification;
	name : label;
	description : text;
	qualified_measure : measure_with_unit;
	qualifiers : SET [1:?] OF value_qualifier;
WHERE
	WR1 : SIZEOF(QUERY(temp <* qualifiers |
             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRECISION_QUALIFIER'
             IN TYPEOF(temp))) < 2;
	WR2 : NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REPRESENTATION_ITEM'
           IN TYPEOF(SELF\measure_qualification.qualified_measure));
END_ENTITY;


ENTITY measure_representation_item
	SUBTYPE OF (representation_item, measure_with_unit);
END_ENTITY;


ENTITY measure_with_unit
	SUPERTYPE OF (ONEOF (length_measure_with_unit, mass_measure_with_unit, time_measure_with_unit, electric_current_measure_with_unit, thermodynamic_temperature_measure_with_unit, celsius_temperature_measure_with_unit, amount_of_substance_measure_with_unit, luminous_intensity_measure_with_unit, plane_angle_measure_with_unit, solid_angle_measure_with_unit, area_measure_with_unit, volume_measure_with_unit, ratio_measure_with_unit, acceleration_measure_with_unit, capacitance_measure_with_unit, electric_charge_measure_with_unit, conductance_measure_with_unit, electric_potential_measure_with_unit, energy_measure_with_unit, magnetic_flux_density_measure_with_unit, force_measure_with_unit, frequency_measure_with_unit, illuminance_measure_with_unit, inductance_measure_with_unit, luminous_flux_measure_with_unit, magnetic_flux_measure_with_unit, power_measure_with_unit, pressure_measure_with_unit, resistance_measure_with_unit, velocity_measure_with_unit, absorbed_dose_measure_with_unit, radioactivity_measure_with_unit, dose_equivalent_measure_with_unit));
	value_component : measure_value;
	unit_component : unit;
WHERE
	WR1 : valid_units(SELF);
END_ENTITY;


ENTITY mechanical_context
	SUBTYPE OF (product_context);
WHERE
	WR1 : SELF.discipline_type = 'mechanical';
END_ENTITY;


ENTITY mechanical_design_and_draughting_relationship
	SUBTYPE OF (definitional_representation_relationship_with_same_context);
	SELF\representation_relationship.rep_1 : mechanical_design_and_draughting_relationship_select;
	SELF\representation_relationship.rep_2 : mechanical_design_and_draughting_relationship_select;
WHERE
	WR1 : NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'DRAUGHTING_MODEL' IN TYPEOF(rep_2)) OR 
       (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'DRAUGHTING_MODEL' IN TYPEOF(rep_1)) OR
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'SHAPE_REPRESENTATION' IN TYPEOF(rep_1)));
	WR2 : NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION' IN TYPEOF(rep_2)) OR 
       (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION' IN TYPEOF(rep_1)) OR
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'SHAPE_REPRESENTATION' IN TYPEOF(rep_1)));
	WR3 : NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'MECHANICAL_DESIGN_SHADED_PRESENTATION_REPRESENTATION' IN TYPEOF(rep_2)) OR 
       (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'MECHANICAL_DESIGN_SHADED_PRESENTATION_REPRESENTATION' IN TYPEOF(rep_1)) OR
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'SHAPE_REPRESENTATION' IN TYPEOF(rep_1)));
END_ENTITY;


ENTITY mechanical_design_geometric_presentation_area
	SUBTYPE OF (presentation_area);
	SELF\representation.items : SET [1:?] OF mechanical_design_geometric_presentation_area_items;
WHERE
	WR1 : SIZEOF(QUERY(it1 <* SELF.items |
        NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'
        IN TYPEOF(it1))
        OR
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRESENTATION_VIEW'
        IN TYPEOF
        (it1\mapped_item.mapping_source.mapped_representation)))) = 0;
	WR2 : SIZEOF(QUERY(pv <* QUERY(mi1 <* QUERY(it1 <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'
        IN TYPEOF(it1)) |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRESENTATION_VIEW'
        IN TYPEOF
        (mi1\mapped_item.mapping_source.mapped_representation)) |
        -- search in all presentation_views for axis2_placements and
        -- mapped_items and for the subtype of mapped_item
        -- camera_image_3d_with_scale; the latter shall reference
        -- a mechanical_design_geometric_presentation_representation;
        -- the supertype mapped_item shall reference presentation_view.
        NOT (SIZEOF(QUERY(it2 <* pv\mapped_item.mapping_source.
        mapped_representation\representation.items |
        NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT'
        IN TYPEOF(it2))
        OR
        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'
        IN TYPEOF(it2)) AND NOT
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'CAMERA_IMAGE_3D_WITH_SCALE' IN TYPEOF(it2))) AND NOT (
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRESENTATION_VIEW'
        IN TYPEOF
        (it2\mapped_item.mapping_source.mapped_representation)))
        OR
        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'CAMERA_IMAGE_3D_WITH_SCALE' IN TYPEOF(it2))
        AND NOT (
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION'
        IN TYPEOF (it2\mapped_item.mapping_source.mapped_representation) ))
        ))) = 0))) = 0;
	WR3 : (SIZEOF(QUERY(ps <* USEDIN (SELF,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'PRESENTATION_SIZE.UNIT') | 
        ((ps\presentation_size.size.size_in_x <= 0)
         OR
         (ps\presentation_size.size.size_in_y <= 0)))) = 0)
        AND
        (SIZEOF(QUERY(ais <* USEDIN (SELF,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'AREA_IN_SET.AREA') |
        (SIZEOF(QUERY(ps <* USEDIN (ais, 
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'PRESENTATION_SIZE.UNIT') |
        ((ps\presentation_size.size.size_in_x <= 0)
        OR
        (ps\presentation_size.size.size_in_y <= 0)))) > 0))) = 0);
	WR4 : (SIZEOF(QUERY(ps <* USEDIN (SELF,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'PRESENTATION_SIZE.UNIT') | 
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'AXIS2_PLACEMENT_2D' IN TYPEOF (ps.size.placement)))) = 1)
        AND
        (SIZEOF(QUERY(ps <* USEDIN (SELF,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'PRESENTATION_SIZE.UNIT') | 
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'AXIS2_PLACEMENT_3D' IN TYPEOF (ps.size.placement)))) = 0)
        OR
        ((SIZEOF(QUERY(ais <* USEDIN (SELF,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'AREA_IN_SET.AREA') |
        (SIZEOF(QUERY(ps <* USEDIN (ais, 
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'PRESENTATION_SIZE.UNIT') |
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'AXIS2_PLACEMENT_2D' IN TYPEOF (ps.size.placement)))) = 1))) = 1)
        AND
        (SIZEOF(QUERY(ais <* USEDIN (SELF,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'AREA_IN_SET.AREA') |
        (SIZEOF(QUERY(ps <* USEDIN (ais, 
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'PRESENTATION_SIZE.UNIT') |
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'AXIS2_PLACEMENT_3D' IN TYPEOF (ps.size.placement)))) = 0))) = 1));
END_ENTITY;


ENTITY mechanical_design_geometric_presentation_representation
	SUBTYPE OF (representation);
	SELF\representation.items : SET [1:?] OF mechanical_design_geometric_presentation_representation_items;
WHERE
	WR1 : SIZEOF(QUERY(mi <* QUERY(it <* SELF.items |
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'
        IN TYPEOF(it))) | NOT (SIZEOF(
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'SHAPE_REPRESENTATION',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION']
        * TYPEOF(mi\mapped_item.mapping_source.mapped_representation))
        = 1))) = 0;
	WR2 : SIZEOF(QUERY(smi <* QUERY(si <* QUERY(it <* SELF.items |
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'
        IN TYPEOF(it))) |
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'
        IN TYPEOF(si\styled_item.item))) | NOT (
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'SHAPE_REPRESENTATION' IN TYPEOF (smi\styled_item.
        item\mapped_item.mapping_source.mapped_representation))) )) = 0;
	WR3 : SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(pss <* psa.styles | NOT (SIZEOF(
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_STYLE',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE']
        * TYPEOF(pss)) = 1))) = 0))) = 0))) = 0;
	WR4 : SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'
        IN TYPEOF(it)) |
        NOT (SIZEOF(QUERY(psbc <* QUERY(psa <* si\styled_item.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'PRESENTATION_STYLE_BY_CONTEXT' IN TYPEOF(psa)) | NOT (SIZEOF(
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'REPRESENTATION_ITEM',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REPRESENTATION']
        * TYPEOF(psbc\presentation_style_by_context.style_context))
        = 1))) = 0))) = 0;
	WR5 : SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ps <* QUERY(pss <* psa.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_STYLE'
        IN TYPEOF(pss)) | NOT
        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF (ps\point_style.marker_size))
        AND (SIZEOF(
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(ps\point_style.marker_colour))
        = 1)))) = 0))) = 0))) = 0;
	WR6 : SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(cs <* QUERY(pss <* psa.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE'
        IN TYPEOF(pss)) | NOT((SIZEOF(
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(cs\curve_style.curve_colour)) = 1)
        AND
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF (cs\curve_style.curve_width))
        AND (SIZEOF(
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE_FONT',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(cs\curve_style.curve_font)) = 1)))) = 0))) = 0))) = 0;
	WR7 : SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) |
        NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'SURFACE_SIDE_STYLE' IN TYPEOF
        (ssu\surface_style_usage.style)))) = 0))) = 0))) = 0;
	WR8 : SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        NOT (SIZEOF(
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'SURFACE_STYLE_PARAMETER_LINE',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'SURFACE_STYLE_CONTROL_GRID',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'SURFACE_STYLE_SILHOUETTE',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'SURFACE_STYLE_SEGMENTATION_CURVE',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'SURFACE_STYLE_FILL_AREA',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'SURFACE_STYLE_BOUNDARY']
        * TYPEOF(sses)) = 1))) = 0))) = 0))) = 0))) = 0;
	WR9 : SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sspl <* QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'SURFACE_STYLE_PARAMETER_LINE' IN TYPEOF(sses)) |
        NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE'
        IN TYPEOF
        (sspl\surface_style_parameter_line.style_of_parameter_lines))
        AND (SIZEOF(
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(sspl\surface_style_parameter_line.
        style_of_parameter_lines\curve_style.curve_colour)) = 1)
        AND (
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (sspl\surface_style_parameter_line.
        style_of_parameter_lines\curve_style.curve_width))
        AND (SIZEOF(
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE_FONT',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(sspl\surface_style_parameter_line.
        style_of_parameter_lines\curve_style.curve_font)) = 1))))
        = 0))) = 0))) = 0))) = 0;
	WR10 : SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sscg <* QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'SURFACE_STYLE_CONTROL_GRID' IN TYPEOF(sses)) |
        NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE'
        IN TYPEOF (sscg\surface_style_control_grid.style_of_control_grid))
        AND (SIZEOF(
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(sscg\surface_style_control_grid.
        style_of_control_grid\curve_style.curve_colour)) = 1)
        AND
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF 
        (sscg\surface_style_control_grid.
        style_of_control_grid\curve_style.curve_width))
        AND (SIZEOF(
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE_FONT',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(sscg\surface_style_control_grid.
        style_of_control_grid\curve_style.curve_font)) = 1))))
        = 0))) = 0))) = 0))) = 0;
	WR11 : SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'
        IN TYPEOF(it)) |
        NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sssh <* QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'SURFACE_STYLE_SILHOUETTE' IN TYPEOF(sses)) |
        NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE'
        IN TYPEOF (sssh\surface_style_silhouette.style_of_silhouette))
        AND (SIZEOF(
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(sssh\surface_style_silhouette.
        style_of_silhouette\curve_style.curve_colour)) = 1)
        AND
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (sssh\surface_style_silhouette.style_of_silhouette\curve_style.
        curve_width))
        AND (SIZEOF(
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE_FONT',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(sssh\surface_style_silhouette.
        style_of_silhouette\curve_style.curve_font)) = 1))))
        = 0))) = 0))) = 0))) = 0;
	WR12 : SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sssc <* QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'SURFACE_STYLE_SEGMENTATION_CURVE' IN TYPEOF(sses)) |
        NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE'
        IN TYPEOF
        (sssc\surface_style_segmentation_curve.style_of_segmentation_curve))
        AND (SIZEOF(
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve\curve_style.curve_colour)) = 1)
        AND
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve\curve_style.curve_width))
        AND (SIZEOF(
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE_FONT',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve\curve_style.curve_font)) = 1))))
        = 0))) = 0))) = 0))) = 0;
	WR13 : SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(ssbd <* QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'SURFACE_STYLE_BOUNDARY' IN TYPEOF(sses)) |
        NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE'
        IN TYPEOF (ssbd\surface_style_boundary.style_of_boundary))
        AND (SIZEOF(
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(ssbd\surface_style_boundary.
        style_of_boundary\curve_style.curve_colour)) = 1)
        AND
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF (ssbd\surface_style_boundary.
        style_of_boundary\curve_style.curve_width))
        AND (SIZEOF(
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE_FONT',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(ssbd\surface_style_boundary.
        style_of_boundary\curve_style.curve_font)) = 1)))) = 0)))
        = 0))) = 0))) = 0;
END_ENTITY;


ENTITY mechanical_design_presentation_representation_with_draughting
	SUBTYPE OF (representation);
	SELF\representation.items : SET [1:?] OF camera_model_d3;
END_ENTITY;


ENTITY mechanical_design_shaded_presentation_area
	SUBTYPE OF (presentation_area);
	SELF\representation.items : SET [1:?] OF mechanical_design_shaded_presentation_area_items;
WHERE
	WR1 : SIZEOF (QUERY (it1 <* SELF.items |
        NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT'
        IN TYPEOF (it1))
        OR
        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'
        IN TYPEOF (it1)) AND
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRESENTATION_VIEW'
        IN TYPEOF
        (it1\mapped_item.mapping_source.mapped_representation)))))) = 0;
	WR2 : SIZEOF (QUERY (pv <* QUERY (mi1 <* QUERY (it1 <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'
        IN TYPEOF (it1)) |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRESENTATION_VIEW'
        IN TYPEOF
        (mi1\mapped_item.mapping_source.mapped_representation)) |
        (* search in all presentation_views for axis2_placements and
           mapped_items and for the subtype of mapped_item,
           camera_image_3d_with_scale; the latter shall reference
           a mechanical_design_geometric_presentation_representation;
           the supertype mapped_item shall reference presentation_view. *)
        NOT (SIZEOF(QUERY(it2 <* pv\mapped_item.mapping_source.
        mapped_representation\representation.items |
        NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT'
        IN TYPEOF(it2))
        OR
        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'
        IN TYPEOF(it2)) AND NOT
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'CAMERA_IMAGE_3D_WITH_SCALE' IN TYPEOF(it2))) AND NOT (
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRESENTATION_VIEW'
        IN TYPEOF
        (it2\mapped_item.mapping_source.mapped_representation)))
        OR
        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'CAMERA_IMAGE_3D_WITH_SCALE' IN TYPEOF(it2))
        AND NOT (
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'MECHANICAL_DESIGN_SHADED_PRESENTATION_REPRESENTATION'
        IN TYPEOF (it2\mapped_item.mapping_source.mapped_representation) ))
        ))) = 0))) = 0;
	WR3 : (SIZEOF (QUERY(ps <* USEDIN (SELF, 
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
        'PRESENTATION_SIZE.UNIT') |
        NOT ((ps\presentation_size.size.size_in_x > 0) 
        AND (ps\presentation_size.size.size_in_y > 0)) )) = 0)
        AND
        (* check secondly for presentation_set, via area_in_set *)
        (SIZEOF (QUERY(pset <* QUERY(ais <* 
        USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
        'AREA_IN_SET.AREA') 
        | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'PRESENTATION_SET' IN TYPEOF (ais.in_set)) |
        (* after having collected all presentation_set, check their sizes *)
        SIZEOF (QUERY(ps <* USEDIN(pset, 
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
        'PRESENTATION_SIZE.UNIT')
        | NOT ((ps\presentation_size.size.size_in_x > 0) 
        AND (ps\presentation_size.size.size_in_y > 0)) )) = 0)) = 0);
	WR4 : (SIZEOF(QUERY( psize <* USEDIN (SELF, 
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
        'PRESENTATION_SIZE.UNIT') 
        | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'AXIS2_PLACEMENT_2D' 
        IN TYPEOF (psize.size.placement))) = 1)
        AND
        (* check secondly for presentation_set, via area_in_set *)
        (SIZEOF (QUERY(pset <* QUERY(ais <* 
        USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'AREA_IN_SET.AREA')
        | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'PRESENTATION_SET' IN TYPEOF (ais.in_set)) |
        (* after having collected all presentation_set, check their 
           dimension *)
        SIZEOF (QUERY(psize <* USEDIN(pset, 
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
        'PRESENTATION_SIZE.UNIT')
        | NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
        'AXIS2_PLACEMENT_2D' 
        IN TYPEOF (psize.size.placement)) )) = 0)) = 0);
	WR5 : SIZEOF (QUERY (pv <* QUERY (mi1 <* QUERY (it1 <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' 
        IN TYPEOF (it1)) |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRESENTATION_VIEW' 
        IN TYPEOF 
        (mi1\mapped_item.mapping_source.mapped_representation)) |
        (* search in all presentation_views for 
           mapped_items and for the subtype of mapped_item,
           camera_image_3d_with_scale; the latter shall reference
           a camera_usage that shall have as its mapping_origin either
           camera_model_d3, camera_model_d3_with_hlhsr, or
           camera_model_with_light_sources. *)
        NOT (SIZEOF(QUERY(ci <* pv\mapped_item.mapping_source.
        mapped_representation\representation.items |
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
         'CAMERA_IMAGE_3D_WITH_SCALE' IN TYPEOF(ci))
        AND
        (SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'CAMERA_MODEL_D3',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'CAMERA_MODEL_D3_WITH_HLHSR',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'CAMERA_MODEL_WITH_LIGHT_SOURCES'] * TYPEOF
        (ci\mapped_item.mapping_source.mapping_origin))
        = 1))) = 0))) = 0;
END_ENTITY;


ENTITY mechanical_design_shaded_presentation_representation
	SUBTYPE OF (representation);
	SELF\representation.items : SET [1:?] OF mechanical_design_shaded_presentation_representation_items;
WHERE
	WR1 : SIZEOF(QUERY(mi <* QUERY(it <* SELF.items |
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'
        IN TYPEOF(it))) | NOT (SIZEOF(
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'SHAPE_REPRESENTATION',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'MECHANICAL_DESIGN_SHADED_PRESENTATION_REPRESENTATION']
        * TYPEOF(mi\mapped_item.mapping_source.mapped_representation))
        = 1))) = 0;
	WR2 : SIZEOF(QUERY(smi <* QUERY(si <* QUERY(it <* SELF.items |
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'
        IN TYPEOF(it))) |
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'
        IN TYPEOF(si\styled_item.item))) | NOT (
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'SHAPE_REPRESENTATION' IN TYPEOF (smi\styled_item.
        item\mapped_item.mapping_source.mapped_representation))) )) = 0;
	WR3 : SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (pss <* psa.styles |
        NOT (SIZEOF (
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_STYLE',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE']
        *  TYPEOF (pss)) = 1))) = 0))) = 0))) = 0;
	WR4 : SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psbc <* QUERY (psa <* si\styled_item.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'PRESENTATION_STYLE_BY_CONTEXT' IN TYPEOF (psa))  |
        NOT (SIZEOF (
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REPRESENTATION_ITEM',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REPRESENTATION']
        * TYPEOF (psbc\presentation_style_by_context.style_context)) = 1)))
        = 0))) = 0;
	WR5 : SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ps <* QUERY (pss <* psa.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_STYLE'
        IN TYPEOF (pss)) |
        NOT (
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MARKER_TYPE'
        IN TYPEOF (ps\point_style.marker))
        AND
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (ps\point_style.marker_size))
        AND
        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (ps\point_style.marker_colour)) = 1)))) = 0))) = 0))) = 0;
	WR6 : SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (cs <* QUERY (pss <* psa.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE'
        IN TYPEOF (pss)) |
        NOT (
        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (cs\curve_style.curve_colour)) = 1)
        AND
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (cs\curve_style.curve_width))
        AND
        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'CURVE_STYLE_FONT', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF
        (cs\curve_style.curve_font)) = 1)))) = 0))) = 0))) = 0;
	WR7 : SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_SIDE_STYLE'
        IN TYPEOF (ssu\surface_style_usage.style)) )) = 0))) = 0 ))) = 0;
	WR8 : SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT (SIZEOF (QUERY (sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        NOT (SIZEOF (
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'SURFACE_STYLE_PARAMETER_LINE',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'SURFACE_STYLE_CONTROL_GRID',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'SURFACE_STYLE_SILHOUETTE',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'SURFACE_STYLE_SEGMENTATION_CURVE',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'SURFACE_STYLE_BOUNDARY',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'SURFACE_STYLE_FILL_AREA',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'SURFACE_STYLE_RENDERING'] * TYPEOF (sses)) = 1))) = 0))) = 0)))
        = 0))) = 0;
	WR9 : SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT (SIZEOF (QUERY (ssfa <* QUERY (sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_FILL_AREA'
        IN TYPEOF (sses)) |
        NOT (SIZEOF (QUERY (fss <*
        ssfa\surface_style_fill_area.fill_area.fill_styles |
        NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'FILL_AREA_STYLE_COLOUR' IN TYPEOF (fss))
        AND
        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (fss\fill_area_style_colour.fill_colour)) = 1)))) = 0))) = 0)))
        = 0))) = 0))) = 0;
	WR10 : SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT (SIZEOF (QUERY (sspl <* QUERY (sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'SURFACE_STYLE_PARAMETER_LINE' IN TYPEOF (sses)) |
        NOT ((
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE' IN TYPEOF
        (sspl\surface_style_parameter_line.style_of_parameter_lines))
        AND
        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (sspl\surface_style_parameter_line.
        style_of_parameter_lines\curve_style.curve_colour)) = 1)
        AND
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (sspl\surface_style_parameter_line.
        style_of_parameter_lines\curve_style.curve_width))
        AND
        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'CURVE_STYLE_FONT', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF
        (sspl\surface_style_parameter_line.
        style_of_parameter_lines\curve_style.curve_font)) = 1))
        OR
        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE_RENDERING'
        IN TYPEOF
        (sspl\surface_style_parameter_line.style_of_parameter_lines))
        AND
        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (sspl\surface_style_parameter_line.style_of_parameter_lines\
        curve_style_rendering.rendering_properties.rendered_colour))
        = 1))) )) = 0))) = 0))) = 0))) = 0;
	WR11 : SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT (SIZEOF (QUERY (sscg <* QUERY (sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'SURFACE_STYLE_CONTROL_GRID' IN TYPEOF (sses)) |
        NOT ((
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE'
        IN TYPEOF (sscg\surface_style_control_grid.style_of_control_grid))
        AND
        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (sscg\surface_style_control_grid.
        style_of_control_grid\curve_style.curve_colour)) = 1)
        AND
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (sscg\surface_style_control_grid.
        style_of_control_grid\curve_style.curve_width))
        AND
        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'CURVE_STYLE_FONT', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF
        (sscg\surface_style_control_grid.
        style_of_control_grid\curve_style.curve_font)) = 1))
        OR
        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE_RENDERING'
        IN TYPEOF (sscg\surface_style_control_grid.style_of_control_grid))
        AND
        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (sscg\surface_style_control_grid.style_of_control_grid\
        curve_style_rendering.rendering_properties.rendered_colour))
        = 1))) )) = 0))) = 0))) = 0))) = 0;
	WR12 : SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT (SIZEOF (QUERY (sssh <* QUERY (sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'SURFACE_STYLE_SILHOUETTE' IN TYPEOF (sses)) |
        NOT ((
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE'
        IN TYPEOF (sssh\surface_style_silhouette.style_of_silhouette))
        AND
        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (sssh\surface_style_silhouette.
        style_of_silhouette\curve_style.curve_colour)) = 1)
        AND
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (sssh\surface_style_silhouette.
        style_of_silhouette\curve_style.curve_width))
        AND
        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'CURVE_STYLE_FONT', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF
        (sssh\surface_style_silhouette.
        style_of_silhouette\curve_style.curve_font)) = 1)) 
        OR
        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE_RENDERING'
        IN TYPEOF (sssh\surface_style_silhouette.style_of_silhouette))
        AND
        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (sssh\surface_style_silhouette.style_of_silhouette\
        curve_style_rendering.rendering_properties.rendered_colour))
        = 1))) )) = 0))) = 0))) = 0))) = 0;
	WR13 : SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT (SIZEOF (QUERY (sssc <* QUERY (sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'SURFACE_STYLE_SEGMENTATION_CURVE' IN TYPEOF (sses)) |
        NOT ((
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE'
        IN TYPEOF
        (sssc\surface_style_segmentation_curve.style_of_segmentation_curve))
        AND
        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve\curve_style.curve_colour)) = 1)
        AND
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve\curve_style.curve_width))
        AND
        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'CURVE_STYLE_FONT', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF
        (sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve\curve_style.curve_font)) = 1)) 
        OR
        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE_RENDERING'
        IN TYPEOF (sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve))
        AND
        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (sssc\surface_style_segmentation_curve.style_of_segmentation_curve\
        curve_style_rendering.rendering_properties.rendered_colour))
        = 1))) )) = 0))) = 0))) = 0))) = 0;
	WR14 : SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT (SIZEOF (QUERY (ssbd <* QUERY (sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'SURFACE_STYLE_BOUNDARY' IN TYPEOF (sses)) |
        NOT ((
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE'
        IN TYPEOF (ssbd\surface_style_boundary.style_of_boundary))
        AND
        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (ssbd\surface_style_boundary.
        style_of_boundary\curve_style.curve_colour)) = 1)
        AND
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (ssbd\surface_style_boundary.
        style_of_boundary\curve_style.curve_width))
        AND
        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'CURVE_STYLE_FONT', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF
        (ssbd\surface_style_boundary.
        style_of_boundary\curve_style.curve_font)) = 1)) 
        OR
        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE_RENDERING'
        IN TYPEOF (ssbd\surface_style_boundary.style_of_boundary))
        AND
        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (ssbd\surface_style_boundary.style_of_boundary\
        curve_style_rendering.rendering_properties.rendered_colour))
        = 1))) )) = 0))) = 0))) = 0))) = 0;
	WR15 : SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT (SIZEOF (QUERY (ssre <* QUERY (sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'SURFACE_STYLE_RENDERING' IN TYPEOF (sses)) |
        NOT
        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (ssre\surface_style_rendering.surface_colour)) = 1)))
        = 0))) = 0))) = 0))) = 0;
END_ENTITY;


ENTITY membership_of_maths_space_context;
	space_context : maths_space_context;
	value_context : maths_value_context;
END_ENTITY;


ENTITY mesh
	ABSTRACT SUPERTYPE OF ((ONEOF (structured_mesh, unstructured_mesh) ANDOR submesh))
	SUBTYPE OF (topological_representation_item);
	description : text;
	index_count : INTEGER;
END_ENTITY;


ENTITY mesh_connectivity
	ABSTRACT SUPERTYPE OF (ONEOF (matched_mesh_connection, mismatched_mesh_connection));
	name : label;
	description : text;
	id : identifier;
	current : mesh;
DERIVE
	index_count : INTEGER := current.index_count;
END_ENTITY;


ENTITY mesh_derived_maths_space
	SUBTYPE OF (maths_space);
	description : text;
	name : label;
	id : identifier;
	the_mesh : mesh;
	kind : mesh_maths_space_type;
END_ENTITY;


ENTITY mesh_function
	SUBTYPE OF (application_defined_function, unary_generic_expression);
	mesh : mesh;
	basis : LIST [0:?] OF mesh_function_basis;
	uniform : BOOLEAN;
	vertex_values : BOOLEAN;
DERIVE
	control_values : maths_function := SELF\unary_generic_expression.operand;
WHERE
	wr1 : function_is_table(control_values);
	wr2 : (uniform AND (SIZEOF(basis) = 1)) XOR
        (NOT uniform);
END_ENTITY;


ENTITY mesh_function_basis
	SUBTYPE OF (application_defined_function, unary_generic_expression);
	cell_topological_dimension : INTEGER;
	value_array_dimension : INTEGER;
	value_array_order : ARRAY [1:value_array_dimension] OF INTEGER;
DERIVE
	value_positions : maths_function := SELF\unary_generic_expression.operand;
WHERE
	value_positions_as_table : function_is_table(value_positions);
END_ENTITY;


ENTITY mesh_overset_hole
	SUBTYPE OF (mismatched_mesh_connection);
END_ENTITY;


ENTITY min_and_major_ply_orientation_basis
	SUBTYPE OF (representation_item_relationship, geometric_representation_item);
	SELF\representation_item_relationship.related_representation_item : axis2_placement_3d;
	SELF\representation_item_relationship.relating_representation_item : axis2_placement_3d;
DERIVE
	major_orientation_basis : axis2_placement_3d := SELF\representation_item_relationship.related_representation_item;
	minor_orientation_basis : axis2_placement_3d := SELF\representation_item_relationship.relating_representation_item;
END_ENTITY;


ENTITY minimum_function
	SUBTYPE OF (multiple_arity_function_call);
END_ENTITY;


ENTITY minus_expression
	SUBTYPE OF (binary_numeric_expression);
END_ENTITY;


ENTITY minus_function
	SUBTYPE OF (unary_function_call);
END_ENTITY;


ENTITY mismatched_donor_mesh
	ABSTRACT SUPERTYPE OF (ONEOF (structured_donor_mesh, unstructured_donor_mesh));
	donor : mesh;
INVERSE
	connect: mismatched_mesh_region FOR donor;
END_ENTITY;


ENTITY mismatched_mesh_connection
	ABSTRACT SUPERTYPE OF (ONEOF (mismatched_mesh_region, mesh_overset_hole))
	SUBTYPE OF (mesh_connectivity);
	points : indices_group;
	gridloc : mesh_location;
END_ENTITY;


ENTITY mismatched_mesh_region
	SUBTYPE OF (mismatched_mesh_connection);
	donor : mismatched_donor_mesh;
	kind : mismatched_region_type;
WHERE
	wr1 : donor.donor :<>: SELF\mesh_connectivity.current;
END_ENTITY;


ENTITY mod_expression
	SUBTYPE OF (binary_numeric_expression);
END_ENTITY;


ENTITY model_action_domain
	SUBTYPE OF (numerical_model);
	initial : model_state_domain;
	final : model_state_domain;
END_ENTITY;


ENTITY model_product_domain
	SUBTYPE OF (numerical_model);
	temporal_parts : LIST [0:?] OF model_action_domain;
END_ENTITY;


ENTITY model_product_domain_with_mesh
	SUBTYPE OF (model_product_domain);
	model_mesh : mesh;
END_ENTITY;


ENTITY model_property_distribution;
	creating_software : text;
	domain : numerical_model;
	range : general_property;
END_ENTITY;


ENTITY model_state_domain
	SUBTYPE OF (numerical_model);
END_ENTITY;


ENTITY modified_geometric_tolerance
	SUBTYPE OF (geometric_tolerance);
	modifier : limit_condition;
END_ENTITY;


ENTITY modified_solid
	ABSTRACT SUPERTYPE OF (ONEOF (edge_blended_solid, sculptured_solid, shelled_solid, modified_solid_with_placed_configuration))
	SUBTYPE OF (solid_model);
	rationale : text;
	base_solid : base_solid_select;
END_ENTITY;


ENTITY modified_solid_with_placed_configuration
	ABSTRACT SUPERTYPE OF (ONEOF (solid_with_depression, solid_with_protrusion, solid_with_shape_element_pattern))
	SUBTYPE OF (modified_solid);
	placing : axis2_placement_3d;
END_ENTITY;


ENTITY moments_of_inertia_representation
	SUBTYPE OF (representation);
WHERE
	WR1 : (SIZEOF(SELF.items) = 1) AND 
 (SIZEOF( QUERY( i <* SELF.items | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'COMPOUND_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  (i.name = 'moments of inertia matrix') )) = 1);
	WR2 : SIZEOF( QUERY( i <* SELF.items | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'COMPOUND_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'LIST_REPRESENTATION_ITEM' IN TYPEOF(i\compound_representation_item.item_element)) AND 
  value_range_aggregate_rep_item (i\compound_representation_item.item_element) )) = 1;
END_ENTITY;


ENTITY mult_expression
	SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;


ENTITY multi_language_attribute_assignment
	SUBTYPE OF (attribute_value_assignment);
	items : SET [1:?] OF multi_language_attribute_item;
DERIVE
	translation_language : language := language_indication[1]\attribute_classification_assignment.assigned_class;
INVERSE
	language_indication: SET [1:1] OF attribute_language_assignment FOR items;
WHERE
	WR1 : (SELF\attribute_value_assignment.role.name = 'alternate language');
	WR2 : SIZEOF( QUERY( ala <* language_indication |  
   (ala\attribute_classification_assignment.attribute_name = 'attribute_value') AND 
   (ala\attribute_classification_assignment.role.name='translated') )) = 1;
	WR3 : SELF\attribute_value_assignment.attribute_name <> '';
	WR4 : SIZEOF(QUERY(ci <* items |
SIZEOF(QUERY(ata <* USEDIN(ci, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT.ITEMS') |
(ata\attribute_value_assignment.attribute_name = SELF\attribute_value_assignment.attribute_name) AND 
(ata.translation_language :=: translation_language) ))>1 )) =0;
	WR5 : SIZEOF(QUERY(ci <* items |
SIZEOF(QUERY(ata <* USEDIN(ci, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS') |
 (ata\attribute_classification_assignment.role.name='primary') AND
 (ata\attribute_classification_assignment.attribute_name= SELF\attribute_value_assignment.attribute_name) AND 
 (ata\attribute_classification_assignment.assigned_class :=: translation_language) ))>0 )) =0;
END_ENTITY;


ENTITY multiple_arity_boolean_expression
	ABSTRACT SUPERTYPE OF (ONEOF (and_expression, or_expression))
	SUBTYPE OF (boolean_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF boolean_expression;
END_ENTITY;


ENTITY multiple_arity_function_call
	ABSTRACT SUPERTYPE OF (ONEOF (maximum_function, minimum_function))
	SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;


ENTITY multiple_arity_generic_expression
	ABSTRACT SUPERTYPE
	SUBTYPE OF (generic_expression);
	operands : LIST [2:?] OF generic_expression;
END_ENTITY;


ENTITY multiple_arity_numeric_expression
	ABSTRACT SUPERTYPE OF (ONEOF (plus_expression, mult_expression, multiple_arity_function_call))
	SUBTYPE OF (numeric_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF numeric_expression;
END_ENTITY;


ENTITY multiple_mesh_block;
	name : label;
	description : text;
	id : identifier;
	connectivities : LIST [0:?] OF mesh_connectivity;
END_ENTITY;


ENTITY name_assignment
	ABSTRACT SUPERTYPE;
	assigned_name : label;
DERIVE
	role : object_role := get_role(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;


ENTITY name_attribute;
	attribute_value : label;
	named_item : name_attribute_select;
END_ENTITY;


ENTITY named_unit
	SUPERTYPE OF ((ONEOF (si_unit, conversion_based_unit, context_dependent_unit) ANDOR ONEOF (length_unit, mass_unit, time_unit, electric_current_unit, thermodynamic_temperature_unit, amount_of_substance_unit, luminous_flux_unit, luminous_intensity_unit, plane_angle_unit, solid_angle_unit, ratio_unit)));
	dimensions : dimensional_exponents;
END_ENTITY;


ENTITY next_assembly_usage_occurrence
	SUBTYPE OF (assembly_component_usage);
END_ENTITY;


ENTITY no_symmetry_control
	SUBTYPE OF (symmetry_control);
END_ENTITY;


ENTITY nodal_dof_reduction
	SUBTYPE OF (constraint_element);
	required_node : node_output_reference;
	coordinate_system : fea_axis2_placement_3d;
	freedoms : SET [1:?] OF degree_of_freedom;
	description : text;
END_ENTITY;


ENTITY nodal_freedom_action_definition
	SUBTYPE OF (nodal_freedom_and_value_definition);
	action : action_type;
END_ENTITY;


ENTITY nodal_freedom_and_value_definition
	SUPERTYPE OF (ONEOF (nodal_freedom_values, nodal_freedom_action_definition))
	SUBTYPE OF (state_definition);
	node : node_output_reference;
	coordinate_system : fea_axis2_placement_3d;
	degrees_of_freedom : freedoms_list;
	values : LIST [1:?] OF measure_or_unspecified_value;
WHERE
	WR1 : SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (values);
END_ENTITY;


ENTITY nodal_freedom_values
	SUBTYPE OF (nodal_freedom_and_value_definition);
END_ENTITY;


ENTITY node
	SUPERTYPE OF ((node_with_vector ANDOR node_with_solution_coordinate_system))
	SUBTYPE OF (node_representation);
WHERE
	WR1 : SIZEOF (QUERY(item <* SELF\representation.items |
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT' 
              IN TYPEOF (item))) = 1;
END_ENTITY;


ENTITY node_analysis_message
	SUBTYPE OF (analysis_message);
	node : node_output_reference;
END_ENTITY;


ENTITY node_definition
	SUBTYPE OF (shape_aspect);
END_ENTITY;


ENTITY node_geometric_relationship;
	node_ref : node_or_node_group;
	item : analysis_item_within_representation;
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(item.item);
END_ENTITY;


ENTITY node_group
	SUBTYPE OF (fea_group);
	nodes : SET [1:?] OF node_representation;
END_ENTITY;


ENTITY node_representation
	SUPERTYPE OF (ONEOF (node, dummy_node, geometric_node))
	SUBTYPE OF (representation);
	model_ref : fea_model;
UNIQUE
	UR1 : model_ref, SELF\representation.name;
END_ENTITY;


ENTITY node_sequence;
	order_id : identifier;
	control_ref : control;
	purpose : text;
	nodes : LIST [1:?] OF node_representation;
UNIQUE
	UR1 : order_id, control_ref;
END_ENTITY;


ENTITY node_set
	SUBTYPE OF (geometric_representation_item);
	nodes : SET [1:?] OF node_representation;
WHERE
	WR1 : SIZEOF (QUERY (tmp <* nodes | 
               tmp\representation.context_of_items :<>:
               nodes[1]\representation.context_of_items)) = 0;
END_ENTITY;


ENTITY node_topological_relationship;
	item : analysis_item_within_representation;
	node_ref : node_representation;
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX' IN TYPEOF (item.item);
END_ENTITY;


ENTITY node_with_solution_coordinate_system
	SUBTYPE OF (node);
WHERE
	WR1 : ( (SIZEOF (QUERY(item <* SELF\representation.items |
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
              'FEA_AXIS2_PLACEMENT_3D' 
              IN TYPEOF (item))) = 1)
          AND
          (SELF\representation.context_of_items\
       geometric_representation_context.coordinate_space_dimension = 3) )
     OR
       ( (SIZEOF (QUERY(item <* SELF\representation.items |
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
              'FEA_AXIS2_PLACEMENT_2D' 
              IN TYPEOF (item))) = 1)
          AND
          (SELF\representation.context_of_items\
       geometric_representation_context.coordinate_space_dimension = 2) );
END_ENTITY;


ENTITY node_with_vector
	SUBTYPE OF (node);
WHERE
	WR1 : SIZEOF (QUERY(item <* SELF\representation.items |
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIRECTION' 
              IN TYPEOF (item))) = 1;
END_ENTITY;


ENTITY non_manifold_surface_shape_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 : SIZEOF (QUERY (it <* SELF.items |
       NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D'] * TYPEOF (it)) = 1)))
       = 0;
	WR2 : SIZEOF (QUERY (it <* SELF.items |
       SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'] * TYPEOF (it)) = 1)) > 0;
	WR3 : SIZEOF (QUERY (mi <* QUERY (it <* SELF.items |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF (it)) |
       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
       'NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION'
       IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))
       AND
       (SIZEOF(QUERY (mr_it <*
       mi\mapped_item.mapping_source.mapped_representation.items |
       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL'
       IN TYPEOF (mr_it)))) > 0 )))) = 0;
	WR4 : SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_SURFACE',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_FACE'] * TYPEOF (fa)) = 1)))
       = 0))) = 0))) = 0;
	WR5 : SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (f_sf <* QUERY (fa <* cfs.cfs_faces |
       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_SURFACE' IN TYPEOF (fa))) |
       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (f_sf))
       OR
       (nmsf_surface_check(f_sf\face_surface.face_geometry))))) = 0))) 
       = 0))) = 0;
	WR6 : SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (o_fa <* QUERY (fa <* cfs.cfs_faces |
       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_FACE' IN TYPEOF (fa))) |
       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF 
       (o_fa\oriented_face.face_element))
       OR
       (nmsf_surface_check
       (o_fa\oriented_face.face_element\face_surface.face_geometry)))))
       = 0))) = 0))) = 0;
	WR7 : SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (bnds <* fa.bounds |
       NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_LOOP']
       * TYPEOF (bnds.bound)) = 1))) = 0)))) = 0))) = 0))) = 0;
	WR8 : SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items|
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_CURVE' IN TYPEOF 
       (oe.edge_element)))) = 0))) = 0)))) = 0))) = 0))) = 0;
	WR9 : SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe_cv <* QUERY (oe <* 
       elp_fbnds\path.edge_list |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_CURVE' IN TYPEOF (oe.edge_element)) |
       NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONIC',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_REPLICA',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_CURVE_3D',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE'] * 
       TYPEOF (oe_cv.edge_element\edge_curve.edge_geometry)) 
       = 1))) = 0))) = 0)))) = 0))) = 0))) = 0;
	WR10 : SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT (nmsf_curve_check (oe.edge_element\edge_curve.edge_geometry)))) 
       = 0))) = 0)))) = 0))) = 0))) = 0;
	WR11 : SIZEOF (QUERY(fbsm <* QUERY (it <* SELF.items |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list|
       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF
       (oe.edge_element.edge_start))
       AND
       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN
       TYPEOF (oe.edge_element.edge_end))))) 
       = 0))) = 0)))) = 0))) = 0))) = 0;
	WR12 : SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT ((SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DEGENERATE_PCURVE',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_CURVE',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_SURFACE'] * TYPEOF
       (oe.edge_element.edge_start\vertex_point.vertex_geometry)) = 1)
       AND
       (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DEGENERATE_PCURVE',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_CURVE',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_SURFACE'] * TYPEOF
       (oe.edge_element.edge_end\vertex_point.vertex_geometry)) = 1
       )))) = 0))) = 0)))) = 0))) = 0))) = 0;
	WR13 : SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <* 
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |
       NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF
       (vlp_fbnds\vertex_loop.loop_vertex)))) = 0)))) = 0))) 
       = 0))) = 0;
	WR14 : SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <* 
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DEGENERATE_PCURVE',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_CURVE',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_SURFACE'] * TYPEOF
       (vlp_fbnds\vertex_loop.loop_vertex\vertex_point.vertex_geometry)) 
       = 1))) = 0)))) = 0))) = 0))) = 0;
END_ENTITY;


ENTITY normalized_maths_space_context
	SUBTYPE OF (defined_maths_space_context);
	normalization_basis : value_context_select;
END_ENTITY;


ENTITY not_expression
	SUBTYPE OF (unary_boolean_expression);
	SELF\unary_generic_expression.operand : boolean_expression;
END_ENTITY;


ENTITY null_representation_item
	SUBTYPE OF (representation_item);
END_ENTITY;


ENTITY numeric_defined_function
	ABSTRACT SUPERTYPE OF (ONEOF (integer_defined_function, real_defined_function))
	SUBTYPE OF (numeric_expression, defined_function);
END_ENTITY;


ENTITY numeric_expression
	ABSTRACT SUPERTYPE OF (ONEOF (simple_numeric_expression, unary_numeric_expression, binary_numeric_expression, multiple_arity_numeric_expression, length_function, value_function, numeric_defined_function))
	SUBTYPE OF (expression);
DERIVE
	is_int : LOGICAL := is_int_expr (SELF);
	sql_mappable : LOGICAL := is_SQL_mappable (SELF);
END_ENTITY;


ENTITY numeric_variable
	SUPERTYPE OF (ONEOF (int_numeric_variable, real_numeric_variable))
	SUBTYPE OF (simple_numeric_expression, variable);
WHERE
	WR1 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.INT_NUMERIC_VARIABLE' 
			IN TYPEOF(SELF) ) OR
			('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REAL_NUMERIC_VARIABLE' 
			IN TYPEOF(SELF) );
END_ENTITY;


ENTITY numerical_model;
	id : identifier;
	name : label;
	description : text;
	creating_software : text;
	intended_analysis_code : SET [1:?] OF text;
	analysis_type : text;
WHERE
	wr1 : temporal_spatial_domain_for_model(SELF);
END_ENTITY;


ENTITY object_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY;


ENTITY odd_function
	SUBTYPE OF (unary_boolean_expression);
	SELF\unary_generic_expression.operand : numeric_expression;
WHERE
	WR1 : is_int_expr(operand);
END_ENTITY;


ENTITY offset_curve_2d
	SUBTYPE OF (curve);
	basis_curve : curve;
	distance : length_measure;
	self_intersect : LOGICAL;
WHERE
	WR1 : basis_curve.dim = 2;
END_ENTITY;


ENTITY offset_curve_3d
	SUBTYPE OF (curve);
	basis_curve : curve;
	distance : length_measure;
	self_intersect : LOGICAL;
	ref_direction : direction;
WHERE
	WR1 : (basis_curve.dim = 3) AND (ref_direction.dim = 3);
END_ENTITY;


ENTITY offset_surface
	SUBTYPE OF (surface);
	basis_surface : surface;
	distance : length_measure;
	self_intersect : LOGICAL;
END_ENTITY;


ENTITY one_direction_repeat_factor
	SUBTYPE OF (geometric_representation_item);
	repeat_factor : vector;
END_ENTITY;


ENTITY open_shell
	SUBTYPE OF (connected_face_set);
END_ENTITY;


ENTITY or_expression
	SUBTYPE OF (multiple_arity_boolean_expression);
END_ENTITY;


ENTITY ordinal_date
	SUBTYPE OF (date);
	day_component : day_in_year_number;
WHERE
	WR1 : (NOT leap_year(SELF.year_component) AND { 1 <= day_component <= 365 }) OR (leap_year(SELF.year_component) AND { 1 <= day_component <= 366 });
END_ENTITY;


ENTITY ordinate_dimension
	SUBTYPE OF (projection_directed_callout);
END_ENTITY;


ENTITY organization;
	id : OPTIONAL identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY;


ENTITY organization_assignment
	ABSTRACT SUPERTYPE;
	assigned_organization : organization;
	role : organization_role;
END_ENTITY;


ENTITY organization_relationship;
	name : label;
	description : OPTIONAL text;
	relating_organization : organization;
	related_organization : organization;
END_ENTITY;


ENTITY organization_role;
	name : label;
DERIVE
	description : text := get_description_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;


ENTITY organizational_address
	SUBTYPE OF (address);
	organizations : SET [1:?] OF organization;
	description : OPTIONAL text;
END_ENTITY;


ENTITY organizational_project;
	name : label;
	description : OPTIONAL text;
	responsible_organizations : SET [1:?] OF organization;
DERIVE
	id : identifier := get_id_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;


ENTITY organizational_project_assignment
	ABSTRACT SUPERTYPE;
	assigned_organizational_project : organizational_project;
	role : organizational_project_role;
END_ENTITY;


ENTITY organizational_project_relationship;
	name : label;
	description : OPTIONAL text;
	relating_organizational_project : organizational_project;
	related_organizational_project : organizational_project;
END_ENTITY;


ENTITY organizational_project_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY;


ENTITY oriented_closed_shell
	SUBTYPE OF (closed_shell);
	closed_shell_element : closed_shell;
	orientation : BOOLEAN;
DERIVE
	SELF\connected_face_set.cfs_faces : SET [1:?] OF face := conditional_reverse(SELF.orientation,
                                   SELF.closed_shell_element.cfs_faces);
WHERE
	WR1 : NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_CLOSED_SHELL' 
                IN TYPEOF (SELF.closed_shell_element));
END_ENTITY;


ENTITY oriented_edge
	SUBTYPE OF (edge);
	edge_element : edge;
	orientation : BOOLEAN;
DERIVE
	SELF\edge.edge_end : vertex := boolean_choose (SELF.orientation,
                                            SELF.edge_element.edge_end,
                                            SELF.edge_element.edge_start);
	SELF\edge.edge_start : vertex := boolean_choose (SELF.orientation,
                                            SELF.edge_element.edge_start,
                                            SELF.edge_element.edge_end);
WHERE
	WR1 : NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_EDGE' IN TYPEOF (SELF.edge_element));
END_ENTITY;


ENTITY oriented_face
	SUBTYPE OF (face);
	face_element : face;
	orientation : BOOLEAN;
DERIVE
	SELF\face.bounds : SET [1:?] OF face_bound := conditional_reverse(SELF.orientation,SELF.face_element.bounds);
WHERE
	WR1 : NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_FACE' IN TYPEOF (SELF.face_element));
END_ENTITY;


ENTITY oriented_open_shell
	SUBTYPE OF (open_shell);
	open_shell_element : open_shell;
	orientation : BOOLEAN;
DERIVE
	SELF\connected_face_set.cfs_faces : SET [1:?] OF face := conditional_reverse(SELF.orientation,
                                      SELF.open_shell_element.cfs_faces);
WHERE
	WR1 : NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_OPEN_SHELL' 
                IN TYPEOF (SELF.open_shell_element));
END_ENTITY;


ENTITY oriented_path
	SUBTYPE OF (path);
	path_element : path;
	orientation : BOOLEAN;
DERIVE
	SELF\path.edge_list : LIST [1:?] OF  UNIQUE oriented_edge := conditional_reverse(SELF.orientation,
                                         SELF.path_element.edge_list);
WHERE
	WR1 : NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_PATH' IN TYPEOF (SELF.path_element));
END_ENTITY;


ENTITY oriented_surface
	SUBTYPE OF (surface);
	orientation : BOOLEAN;
END_ENTITY;


ENTITY outer_boundary_curve
	SUBTYPE OF (boundary_curve);
END_ENTITY;


ENTITY output_request_state
	SUBTYPE OF (state);
	steps : SET [1:?] OF control_analysis_step;
END_ENTITY;


ENTITY over_riding_styled_item
	SUBTYPE OF (styled_item);
	over_ridden_style : styled_item;
END_ENTITY;


ENTITY package_product_concept_feature
	SUBTYPE OF (product_concept_feature);
WHERE
	WR1 : NOT ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE' IN TYPEOF ( SELF ) );
	WR2 : SIZEOF ( QUERY 
									( 
										cfr <* USEDIN ( SELF , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP.' +'RELATING_PRODUCT_CONCEPT_FEATURE' ) 
										| 
										('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF (cfr ) ) 
										AND 
										( SIZEOF ( QUERY 
																( 
																	ipcf <* USEDIN ( cfr , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE.' +	'CONDITION' ) 
																	| 
																	'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( ipcf ) 
																)
															)= 1 
										)
									)
							)>0;
END_ENTITY;


ENTITY parabola
	SUBTYPE OF (conic);
	focal_dist : length_measure;
WHERE
	WR1 : focal_dist <> 0.0;
END_ENTITY;


ENTITY parallel_composed_function
	SUBTYPE OF (maths_function, multiple_arity_generic_expression);
	source_of_domain : maths_space_or_function;
	prep_functions : LIST [1:?] OF maths_function;
	final_function : maths_function_select;
DERIVE
	SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF generic_expression := convert_to_operands_prcmfn(source_of_domain, prep_functions, final_function);
WHERE
	WR1 : no_cyclic_domain_reference(source_of_domain, [SELF]);
	WR2 : expression_is_constant(domain_from(source_of_domain));
	WR3 : parallel_composed_function_domain_check(domain_from(source_of_domain),
       prep_functions);
	WR4 : parallel_composed_function_composability_check(prep_functions, final_function);
END_ENTITY;


ENTITY parallel_offset
	SUBTYPE OF (derived_shape_aspect);
	offset : measure_with_unit;
WHERE
	WR1 : SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;


ENTITY parallelism_tolerance
	SUBTYPE OF (geometric_tolerance_with_datum_reference);
WHERE
	WR1 : SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) < 3;
END_ENTITY;


ENTITY parametric_curve_3d_element_coordinate_direction
	SUBTYPE OF (fea_representation_item);
	orientation : direction;
WHERE
	WR1 : SELF\geometric_representation_item.dim=3;
END_ENTITY;


ENTITY parametric_curve_3d_element_coordinate_system
	SUBTYPE OF (fea_representation_item);
	direction : parametric_curve_3d_element_coordinate_direction;
END_ENTITY;


ENTITY parametric_representation_context
	SUBTYPE OF (representation_context);
END_ENTITY;


ENTITY parametric_surface_2d_element_coordinate_system
	SUBTYPE OF (fea_representation_item);
END_ENTITY;


ENTITY parametric_surface_3d_element_coordinate_system
	SUBTYPE OF (fea_representation_item);
	axis : INTEGER;
	angle : plane_angle_measure;
WHERE
	WR1 : (axis >= 1) AND (axis <= 2);
END_ENTITY;


ENTITY parametric_volume_2d_element_coordinate_system
	SUBTYPE OF (fea_representation_item);
	axis : INTEGER;
	angle : plane_angle_measure;
WHERE
	WR1 : (axis >= 1) AND (axis <= 2);
END_ENTITY;


ENTITY parametric_volume_3d_element_coordinate_system
	SUBTYPE OF (fea_representation_item);
	axis_1 : INTEGER;
	axis_2 : INTEGER;
	eu_angles : euler_angles;
WHERE
	WR1 : (axis_1 >= 1) AND (axis_1 <= 3) AND
        (axis_2 >= 1) AND (axis_2 <= 3) AND
        NOT (axis_1 = axis_2);
END_ENTITY;


ENTITY part_laminate_table
	SUPERTYPE OF (ONEOF (composite_assembly_table, ply_laminate_table))
	SUBTYPE OF (laminate_table);
END_ENTITY;


ENTITY partial_derivative_expression
	SUBTYPE OF (unary_generic_expression);
	d_variables : LIST [1:?] OF maths_variable;
	extension : extension_options;
DERIVE
	derivand : generic_expression := SELF\unary_generic_expression.operand;
WHERE
	WR1 : has_values_space (derivand);
	WR2 : space_is_continuum (values_space_of (derivand));
	WR3 : SIZEOF (QUERY (vbl <* d_variables | (NOT subspace_of (values_space_of (vbl),
    the_reals)) AND (NOT subspace_of (values_space_of (vbl), the_complex_numbers))
    )) = 0;
END_ENTITY;


ENTITY partial_derivative_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	d_variables : LIST [1:?] OF input_selector;
	extension : extension_options;
	SELF\unary_generic_expression.operand : maths_function;
DERIVE
	derivand : maths_function := SELF\unary_generic_expression.operand;
WHERE
	WR1 : space_is_continuum (derivand.range);
	WR2 : partial_derivative_check (derivand.domain, d_variables);
END_ENTITY;


ENTITY partial_document_with_structured_text_representation_assignment
	SUBTYPE OF (applied_document_usage_constraint_assignment, characterized_object);
END_ENTITY;


ENTITY path
	SUPERTYPE OF (ONEOF (edge_loop, oriented_path))
	SUBTYPE OF (topological_representation_item);
	edge_list : LIST [1:?] OF  UNIQUE oriented_edge;
WHERE
	WR1 : path_head_to_tail(SELF);
END_ENTITY;


ENTITY pcurve
	SUBTYPE OF (curve);
	basis_surface : surface;
	reference_to_curve : definitional_representation;
WHERE
	WR1 : SIZEOF(reference_to_curve\representation.items) = 1;
	WR2 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE' IN TYPEOF
                    (reference_to_curve\representation.items[1]);
	WR3 : reference_to_curve\representation.items[1]\
                               geometric_representation_item.dim =2;
END_ENTITY;


ENTITY percentage_laminate_definition
	SUBTYPE OF (product_definition);
WHERE
	WR1 : SIZEOF (QUERY (pdr <* USEDIN (SELF, 
                             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                             'PRODUCT_DEFINITION_RELATIONSHIP.' +
                             'RELATING_PRODUCT_DEFINITION') |
                             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                             'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN
                             TYPEOF (pdr))) > 0;
END_ENTITY;


ENTITY percentage_laminate_table
	SUBTYPE OF (zone_structural_makeup);
END_ENTITY;


ENTITY percentage_ply_definition
	SUBTYPE OF (product_definition);
WHERE
	WR1 : SIZEOF (QUERY (pdr <* USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
        'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') |
        ('STRUCTURAL_ANALYSIS_DESIGN.PERCENTAGE_LAMINATE_DEFINITION' 
        IN TYPEOF (pdr.related_product_definition)) AND
        (pdr.name = 'makeup and properties'))) = 0;
END_ENTITY;


ENTITY perpendicular_to
	SUBTYPE OF (derived_shape_aspect);
WHERE
	WR1 : SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;


ENTITY perpendicularity_tolerance
	SUBTYPE OF (geometric_tolerance_with_datum_reference);
WHERE
	WR1 : SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) <= 3;
END_ENTITY;


ENTITY person;
	id : identifier;
	last_name : OPTIONAL label;
	first_name : OPTIONAL label;
	middle_names : OPTIONAL LIST [1:?] OF label;
	prefix_titles : OPTIONAL LIST [1:?] OF label;
	suffix_titles : OPTIONAL LIST [1:?] OF label;
WHERE
	WR1 : EXISTS(last_name) OR EXISTS(first_name);
END_ENTITY;


ENTITY person_and_organization;
	the_person : person;
	the_organization : organization;
DERIVE
	description : text := get_description_value(SELF);
	name : label := get_name_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
	WR2 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;


ENTITY person_and_organization_address
	SUBTYPE OF (organizational_address, personal_address);
	SELF\organizational_address.organizations : SET [1:1] OF organization;
	SELF\personal_address.people : SET [1:1] OF person;
WHERE
	WR1 : SIZEOF(QUERY(pao <* USEDIN (SELF\personal_address.people[1], 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PERSON_AND_ORGANIZATION.THE_PERSON') | pao.the_organization :=: SELF\organizational_address.organizations[1])) = 1;
END_ENTITY;


ENTITY person_and_organization_assignment
	ABSTRACT SUPERTYPE;
	assigned_person_and_organization : person_and_organization;
	role : person_and_organization_role;
END_ENTITY;


ENTITY person_and_organization_role;
	name : label;
DERIVE
	description : text := get_description_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;


ENTITY personal_address
	SUBTYPE OF (address);
	people : SET [1:?] OF person;
	description : OPTIONAL text;
END_ENTITY;


ENTITY physical_action_domain
	SUBTYPE OF (temporal_spatial_domain);
	initial : physical_state_domain;
	final : physical_state_domain;
END_ENTITY;


ENTITY physical_breakdown_context
	SUBTYPE OF (breakdown_context);
END_ENTITY;


ENTITY physical_element_usage
	SUBTYPE OF (breakdown_element_usage);
END_ENTITY;


ENTITY physical_product_domain
	SUBTYPE OF (temporal_spatial_domain);
	temporal_parts : SET [0:?] OF physical_action_domain;
END_ENTITY;


ENTITY physical_quantity_instance
	SUBTYPE OF (general_property, class);
END_ENTITY;


ENTITY physical_quantity_range
	SUBTYPE OF (physical_quantity_space);
END_ENTITY;


ENTITY physical_quantity_space
	SUBTYPE OF (general_property, class);
END_ENTITY;


ENTITY physical_quantity_symmetry
	SUBTYPE OF (general_property, class);
END_ENTITY;


ENTITY physical_quantity_symmetry_by_library_reference
	SUBTYPE OF (physical_quantity_symmetry, externally_defined_item);
END_ENTITY;


ENTITY physical_state_domain
	SUBTYPE OF (temporal_spatial_domain);
END_ENTITY;


ENTITY picture_representation
	SUBTYPE OF (presentation_view);
	SELF\representation.items : SET [2:?] OF picture_representation_item_select;
INVERSE
	size: presentation_size FOR unit;
WHERE
	WR1 : SIZEOF(QUERY(item <* items | 
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM' IN TYPEOF(item))) = 1;
	WR2 : SIZEOF (QUERY (se <* QUERY (item <* SELF.items 
                   | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM' IN TYPEOF (item))) 
         | NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PICTURE_REPRESENTATION_ITEM' 
                IN TYPEOF (se\styled_item.item)) )) = 0;
END_ENTITY;


ENTITY picture_representation_item
	ABSTRACT SUPERTYPE OF (ONEOF (externally_defined_picture_representation_item, predefined_picture_representation_item))
	SUBTYPE OF (bytes_representation_item);
END_ENTITY;


ENTITY placed_datum_target_feature
	SUBTYPE OF (datum_target);
DERIVE
	representation_associations : SET [0:?] OF property_definition_representation := get_shape_aspect_property_definition_representations(SELF);
WHERE
	WR1 : SELF.description IN ['point','line','rectangle','circle','circular curve'];
	WR2 : SIZEOF (QUERY (pdr <* representation_associations | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN TYPEOF (pdr.used_representation) )) = 1;
	WR3 : valid_datum_target_parameters(SELF);
END_ENTITY;


ENTITY placed_feature
	SUBTYPE OF (shape_aspect);
END_ENTITY;


ENTITY placement
	SUPERTYPE OF (ONEOF (axis1_placement, axis2_placement_2d, axis2_placement_3d))
	SUBTYPE OF (geometric_representation_item);
	location : cartesian_point;
END_ENTITY;


ENTITY planar_box
	SUBTYPE OF (planar_extent);
	placement : axis2_placement_3d;
END_ENTITY;


ENTITY planar_extent
	SUBTYPE OF (geometric_representation_item);
	size_in_x : length_measure;
	size_in_y : length_measure;
END_ENTITY;


ENTITY plane
	SUBTYPE OF (elementary_surface);
END_ENTITY;


ENTITY plane_2d_element_property
	SUPERTYPE OF (simple_plane_2d_element_property);
	depth : context_dependent_measure;
END_ENTITY;


ENTITY plane_angle_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLANE_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY plane_angle_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;


ENTITY plane_curve_2d_element_descriptor
	SUBTYPE OF (element_descriptor);
	purpose : SET [1:?] OF SET [1:?] OF curve_element_purpose;
	assumption : plane_2d_element_purpose;
END_ENTITY;


ENTITY plane_curve_2d_element_representation
	SUBTYPE OF (element_representation);
	model_ref : fea_model_2d;
	element_descriptor : plane_curve_2d_element_descriptor;
	property : curve_2d_element_property;
	depth_property : plane_2d_element_property;
	material : element_material;
UNIQUE
	UR1 : model_ref, SELF\representation.name;
WHERE
	WR1 : model_ref.type_of_2d_analysis = planar;
	WR2 : SIZEOF (QUERY(item <* SELF\representation.items |
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
              'CURVE_2D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) = 1;
	WR3 : SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_MASS_DENSITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_AREA_DENSITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_MOISTURE_ABSORPTION'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
	WR4 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items);
	FU1 : required_0d_nodes (
        SELF\element_representation.node_list);
END_ENTITY;


ENTITY plane_surface_2d_element_descriptor
	SUBTYPE OF (element_descriptor);
	purpose : SET [1:?] OF SET [1:?] OF surface_element_purpose;
	assumption : plane_2d_element_purpose;
END_ENTITY;


ENTITY plane_surface_2d_element_representation
	SUBTYPE OF (element_representation);
	model_ref : fea_model_2d;
	element_descriptor : plane_surface_2d_element_descriptor;
	property : surface_element_property;
	depth_property : plane_2d_element_property;
	material : element_material;
UNIQUE
	UR1 : model_ref, SELF\representation.name;
WHERE
	WR1 : model_ref.type_of_2d_analysis = planar;
	WR2 : SIZEOF (QUERY(item <* SELF\representation.items |
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
              'PARAMETRIC_SURFACE_2D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) +
       SIZEOF (QUERY(item <* SELF\representation.items |
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
              'ALIGNED_SURFACE_2D_ELEMENT_COORDINATE_SYSTEM' 
              IN TYPEOF (item))) = 1;
	WR3 : SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_MASS_DENSITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_AREA_DENSITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_MOISTURE_ABSORPTION',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_SHELL_MEMBRANE_STIFFNESS',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_SHELL_BENDING_STIFFNESS',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_SHELL_MEMBRANE_BENDING_COUPLING_STIFFNESS',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_SHELL_SHEAR_STIFFNESS'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
	WR4 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items);
	FU1 : required_1d_nodes (
        SELF\element_representation.node_list,
        element_descriptor\element_descriptor.topology_order);
END_ENTITY;


ENTITY plane_volume_2d_element_descriptor
	SUBTYPE OF (element_descriptor);
	purpose : SET [1:?] OF SET [1:?] OF volume_element_purpose;
	shape : element_2d_shape;
	assumption : plane_2d_element_purpose;
END_ENTITY;


ENTITY plane_volume_2d_element_representation
	SUBTYPE OF (element_representation);
	model_ref : fea_model_2d;
	element_descriptor : plane_volume_2d_element_descriptor;
	depth_property : plane_2d_element_property;
	material : element_material;
UNIQUE
	UR1 : model_ref, SELF\representation.name;
WHERE
	WR1 : model_ref.type_of_2d_analysis = planar;
	WR2 : SIZEOF (QUERY(item <* SELF\representation.items |
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
              'PARAMETRIC_VOLUME_2D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) +
       SIZEOF (QUERY(item <* SELF\representation.items |
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
              'ARBITRARY_VOLUME_2D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) = 1;
	WR3 : SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_MASS_DENSITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_AREA_DENSITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_MOISTURE_ABSORPTION'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
	WR4 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items);
	FU1 : required_2d_nodes (
        SELF\element_representation.node_list,
        element_descriptor.shape,
        element_descriptor\element_descriptor.topology_order);
END_ENTITY;


ENTITY plus_expression
	SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;


ENTITY plus_minus_tolerance;
	range : tolerance_method_definition;
	toleranced_dimension : dimensional_characteristic;
UNIQUE
	UR1 : toleranced_dimension;
END_ENTITY;


ENTITY ply_laminate_definition
	SUBTYPE OF (product_definition);
WHERE
	WR1 : SIZEOF (QUERY (pdr <* USEDIN (SELF, 
                             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                             'PRODUCT_DEFINITION_RELATIONSHIP.' +
                             'RELATING_PRODUCT_DEFINITION') |
                             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                             'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN
                             TYPEOF (pdr))) = 1;
END_ENTITY;


ENTITY ply_laminate_sequence_definition
	SUBTYPE OF (product_definition);
WHERE
	WR1 : SIZEOF (QUERY (pdr <* USEDIN (SELF, 
                             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                             'PRODUCT_DEFINITION_RELATIONSHIP.' +
                             'RELATING_PRODUCT_DEFINITION') |
                             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                             'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN
                             TYPEOF (pdr))) > 0;
END_ENTITY;


ENTITY ply_laminate_table
	SUBTYPE OF (part_laminate_table);
END_ENTITY;


ENTITY point
	SUPERTYPE OF (ONEOF (cartesian_point, point_on_curve, point_on_surface, point_replica, degenerate_pcurve))
	SUBTYPE OF (geometric_representation_item);
END_ENTITY;


ENTITY point_and_vector
	SUBTYPE OF (compound_representation_item, geometric_representation_item);
	SELF\compound_representation_item.item_element : point_and_vector_members;
END_ENTITY;


ENTITY point_constraint
	SUBTYPE OF (constraint_element);
	required_point : analysis_item_within_representation;
	coordinate_system : fea_axis2_placement_3d;
	freedoms_and_coefficients : SET [1:?] OF freedom_and_coefficient;
	description : text;
WHERE
	WR1 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT' IN TYPEOF (required_point.item)) OR
       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF (required_point.item));
END_ENTITY;


ENTITY point_element_matrix
	SUPERTYPE OF (ONEOF (stationary_mass, grounded_spring, grounded_damper));
END_ENTITY;


ENTITY point_element_representation
	SUBTYPE OF (element_representation);
	model_ref : fea_model;
	matrix_set : SET [1:?] OF point_element_matrix;
UNIQUE
	UR1 : model_ref, SELF\representation.name;
WHERE
	WR1 : SIZEOF (QUERY(item <* SELF\representation.items |
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
              'FEA_AXIS2_PLACEMENT_3D'
              IN TYPEOF (item))) = 1;
	FU1 : required_0d_nodes (
        SELF\element_representation.node_list);
END_ENTITY;


ENTITY point_freedom_action_definition
	SUBTYPE OF (point_freedom_and_value_definition);
	action : action_type;
END_ENTITY;


ENTITY point_freedom_and_value_definition
	SUPERTYPE OF (ONEOF (point_freedom_values, point_freedom_action_definition))
	SUBTYPE OF (state_definition);
	required_point : analysis_item_within_representation;
	coordinate_system : fea_axis2_placement_3d;
	degrees_of_freedom : freedoms_list;
	values : LIST [1:?] OF measure_or_unspecified_value;
WHERE
	WR1 : SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (values);
	WR2 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT' IN TYPEOF (required_point.item)) OR
       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF (required_point.item));
END_ENTITY;


ENTITY point_freedom_values
	SUBTYPE OF (point_freedom_and_value_definition);
END_ENTITY;


ENTITY point_on_curve
	SUBTYPE OF (point);
	basis_curve : curve;
	point_parameter : parameter_value;
END_ENTITY;


ENTITY point_on_surface
	SUBTYPE OF (point);
	basis_surface : surface;
	point_parameter_u : parameter_value;
	point_parameter_v : parameter_value;
END_ENTITY;


ENTITY point_path
	SUBTYPE OF (compound_representation_item, geometric_representation_item);
	SELF\compound_representation_item.item_element : point_path_members;
END_ENTITY;


ENTITY point_replica
	SUBTYPE OF (point);
	parent_pt : point;
	transformation : cartesian_transformation_operator;
WHERE
	WR1 : transformation.dim = parent_pt.dim;
	WR2 : acyclic_point_replica (SELF,parent_pt);
END_ENTITY;


ENTITY point_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 : SIZEOF(QUERY(it <* SELF\representation.items | ( NOT (SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NODE_SET', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'FEA_AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1)))) = 0;
	WR2 : SIZEOF(QUERY(it <* SELF\representation.items | (SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NODE_SET', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'] * TYPEOF(it)) = 1))) >= 1;
END_ENTITY;


ENTITY point_style
	SUBTYPE OF (founded_item);
	name : label;
	marker : marker_select;
	marker_size : size_select;
	marker_colour : colour;
END_ENTITY;


ENTITY polar_complex_number_literal
	SUBTYPE OF (generic_literal);
	radius : REAL;
	angle : REAL;
WHERE
	WR1 : radius >= 0;
	WR2 : { 0 <= angle < 2*PI };
END_ENTITY;


ENTITY polar_complex_number_region
	SUBTYPE OF (maths_space, generic_literal);
	centre : complex_number_literal;
	distance_constraint : real_interval;
	direction_constraint : finite_real_interval;
WHERE
	WR1 : min_exists(distance_constraint) AND (real_min(distance_constraint) >= 0.0);
	WR2 : {-PI <= direction_constraint.min < PI};
	WR3 : direction_constraint.max - direction_constraint.min <= 2.0*PI;
	WR4 : (direction_constraint.max - direction_constraint.min < 2.0*PI) OR
       (direction_constraint.min_closure = open);
	WR5 : (direction_constraint.max - direction_constraint.min < 2.0*PI) OR
       (direction_constraint.max_closure = open) OR
       (direction_constraint.min = -PI);
	WR6 : (real_min(distance_constraint) > 0.0) OR max_exists(distance_constraint) OR
       (direction_constraint.max - direction_constraint.min < 2.0*PI) OR
       (direction_constraint.max_closure = open);
END_ENTITY;


ENTITY polar_point
	SUBTYPE OF (cartesian_point);
	r : length_measure;
	theta : plane_angle_measure;
DERIVE
	SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure := [r*cos(theta), r*sin(theta)];
WHERE
	WR1 : r >= 0.0;
END_ENTITY;


ENTITY poly_loop
	SUBTYPE OF (loop, geometric_representation_item);
	polygon : LIST [3:?] OF  UNIQUE cartesian_point;
END_ENTITY;


ENTITY polyline
	SUBTYPE OF (bounded_curve);
	points : LIST [2:?] OF cartesian_point;
END_ENTITY;


ENTITY position_tolerance
	SUBTYPE OF (geometric_tolerance);
WHERE
	WR1 : NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF)) OR ( SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) <= 3);
END_ENTITY;


ENTITY positioned_sketch
	SUBTYPE OF (geometric_representation_item);
	sketch_basis : sketch_basis_select;
	auxiliary_elements : SET [0:?] OF auxiliary_geometric_representation_item;
WHERE
	WR1 : NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_BOUNDED_SURFACE' IN 
    TYPEOF(sketch_basis)) AND NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLANE' IN
    TYPEOF(sketch_basis\curve_bounded_surface.basis_surface)));
	WR2 : NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_SURFACE' IN TYPEOF(sketch_basis)) AND
    NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLANE' IN TYPEOF(sketch_basis\face_surface.face_geometry)));
	WR3 : SIZEOF(QUERY(q <* auxiliary_elements | (SIZEOF(TYPEOF(q) * 
    ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT','AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE']) = 0))) = 0;
	WR4 : SIZEOF(QUERY(q <* auxiliary_elements | 
    q\geometric_representation_item.dim <> 3)) = 0;
END_ENTITY;


ENTITY possessed_physical_quantity_space
	SUBTYPE OF (general_property_association);
	SELF\general_property_association.base_definition : physical_quantity_space;
WHERE
	link_to_possession : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CLASS_OF_POSSESSION_OF_PROPERTY_BY_ACTIVITY' IN TYPEOF(SELF\general_property_association.derived_definition)) OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CLASS_OF_POSSESSION_OF_PROPERTY_BY_PRODUCT' IN TYPEOF(SELF\general_property_association.derived_definition));
END_ENTITY;


ENTITY power_expression
	SUBTYPE OF (binary_numeric_expression);
END_ENTITY;


ENTITY power_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POWER_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY power_unit
	SUBTYPE OF (derived_unit);
WHERE
	WR1 : derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.watt);
END_ENTITY;


ENTITY pre_defined_colour
	SUBTYPE OF (pre_defined_item, colour);
END_ENTITY;


ENTITY pre_defined_curve_font
	SUBTYPE OF (pre_defined_item);
END_ENTITY;


ENTITY pre_defined_dimension_symbol
	SUBTYPE OF (pre_defined_symbol);
WHERE
	WR1 : SELF.name IN [ 'arc length' , 'conical taper' , 'counterbore' , 'countersink' , 'depth' , 'diameter' , 'plus minus' , 'radius' , 'slope' , 'spherical diameter' , 'spherical radius' , 'square'];
END_ENTITY;


ENTITY pre_defined_geometrical_tolerance_symbol
	SUBTYPE OF (pre_defined_symbol);
WHERE
	WR1 : SELF.name IN ['angularity' , 'basic dimension' , 'blanked datum reference' , 'circular runout' , 'circularity' , 'concentricity' , 'cylindricity' , 'datum target identification' , 'diameter' , 'filled datum reference' , 'flatness' , 'least material condition' , 'maximum material condition' , 'parallelism' , 'perpendicularity' , 'position' , 'profile of a line' , 'profile of a surface' , 'projected tolerance zone' , 'regardless of feature size' , 'straightness' , 'symmetry' , 'total runout' ];
END_ENTITY;


ENTITY pre_defined_item;
	name : label;
END_ENTITY;


ENTITY pre_defined_marker
	SUBTYPE OF (pre_defined_item);
END_ENTITY;


ENTITY pre_defined_point_marker_symbol
	SUBTYPE OF (pre_defined_marker, pre_defined_symbol);
WHERE
	WR1 : SELF.name IN ['asterisk','circle','dot','plus','square','triangle','x'];
END_ENTITY;


ENTITY pre_defined_surface_condition_symbol
	SUBTYPE OF (pre_defined_symbol);
WHERE
	WR1 : SELF.name IN ['000' , '010' , '020' , '030' , '040' , '050' , '060' , '070' , '001' , '011' , '021' , '031' , '041' , '051' , '061' , '071' , '100' , '110' , '120' , '130' , '140' , '150' , '160' , '170' , '101' , '111' , '121' , '131' , '141' , '151' , '161' , '171' , '200' , '210' , '220' , '230' , '240' , '250' , '260' , '270' , '201' , '211' , '221' , '231' , '241' , '251' , '261' , '271'];
END_ENTITY;


ENTITY pre_defined_surface_side_style
	SUBTYPE OF (pre_defined_item);
END_ENTITY;


ENTITY pre_defined_symbol
	SUBTYPE OF (pre_defined_item);
END_ENTITY;


ENTITY pre_defined_terminator_symbol
	SUBTYPE OF (pre_defined_symbol);
WHERE
	WR1 : SELF.name IN ['blanked arrow', 'blanked box', 'blanked dot', 'blanked triangle', 'dimension origin', 'filled arrow', 'filled box', 'filled dot', 'integral symbol', 'open arrow', 'slash', 'unfilled arrow', 'unfilled triangle', 'filled triangle'];
END_ENTITY;


ENTITY pre_defined_text_font
	SUBTYPE OF (pre_defined_item);
END_ENTITY;


ENTITY pre_defined_tile
	SUBTYPE OF (pre_defined_item);
END_ENTITY;


ENTITY precision_qualifier;
	precision_value : INTEGER;
END_ENTITY;


ENTITY predefined_picture_representation_item
	SUBTYPE OF (picture_representation_item);
WHERE
	WR1 : SELF\representation_item.name IN pre_defined_picture_representation_types;
END_ENTITY;


ENTITY presentation_area
	SUBTYPE OF (presentation_representation);
WHERE
	WR1 : ((SIZEOF (QUERY (ais <* USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                                 'AREA_IN_SET.AREA') | 
             SIZEOF (USEDIN (ais, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                  'PRESENTATION_SIZE.UNIT')) =1)) > 0) OR
            (SIZEOF (USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                   'PRESENTATION_SIZE.UNIT')) =1));
END_ENTITY;


ENTITY presentation_layer_assignment;
	name : label;
	description : text;
	assigned_items : SET [1:?] OF layered_item;
END_ENTITY;


ENTITY presentation_representation
	SUPERTYPE OF (ONEOF (presentation_area, presentation_view))
	SUBTYPE OF (representation);
	SELF\representation.context_of_items : geometric_representation_context;
WHERE
	WR1 : SELF\representation.
           context_of_items\geometric_representation_context.
           coordinate_space_dimension = 2;
	WR2 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRESENTATION_AREA' IN TYPEOF (SELF))
           OR
           (SIZEOF (QUERY (prr <* USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                                'REPRESENTATION_RELATIONSHIP.REP_2') | 
           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRESENTATION_REPRESENTATION' IN
           TYPEOF (prr\representation_relationship.rep_1))) > 0)
           OR 
           (SIZEOF(QUERY( rm <* USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 
                                             'REPRESENTATION_MAP.'+ 
                                             'MAPPED_REPRESENTATION') | 
           SIZEOF(QUERY( mi <* USEDIN(rm, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
                                          'MAPPED_ITEM.'+
                                          'MAPPING_SOURCE') |   
           SIZEOF(QUERY( rep <* using_representations (mi) |                              
                                        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
                                        'PRESENTATION_REPRESENTATION' IN 
                                        TYPEOF (rep))) > 0
           )) > 0))  
           > 0);
END_ENTITY;


ENTITY presentation_set;
INVERSE
	areas: SET [1:?] OF area_in_set FOR in_set;
END_ENTITY;


ENTITY presentation_size;
	unit : presentation_size_assignment_select;
	size : planar_box;
UNIQUE
	UR1 : unit;
WHERE
	WR1 : (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRESENTATION_REPRESENTATION'
           IN TYPEOF (SELF.unit)) AND
           item_in_context (SELF.size, 
                            SELF.unit\representation.context_of_items)
           )
           OR
           (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AREA_IN_SET'
           IN TYPEOF (SELF.unit)) AND
           (SIZEOF (QUERY ( ais <* SELF.unit\area_in_set.in_set.areas |
                NOT item_in_context (SELF.size, ais.area\representation.
                                                context_of_items) )) = 0));
END_ENTITY;


ENTITY presentation_style_assignment
	SUBTYPE OF (founded_item);
	styles : SET [1:?] OF presentation_style_select;
WHERE
	WR1 : SIZEOF (QUERY (style1 <* SELF.styles |
           NOT (SIZEOF (QUERY (style2 <* (SELF.styles - style1) |
           NOT ((TYPEOF (style1) <> TYPEOF (style2)) OR
             (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                       'SURFACE_STYLE_USAGE',
                       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
                       'EXTERNALLY_DEFINED_STYLE'] *
                     TYPEOF (style1)) = 1)
           ))) = 0
         ))) = 0;
	WR2 : SIZEOF (QUERY (style1 <* SELF.styles |
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE' IN
         TYPEOF(style1)
         )) <= 2;
	WR3 : SIZEOF (QUERY (style1 <* SELF.styles |
         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE' IN TYPEOF (style1)) AND 
         (SIZEOF (QUERY (style2 <* (SELF.styles - style1) |
           ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE' IN TYPEOF (style2)) AND 
           ((style1\surface_style_usage.side = both) OR 
           (style2\surface_style_usage.side = both) OR 
           (style1\surface_style_usage.side = style2\surface_style_usage.side)) )) > 0))) = 0;
END_ENTITY;


ENTITY presentation_style_by_context
	SUBTYPE OF (presentation_style_assignment);
	style_context : style_context_select;
END_ENTITY;


ENTITY presentation_view
	SUBTYPE OF (presentation_representation);
END_ENTITY;


ENTITY presented_item
	ABSTRACT SUPERTYPE;
END_ENTITY;


ENTITY presented_item_representation;
	presentation : presentation_representation_select;
	item : presented_item;
END_ENTITY;


ENTITY pressure_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRESSURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY pressure_unit
	SUBTYPE OF (derived_unit);
WHERE
	WR1 : derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.pascal);
END_ENTITY;


ENTITY procedural_representation
	SUBTYPE OF (representation);
	SELF\representation.items : SET [1:?] OF procedural_representation_sequence;
END_ENTITY;


ENTITY procedural_representation_sequence
	SUBTYPE OF (representation_item);
	elements : LIST [1:?] OF representation_item;
	suppressed_items : SET [0:?] OF representation_item;
	rationale : text;
WHERE
	WR1 : SIZEOF(QUERY(q <* suppressed_items | NOT (q IN elements))) = 0;
END_ENTITY;


ENTITY procedural_shape_representation
	SUBTYPE OF (procedural_representation, shape_representation);
	SELF\representation.items : SET [1:?] OF procedural_shape_representation_sequence;
END_ENTITY;


ENTITY procedural_shape_representation_sequence
	SUBTYPE OF (geometric_representation_item, procedural_representation_sequence);
WHERE
	WR1 : SIZEOF(QUERY(q <* SELF\procedural_representation_sequence.elements
    | NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHAPE_REPRESENTATION_ITEM'
    IN TYPEOF(q)))) = 0;
END_ENTITY;


ENTITY product;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	frame_of_reference : SET [1:?] OF product_context;
END_ENTITY;


ENTITY product_category;
	name : label;
	description : OPTIONAL text;
DERIVE
	id : identifier := get_id_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;


ENTITY product_category_relationship;
	name : label;
	description : OPTIONAL text;
	category : product_category;
	sub_category : product_category;
WHERE
	WR1 : acyclic_product_category_relationship(SELF, [SELF.sub_category]);
END_ENTITY;


ENTITY product_class
	SUBTYPE OF (product_concept, characterized_object);
END_ENTITY;


ENTITY product_concept;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	market_context : product_concept_context;
UNIQUE
	UR1 : id;
END_ENTITY;


ENTITY product_concept_context
	SUBTYPE OF (application_context_element);
	market_segment_type : label;
END_ENTITY;


ENTITY product_concept_feature;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY;


ENTITY product_concept_feature_association;
	name : label;
	description : OPTIONAL text;
	concept : product_concept;
	feature : product_concept_feature;
END_ENTITY;


ENTITY product_concept_feature_category
	SUBTYPE OF (group);
WHERE
	WR1 : SIZEOF(QUERY
									( 
										aga <* USEDIN( SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP' ) 
										|
     								('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(aga)) 
     								AND
    								(
    									( aga.role.name <> 'specification category member' ) 
    									OR 
    									( SIZEOF(QUERY 
    															( 
    																i <* aga.items 
    																| 
    																('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( i ) ) 
    																AND 
    																NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'CONDITIONAL_CONCEPT_FEATURE' IN TYPEOF (i))
    															)
    													) <> SIZEOF (aga.items)
    									)
    								) 
       						) 
       				) =0;
END_ENTITY;


ENTITY product_concept_feature_category_usage
	SUBTYPE OF (group_assignment);
	items : SET [1:?] OF category_usage_item;
	SELF\group_assignment.assigned_group : product_concept_feature_category;
WHERE
	WR1 : SELF.role.name IN [ 'mandatory category usage', 'optional category usage' ];
END_ENTITY;


ENTITY product_concept_relationship;
	name : label;
	description : OPTIONAL text;
	relating_product_concept : product_concept;
	related_product_concept : product_concept;
END_ENTITY;


ENTITY product_context
	SUBTYPE OF (application_context_element);
	discipline_type : label;
END_ENTITY;


ENTITY product_definition
	SUPERTYPE OF (ONEOF (composite_assembly_definition, composite_assembly_sequence_definition, laminate_table, percentage_laminate_definition, percentage_ply_definition, ply_laminate_definition, ply_laminate_sequence_definition, thickness_laminate_definition));
	id : identifier;
	description : OPTIONAL text;
	formation : product_definition_formation;
	frame_of_reference : product_definition_context;
DERIVE
	name : label := get_name_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;


ENTITY product_definition_context
	SUBTYPE OF (application_context_element);
	life_cycle_stage : label;
END_ENTITY;


ENTITY product_definition_context_association;
	definition : product_definition;
	frame_of_reference : product_definition_context;
	role : product_definition_context_role;
END_ENTITY;


ENTITY product_definition_context_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY;


ENTITY product_definition_effectivity
	SUBTYPE OF (effectivity);
	usage : product_definition_relationship;
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY')) = 0;
END_ENTITY;


ENTITY product_definition_element_relationship
	SUBTYPE OF (group);
END_ENTITY;


ENTITY product_definition_formation;
	id : identifier;
	description : OPTIONAL text;
	of_product : product;
UNIQUE
	UR1 : id, of_product;
END_ENTITY;


ENTITY product_definition_formation_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_product_definition_formation : product_definition_formation;
	related_product_definition_formation : product_definition_formation;
END_ENTITY;


ENTITY product_definition_formation_with_specified_source
	SUBTYPE OF (product_definition_formation);
	make_or_buy : source;
END_ENTITY;


ENTITY product_definition_group_assignment
	SUBTYPE OF (group_assignment);
	items : SET [1:1] OF product_definition_or_product_definition_relationship;
	SELF\group_assignment.assigned_group : product_definition_element_relationship;
END_ENTITY;


ENTITY product_definition_occurrence_relationship;
	name : label;
	description : OPTIONAL text;
	occurrence : product_definition;
	occurrence_usage : assembly_component_usage;
WHERE
	WR1 : occurrence_usage.relating_product_definition :<>: 
       occurrence;
	WR2 : occurrence_usage.related_product_definition :<>: 
       occurrence;
	WR3 : occurrence.formation :=:
       occurrence_usage.related_product_definition.formation;
END_ENTITY;


ENTITY product_definition_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_product_definition : product_definition;
	related_product_definition : product_definition;
END_ENTITY;


ENTITY product_definition_shape
	SUBTYPE OF (property_definition);
UNIQUE
	UR1 : SELF\property_definition.definition;
WHERE
	WR1 : SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CHARACTERIZED_PRODUCT_DEFINITION', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CHARACTERIZED_OBJECT'] * TYPEOF(SELF\property_definition.definition)) > 0;
END_ENTITY;


ENTITY product_definition_substitute;
	description : OPTIONAL text;
	context_relationship : product_definition_relationship;
	substitute_definition : product_definition;
DERIVE
	name : label := get_name_value(SELF);
WHERE
	WR1 : context_relationship.related_product_definition :<>: substitute_definition;
	WR2 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;


ENTITY product_definition_usage
	SUPERTYPE OF (ONEOF (make_from_usage_option, assembly_component_usage))
	SUBTYPE OF (product_definition_relationship);
UNIQUE
	UR1 : SELF\product_definition_relationship.id, SELF\product_definition_relationship.relating_product_definition, SELF\product_definition_relationship.related_product_definition;
WHERE
	WR1 : acyclic_product_definition_relationship
         (SELF,
         [SELF\product_definition_relationship.related_product_definition],
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION_USAGE');
END_ENTITY;


ENTITY product_definition_with_associated_documents
	SUBTYPE OF (product_definition);
	documentation_ids : SET [1:?] OF document;
END_ENTITY;


ENTITY product_identification
	SUBTYPE OF (configuration_item, characterized_object);
	SELF\configuration_item.item_concept : product_class;
WHERE
	WR1 : SIZEOF(QUERY 
		( cd <* USEDIN ( SELF ,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONFIGURATION_DESIGN.CONFIGURATION' ) 
		|
     	( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'PRODUCT_DEFINITION_FORMATION' IN TYPEOF ( cd. design ) ) 
     	AND 
    	( SIZEOF ( QUERY 
    	( 
    	prpc <* USEDIN ( cd. design\product_definition_formation.of_product , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') 
    	| 
        prpc. name IN ['part' , 'raw material' , 'tool'] ) ) >0
     	) 
     	) 
     	) <=1;
	WR2 : NOT ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'CONFIGURABLE_ITEM' IN TYPEOF( SELF ) ) 
			XOR ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'PRODUCT_SPECIFICATION' IN TYPEOF ( SELF ) );
END_ENTITY;


ENTITY product_material_composition_relationship
	SUBTYPE OF (product_definition_relationship);
	class : label;
	constituent_amount : SET [1:?] OF characterized_product_composition_value;
	composition_basis : label;
	determination_method : text;
END_ENTITY;


ENTITY product_of_mesh;
	operands : LIST [2:2] OF mesh;
	product : mesh;
WHERE
	wr1 : (this_schema+'.STRUCTURED_MESH' IN TYPEOF(operands[1])) AND
        (this_schema+'.STRUCTURED_MESH' IN TYPEOF(operands[2])) AND
        (this_schema+'.STRUCTURED_MESH' IN TYPEOF(product));
	wr2 : operands[1].index_count = 1;
	wr3 : operands[1].index_count + operands[2].index_count
        = product.index_count;
END_ENTITY;


ENTITY product_related_product_category
	SUBTYPE OF (product_category);
	products : SET [1:?] OF product;
END_ENTITY;


ENTITY product_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_product : product;
	related_product : product;
END_ENTITY;


ENTITY product_specification
	SUBTYPE OF (product_identification, configurable_item);
END_ENTITY;


ENTITY product_view_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	discretised_model : discretised_product_model_select;
	idealised_product : idealised_product_select;
END_ENTITY;


ENTITY projected_zone_definition
	SUBTYPE OF (tolerance_zone_definition);
	projection_end : shape_aspect;
	projected_length : measure_with_unit;
WHERE
	WR1 : ('NUMBER' IN TYPEOF
       (projected_length\measure_with_unit.value_component)) AND
       (projected_length\measure_with_unit.value_component > 0.0);
	WR2 : (derive_dimensional_exponents
       (projected_length\measure_with_unit.unit_component)=
        dimensional_exponents(1,0,0,0,0,0,0));
END_ENTITY;


ENTITY projection_curve
	SUBTYPE OF (annotation_curve_occurrence);
END_ENTITY;


ENTITY projection_directed_callout
	SUBTYPE OF (draughting_callout);
WHERE
	WR1 : SIZEOF(QUERY(p_1<*SELF\draughting_callout.contents | 
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROJECTION_CURVE' IN (TYPEOF(p_1))))=1;
	WR2 : SIZEOF(SELF\draughting_callout.contents) >=2;
END_ENTITY;


ENTITY promissory_usage_occurrence
	SUBTYPE OF (assembly_component_usage);
END_ENTITY;


ENTITY property_definition;
	name : label;
	description : OPTIONAL text;
	definition : characterized_definition;
DERIVE
	id : identifier := get_id_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;


ENTITY property_definition_relationship;
	name : label;
	description : text;
	relating_property_definition : property_definition;
	related_property_definition : property_definition;
END_ENTITY;


ENTITY property_definition_representation;
	definition : represented_definition;
	used_representation : representation;
DERIVE
	description : text := get_description_value(SELF);
	name : label := get_name_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
	WR2 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;


ENTITY property_distribution_description;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	abstract_function : maths_function;
	domain_context : maths_space_context;
	physical_function : property_distribution_select;
	range_context : maths_space_context;
END_ENTITY;


ENTITY qualified_representation_item
	SUBTYPE OF (representation_item);
	qualifiers : SET [1:?] OF value_qualifier;
WHERE
	WR1 : SIZEOF(QUERY(temp <* qualifiers |
             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRECISION_QUALIFIER'
             IN TYPEOF(temp))) < 2;
END_ENTITY;


ENTITY qualitative_uncertainty
	SUBTYPE OF (uncertainty_qualifier);
	uncertainty_value : text;
END_ENTITY;


ENTITY quantified_assembly_component_usage
	SUBTYPE OF (assembly_component_usage);
	quantity : measure_with_unit;
WHERE
	WR1 : (NOT ('NUMBER' IN TYPEOF(quantity.value_component)))
       OR (quantity.value_component > 0);
END_ENTITY;


ENTITY quantifier_expression
	ABSTRACT SUPERTYPE
	SUBTYPE OF (multiple_arity_generic_expression);
	variables : LIST [1:?] OF  UNIQUE generic_variable;
WHERE
	WR1 : SIZEOF (QUERY (vrbl <* variables | NOT (vrbl IN
       SELF\multiple_arity_generic_expression.operands))) = 0;
	WR2 : SIZEOF (QUERY (vrbl <* variables | NOT ((schema_prefix +
       'BOUND_VARIABLE_SEMANTICS') IN TYPEOF (vrbl.interpretation.semantics)))) = 0;
END_ENTITY;


ENTITY quasi_uniform_curve
	SUBTYPE OF (b_spline_curve);
END_ENTITY;


ENTITY quasi_uniform_surface
	SUBTYPE OF (b_spline_surface);
END_ENTITY;


ENTITY radioactivity_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.RADIOACTIVITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY radioactivity_unit
	SUBTYPE OF (derived_unit);
WHERE
	WR1 : derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.becquerel);
END_ENTITY;


ENTITY radius_dimension
	SUBTYPE OF (dimension_curve_directed_callout);
WHERE
	WR1 : SIZEOF (QUERY (con <* SELF.contents |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROJECTION_CURVE' IN TYPEOF (con)))<=1;
END_ENTITY;


ENTITY range_characteristic
	SUBTYPE OF (representation, descriptive_representation_item);
WHERE
	WR1 : NOT(SELF\representation.name IN ['tolerance', 'minimum tolerance', 'maximum tolerance', 
        'nominal tolerance', 'plus minus tolerance', 'symmetrical tolerance', 'statistical tolerance']);
END_ENTITY;


ENTITY ratio_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.RATIO_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY ratio_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;


ENTITY rational_b_spline_curve
	SUBTYPE OF (b_spline_curve);
	weights_data : LIST [2:?] OF REAL;
DERIVE
	weights : ARRAY [0:upper_index_on_control_points] OF REAL := list_to_array(weights_data,0,
                                      upper_index_on_control_points);
WHERE
	WR1 : SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.
                                           control_points_list);
	WR2 : curve_weights_positive(SELF);
END_ENTITY;


ENTITY rational_b_spline_surface
	SUBTYPE OF (b_spline_surface);
	weights_data : LIST [2:?] OF LIST [2:?] OF REAL;
DERIVE
	weights : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF REAL := make_array_of_array(weights_data,0,u_upper,0,v_upper);
WHERE
	WR1 : (SIZEOF(weights_data) =
                     SIZEOF(SELF\b_spline_surface.control_points_list))
           AND (SIZEOF(weights_data[1]) =
                  SIZEOF(SELF\b_spline_surface.control_points_list[1]));
	WR2 : surface_weights_positive(SELF);
END_ENTITY;


ENTITY rational_representation_item
	SUBTYPE OF (representation_item, slash_expression);
WHERE
	WR1 : SIZEOF( QUERY( operand <* SELF\binary_generic_expression.operands | 
        NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.INT_LITERAL' IN TYPEOF(operand)))) = 0;
END_ENTITY;


ENTITY rationalize_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	SELF\unary_generic_expression.operand : maths_function;
DERIVE
	fun : maths_function := SELF\unary_generic_expression.operand;
WHERE
	WR1 : (space_dimension(fun.domain) = 1) AND (space_dimension(fun.range) = 1);
	WR2 : number_tuple_subspace_check(factor1(fun.range));
	WR3 : space_dimension(factor1(fun.range)) > 1;
END_ENTITY;


ENTITY real_defined_function
	ABSTRACT SUPERTYPE
	SUBTYPE OF (numeric_defined_function);
END_ENTITY;


ENTITY real_interval_from_min
	SUBTYPE OF (maths_space, generic_literal);
	min : REAL;
	min_closure : open_closed;
END_ENTITY;


ENTITY real_interval_to_max
	SUBTYPE OF (maths_space, generic_literal);
	max : REAL;
	max_closure : open_closed;
END_ENTITY;


ENTITY real_literal
	SUBTYPE OF (literal_number);
	SELF\literal_number.the_value : REAL;
END_ENTITY;


ENTITY real_numeric_variable
	SUBTYPE OF (numeric_variable);
END_ENTITY;


ENTITY real_representation_item
	SUBTYPE OF (representation_item, real_literal);
END_ENTITY;


ENTITY real_tuple_literal
	SUBTYPE OF (generic_literal);
	lit_value : LIST [1:?] OF REAL;
END_ENTITY;


ENTITY rectangular_composite_surface
	SUBTYPE OF (bounded_surface);
	segments : LIST [1:?] OF LIST [1:?] OF surface_patch;
DERIVE
	n_u : INTEGER := SIZEOF(segments);
	n_v : INTEGER := SIZEOF(segments[1]);
WHERE
	WR1 : SIZEOF(QUERY (s <* segments | n_v <> SIZEOF (s))) = 0;
	WR2 : constraints_rectangular_composite_surface(SELF);
END_ENTITY;


ENTITY rectangular_trimmed_surface
	SUBTYPE OF (bounded_surface);
	basis_surface : surface;
	u1 : parameter_value;
	u2 : parameter_value;
	v1 : parameter_value;
	v2 : parameter_value;
	usense : BOOLEAN;
	vsense : BOOLEAN;
WHERE
	WR1 : u1 <> u2;
	WR2 : v1 <> v2;
	WR3 : (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELEMENTARY_SURFACE' IN TYPEOF(basis_surface))
       AND  (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLANE' IN TYPEOF(basis_surface)))) OR
      ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_OF_REVOLUTION' IN TYPEOF(basis_surface))
          OR (usense = (u2 > u1));
	WR4 : (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SPHERICAL_SURFACE' IN TYPEOF(basis_surface))
          OR
         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TOROIDAL_SURFACE' IN TYPEOF(basis_surface)))
          OR (vsense = (v2 > v1));
END_ENTITY;


ENTITY referenced_modified_datum
	SUBTYPE OF (datum_reference);
	modifier : limit_condition;
END_ENTITY;


ENTITY regular_table_function
	SUBTYPE OF (linearized_table_function);
	increments : LIST [1:?] OF INTEGER;
WHERE
	WR1 : SIZEOF (increments) = SIZEOF (self\explicit_table_function.shape);
	WR2 : extremal_position_check(self);
END_ENTITY;


ENTITY reindexed_array_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	starting_indices : LIST [1:?] OF INTEGER;
	SELF\unary_generic_expression.operand : maths_function;
WHERE
	WR1 : function_is_array(SELF\unary_generic_expression.operand);
	WR2 : SIZEOF(starting_indices) = SIZEOF(shape_of_array(
       SELF\unary_generic_expression.operand));
END_ENTITY;


ENTITY relative_event_occurrence
	SUBTYPE OF (event_occurrence);
	base_event : event_occurrence;
	offset : time_measure_with_unit;
END_ENTITY;


ENTITY rep_item_group
	SUBTYPE OF (group, representation_item);
WHERE
	WR1 : SIZEOF(USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'PRESENTATION_LAYER_ASSIGNMENT.' + 'ASSIGNED_ITEMS')) > 0;
	WR2 : SIZEOF(QUERY(r <* USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'REPRESENTATION.' + 'ITEMS') | r.name = 'group representation')) > 0;
	WR3 : SIZEOF(QUERY(ga <* USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'GROUP_ASSIGNMENT.' + 'ASSIGNED_GROUP') | ga.role.name <> 'group membership')) = 0;
	WR4 : SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'GEOMETRIC_REPRESENTATION_ITEM', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'TOPOLOGICAL_REPRESENTATION_ITEM', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'MAPPED_ITEM','AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'STYLED_ITEM'] * TYPEOF(SELF)) = 1;
END_ENTITY;


ENTITY repackaging_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	input_repack : repackage_options;
	output_repack : repackage_options;
	selected_output : nonnegative_integer;
	SELF\unary_generic_expression.operand : maths_function;
WHERE
	WR1 : (input_repack <> ro_wrap_as_tuple) OR
       ((space_dimension(operand.domain) = 1) AND
         ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF (factor1(operand.domain))));
	WR2 : (output_repack <> ro_unwrap_tuple) OR
       ((space_dimension(operand.range) = 1) AND
         ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF (factor1(operand.range))));
	WR3 : selected_output <= space_dimension( repackage(
       operand.range, output_repack));
END_ENTITY;


ENTITY reparametrised_composite_curve_segment
	SUBTYPE OF (composite_curve_segment);
	param_length : parameter_value;
WHERE
	WR1 : param_length > 0.0;
END_ENTITY;


ENTITY representation;
	name : label;
	items : SET [1:?] OF representation_item;
	context_of_items : representation_context;
DERIVE
	description : text := get_description_value (SELF);
	id : identifier := get_id_value (SELF);
WHERE
	WR1 : SIZEOF (USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))
         <= 1;
	WR2 : SIZEOF (USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))
         <= 1;
END_ENTITY;


ENTITY representation_context;
	context_identifier : identifier;
	context_type : text;
INVERSE
	representations_in_context: SET [1:?] OF representation FOR context_of_items;
END_ENTITY;


ENTITY representation_context_defined_maths_space_context
	SUBTYPE OF (defined_maths_space_context);
	representation_basis : representation_context;
END_ENTITY;


ENTITY representation_item
	SUPERTYPE OF ((ONEOF (binary_representation_item, compound_representation_item, mapped_item, value_representation_item) ANDOR ONEOF (mapped_item, styled_item) ANDOR ONEOF (boolean_representation_item, date_representation_item, date_time_representation_item, integer_representation_item, logical_representation_item, rational_representation_item, real_representation_item)));
	name : label;
WHERE
	WR1 : SIZEOF(using_representations(SELF)) > 0;
END_ENTITY;


ENTITY representation_item_relationship;
	name : label;
	description : OPTIONAL text;
	relating_representation_item : representation_item;
	related_representation_item : representation_item;
END_ENTITY;


ENTITY representation_map;
	mapping_origin : representation_item;
	mapped_representation : representation;
INVERSE
	map_usage: SET [1:?] OF mapped_item FOR mapping_source;
WHERE
	WR1 : item_in_context(SELF.mapping_origin,
        SELF.mapped_representation.context_of_items);
END_ENTITY;


ENTITY representation_relationship;
	name : label;
	description : OPTIONAL text;
	rep_1 : representation;
	rep_2 : representation;
END_ENTITY;


ENTITY representation_relationship_with_transformation
	SUBTYPE OF (representation_relationship);
	transformation_operator : transformation;
WHERE
	WR1 : SELF\representation_relationship.rep_1.context_of_items
           :<>: SELF\representation_relationship.rep_2.context_of_items;
END_ENTITY;


ENTITY requirement_assigned_object
	SUBTYPE OF (group_assignment);
	items : SET [1:1] OF requirement_assigned_item;
	SELF\group_assignment.assigned_group : requirement_assignment;
END_ENTITY;


ENTITY requirement_assignment
	SUBTYPE OF (characterized_object, group);
END_ENTITY;


ENTITY requirement_source
	SUBTYPE OF (group);
END_ENTITY;


ENTITY requirement_view_definition_relationship
	SUBTYPE OF (product_definition_relationship);
END_ENTITY;


ENTITY resistance_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.RESISTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY resistance_unit
	SUBTYPE OF (derived_unit);
WHERE
	WR1 : derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.ohm);
END_ENTITY;


ENTITY resource_property;
	name : label;
	description : text;
	resource : characterized_resource_definition;
END_ENTITY;


ENTITY resource_property_representation;
	name : label;
	description : text;
	property : resource_property;
	representation : representation;
END_ENTITY;


ENTITY restriction_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	SELF\unary_generic_expression.operand : maths_space;
END_ENTITY;


ENTITY result;
	result_id : identifier;
	creating_software : text;
	description : text;
END_ENTITY;


ENTITY result_analysis_step
	SUPERTYPE OF (ONEOF (result_linear_static_analysis_sub_step, result_linear_modes_and_frequencies_analysis_sub_step))
	SUBTYPE OF (analysis_step);
	analysis_result : result;
UNIQUE
	UR1 : SELF\analysis_step.analysis_control, analysis_result;
END_ENTITY;


ENTITY result_linear_modes_and_frequencies_analysis_sub_step
	SUBTYPE OF (result_analysis_step);
	states : SET [1:?] OF calculated_state;
END_ENTITY;


ENTITY result_linear_static_analysis_sub_step
	SUBTYPE OF (result_analysis_step);
	state : calculated_state;
END_ENTITY;


ENTITY revolved_area_solid
	SUBTYPE OF (swept_area_solid);
	axis : axis1_placement;
	angle : plane_angle_measure;
DERIVE
	axis_line : line := representation_item('')||
                    geometric_representation_item()|| curve()||
                    line(axis.location, representation_item('')||
                    geometric_representation_item()||
                    vector(axis.z, 1.0));
END_ENTITY;


ENTITY revolved_face_solid
	SUBTYPE OF (swept_face_solid);
	axis : axis1_placement;
	angle : plane_angle_measure;
DERIVE
	axis_line : line := representation_item('')||
                    geometric_representation_item()|| curve()||
                    line(axis.location, representation_item('')||
                    geometric_representation_item()||
                    vector(axis.z, 1.0));
END_ENTITY;


ENTITY revolved_face_solid_with_trim_conditions
	SUBTYPE OF (revolved_face_solid);
	first_trim_condition : trim_condition_select;
	second_trim_condition : trim_condition_select;
WHERE
	WR1 : NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE' 
         IN TYPEOF(first_trim_condition)) 
         OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE' 
         IN TYPEOF(second_trim_condition)));
	WR2 : NOT((('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLANE_ANGLE_MEASURE' 
         IN TYPEOF(first_trim_condition)) AND
            ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLANE_ANGLE_MEASURE' 
         IN TYPEOF(second_trim_condition))) AND
         (first_trim_condition = second_trim_condition));
END_ENTITY;


ENTITY right_angular_wedge
	SUBTYPE OF (geometric_representation_item);
	position : axis2_placement_3d;
	x : positive_length_measure;
	y : positive_length_measure;
	z : positive_length_measure;
	ltx : length_measure;
WHERE
	WR1 : ((0.0 <= ltx) AND (ltx < x));
END_ENTITY;


ENTITY right_circular_cone
	SUBTYPE OF (geometric_representation_item);
	position : axis1_placement;
	height : positive_length_measure;
	radius : length_measure;
	semi_angle : plane_angle_measure;
WHERE
	WR1 : radius >= 0.0;
END_ENTITY;


ENTITY right_circular_cylinder
	SUBTYPE OF (geometric_representation_item);
	position : axis1_placement;
	height : positive_length_measure;
	radius : positive_length_measure;
END_ENTITY;


ENTITY right_to_usage_association
	SUBTYPE OF (action_method_relationship);
	SELF\action_method_relationship.related_method : information_right;
	SELF\action_method_relationship.relating_method : information_usage_right;
DERIVE
	right_applied : information_right := SELF\action_method_relationship.related_method;
	right_usage : information_usage_right := SELF\action_method_relationship.relating_method;
END_ENTITY;


ENTITY rind;
	index_count : INTEGER;
	planes : ARRAY [1:2] OF INTEGER;
END_ENTITY;


ENTITY role_association;
	role : object_role;
	item_with_role : role_select;
END_ENTITY;


ENTITY roundness_tolerance
	SUBTYPE OF (geometric_tolerance);
WHERE
	WR1 : NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF));
END_ENTITY;


ENTITY row_representation_item
	SUBTYPE OF (compound_representation_item);
	SELF\compound_representation_item.item_element : list_representation_item;
END_ENTITY;


ENTITY row_value
	SUBTYPE OF (compound_representation_item);
END_ENTITY;


ENTITY row_variable
	SUBTYPE OF (abstract_variable);
END_ENTITY;


ENTITY rule_action
	SUBTYPE OF (action);
END_ENTITY;


ENTITY rule_condition
	SUBTYPE OF (atomic_formula);
END_ENTITY;


ENTITY rule_definition
	SUBTYPE OF (rule_software_definition);
END_ENTITY;


ENTITY rule_set
	SUBTYPE OF (rule_software_definition);
END_ENTITY;


ENTITY rule_set_group
	SUBTYPE OF (rule_software_definition);
END_ENTITY;


ENTITY rule_software_definition
	SUBTYPE OF (product_definition);
END_ENTITY;


ENTITY rule_superseded_assignment
	SUBTYPE OF (action_assignment);
	items : SET [1:?] OF rule_superseded_item;
END_ENTITY;


ENTITY rule_supersedence
	SUBTYPE OF (rule_action);
END_ENTITY;


ENTITY ruled_surface_swept_area_solid
	SUBTYPE OF (surface_curve_swept_area_solid);
WHERE
	WR1 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_SURFACE' IN TYPEOF(SELF.reference_surface)) AND
         (SELF.reference_surface\b_spline_surface.u_degree = 1);
	WR2 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN TYPEOF(SELF.directrix)) OR
        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE' IN TYPEOF(SELF.directrix\surface_curve.curve_3d))
         AND
         (SELF.directrix\surface_curve.curve_3d\b_spline_curve.degree =
         SELF.reference_surface\b_spline_surface.v_degree));
END_ENTITY;


ENTITY runout_zone_definition
	SUBTYPE OF (tolerance_zone_definition);
	orientation : runout_zone_orientation;
END_ENTITY;


ENTITY runout_zone_orientation;
	angle : measure_with_unit;
END_ENTITY;


ENTITY runout_zone_orientation_reference_direction
	SUBTYPE OF (runout_zone_orientation);
	orientation_defining_relationship : shape_aspect_relationship;
END_ENTITY;


ENTITY same_discretised_action_model;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	equivalent_records : SET [2:?] OF discretised_action_model_select;
END_ENTITY;


ENTITY same_discretised_distribution_model;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	equivalent_records : SET [1:?] OF discretised_distribution_model_select;
END_ENTITY;


ENTITY same_discretised_state_model;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	equivalent_records : SET [2:?] OF discretised_state_model_select;
END_ENTITY;


ENTITY same_idealised_action;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	equivalent_records : SET [2:?] OF idealised_action_select;
END_ENTITY;


ENTITY same_idealised_distribution;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	equivalent_records : LIST [2:?] OF idealised_distribution_select;
END_ENTITY;


ENTITY same_idealised_state;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	equivalent_records : SET [2:?] OF idealised_state_select;
END_ENTITY;


ENTITY satisfied_requirement
	SUBTYPE OF (group_assignment);
	items : SET [1:1] OF product_definition;
	SELF\group_assignment.assigned_group : satisfies_requirement;
END_ENTITY;


ENTITY satisfies_requirement
	SUBTYPE OF (group);
END_ENTITY;


ENTITY satisfying_item
	SUBTYPE OF (group_assignment);
	items : SET [1:1] OF requirement_satisfaction_item;
	SELF\group_assignment.assigned_group : satisfies_requirement;
END_ENTITY;


ENTITY scalar_variable
	SUBTYPE OF (abstract_variable);
END_ENTITY;


ENTITY scattering_parameter
	SUBTYPE OF (polar_complex_number_literal);
WHERE
	WR1 : SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\polar_complex_number_literal ||
       SELF\scattering_parameter))) = 0;
END_ENTITY;


ENTITY sculptured_solid
	SUBTYPE OF (modified_solid);
	sculpturing_element : generalized_surface_select;
	positive_side : BOOLEAN;
END_ENTITY;


ENTITY seam_curve
	SUBTYPE OF (surface_curve);
WHERE
	WR1 : SIZEOF(SELF\surface_curve.associated_geometry) = 2;
	WR2 : associated_surface(SELF\surface_curve.associated_geometry[1]) =
           associated_surface(SELF\surface_curve.associated_geometry[2]);
	WR3 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN
           TYPEOF(SELF\surface_curve.associated_geometry[1]);
	WR4 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN
            TYPEOF(SELF\surface_curve.associated_geometry[2]);
END_ENTITY;


ENTITY security_classification;
	name : label;
	purpose : text;
	security_level : security_classification_level;
END_ENTITY;


ENTITY security_classification_assignment
	ABSTRACT SUPERTYPE;
	assigned_security_classification : security_classification;
DERIVE
	role : object_role := get_role(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;


ENTITY security_classification_level;
	name : label;
END_ENTITY;


ENTITY selector_function
	SUBTYPE OF (maths_function, generic_literal);
	selector : input_selector;
	source_of_domain : maths_space_or_function;
WHERE
	WR1 : no_cyclic_domain_reference(source_of_domain, [SELF]);
	WR2 : expression_is_constant(domain_from(source_of_domain));
END_ENTITY;


ENTITY serial_numbered_effectivity
	SUBTYPE OF (effectivity);
	effectivity_start_id : identifier;
	effectivity_end_id : OPTIONAL identifier;
END_ENTITY;


ENTITY series_composed_function
	SUBTYPE OF (maths_function, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF maths_function;
WHERE
	WR1 : composable_sequence(SELF\multiple_arity_generic_expression.operands);
END_ENTITY;


ENTITY shape_aspect;
	name : label;
	description : OPTIONAL text;
	of_shape : product_definition_shape;
	product_definitional : LOGICAL;
DERIVE
	id : identifier := get_id_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;


ENTITY shape_aspect_associativity
	SUBTYPE OF (shape_aspect_relationship);
WHERE
	WR1 : SELF.relating_shape_aspect.product_definitional;
	WR2 : NOT (SELF.related_shape_aspect.product_definitional);
END_ENTITY;


ENTITY shape_aspect_deriving_relationship
	SUBTYPE OF (shape_aspect_relationship);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DERIVED_SHAPE_ASPECT' IN
TYPEOF
            (SELF\SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT);
END_ENTITY;


ENTITY shape_aspect_relationship;
	name : label;
	description : OPTIONAL text;
	relating_shape_aspect : shape_aspect;
	related_shape_aspect : shape_aspect;
DERIVE
	id : identifier := get_id_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;


ENTITY shape_definition_representation
	SUBTYPE OF (property_definition_representation);
WHERE
	WR1 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(SELF.definition)) OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHAPE_DEFINITION' IN TYPEOF(SELF.definition.definition));
	WR2 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHAPE_REPRESENTATION' IN TYPEOF(SELF.used_representation);
END_ENTITY;


ENTITY shape_dimension_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 : SIZEOF (QUERY (temp <* SELF\representation.items | 
    NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM' 
        IN TYPEOF (temp)))) = 0;
	WR2 : SIZEOF (SELF\representation.items) <= 3;
	WR3 : SIZEOF (QUERY (pos_mri <* QUERY (real_mri <*
        SELF\representation.items | 'REAL' IN TYPEOF
        (real_mri\measure_with_unit.value_component) ) |        
     NOT  (pos_mri\measure_with_unit.value_component > 0.0 ))) = 0;
END_ENTITY;


ENTITY shape_feature_definition
	SUBTYPE OF (characterized_object);
END_ENTITY;


ENTITY shape_representation
	SUBTYPE OF (representation);
END_ENTITY;


ENTITY shape_representation_relationship
	SUBTYPE OF (representation_relationship);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHAPE_REPRESENTATION' IN (TYPEOF(SELF\representation_relationship.rep_1) + TYPEOF(SELF\representation_relationship.rep_2));
END_ENTITY;


ENTITY shape_representation_with_parameters
	SUBTYPE OF (shape_representation);
WHERE
	WR1 : SIZEOF( QUERY( i <* SELF.items | SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLACEMENT', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM'] * TYPEOF(i)) = 1 )) = SIZEOF(SELF.items);
END_ENTITY;


ENTITY shell_based_surface_model
	SUBTYPE OF (geometric_representation_item);
	sbsm_boundary : SET [1:?] OF shell;
WHERE
	WR1 : constraints_geometry_shell_based_surface_model(SELF);
END_ENTITY;


ENTITY shell_based_wireframe_model
	SUBTYPE OF (geometric_representation_item);
	sbwm_boundary : SET [1:?] OF shell;
WHERE
	WR1 : constraints_geometry_shell_based_wireframe_model(SELF);
END_ENTITY;


ENTITY shell_based_wireframe_shape_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 : SIZEOF ( 
QUERY ( it <* SELF.items| NOT ( SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_WIREFRAME_MODEL', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D' ] * TYPEOF (it)) = 1) )) = 0;
	WR2 : SIZEOF ( 
QUERY ( it <* SELF.items| ( SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_WIREFRAME_MODEL', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' ] * TYPEOF (it)) = 1) )) >= 1;
	WR3 : SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( eloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (wsb)) )| NOT ( SIZEOF ( 
QUERY ( el <* eloop\path.edge_list| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_CURVE' IN TYPEOF (el.edge_element)) )) = 0) )) = 0) )) = 0) )) = 0;
	WR4 : SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( eloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (wsb)) )| NOT ( SIZEOF ( 
QUERY ( pline_el <* 
QUERY ( el <* eloop\path.edge_list| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN TYPEOF (el.edge_element\edge_curve.edge_geometry)) )| NOT ( SIZEOF (pline_el.edge_element\edge_curve.edge_geometry\polyline.points) > 2) )) = 0) )) = 0) )) = 0) )) = 0;
	WR5 : SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( eloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (wsb)) )| NOT ( SIZEOF ( 
QUERY ( el <* eloop\path.edge_list| NOT valid_wireframe_edge_curve(el.edge_element\edge_curve.edge_geometry) )) = 0) )) = 0) )) = 0) )) = 0;
	WR6 : SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( eloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (wsb)) )| NOT ( SIZEOF ( 
QUERY ( el <* eloop\path.edge_list| NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF (el.edge_element.edge_start)) AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF (el.edge_element.edge_end))) )) = 0) )) = 0) )) = 0) )) = 0;
	WR7 : SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( eloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (wsb)) )| NOT ( SIZEOF ( 
QUERY ( el <* eloop\path.edge_list| NOT (valid_wireframe_vertex_point(el.edge_element.edge_start\vertex_point.vertex_geometry) AND valid_wireframe_vertex_point(el.edge_element.edge_end\vertex_point.vertex_geometry)) )) = 0) )) = 0) )) = 0) )) = 0;
	WR8 : SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( vloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_LOOP' IN TYPEOF (wsb)) )| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF (vloop\vertex_loop.loop_vertex)) )) = 0) )) = 0) )) = 0;
	WR9 : SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( vloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_LOOP' IN TYPEOF (wsb)) )| NOT valid_wireframe_vertex_point(vloop\vertex_loop.loop_vertex\vertex_point.vertex_geometry) )) = 0) )) = 0) )) = 0;
	WR10 : SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( vs <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_SHELL' IN TYPEOF (sb)) )| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF (vs\vertex_shell.vertex_shell_extent.loop_vertex)) )) = 0) )) = 0;
	WR11 : SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( vs <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_SHELL' IN TYPEOF (sb)) )| NOT valid_wireframe_vertex_point(vs\vertex_shell.vertex_shell_extent.loop_vertex\vertex_point.vertex_geometry) )) = 0) )) = 0;
	WR12 : SIZEOF ( 
QUERY ( mi <* 
QUERY ( it <* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
	WR13 : SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3;
END_ENTITY;


ENTITY shelled_solid
	SUPERTYPE OF (ONEOF (double_offset_shelled_solid, complex_shelled_solid))
	SUBTYPE OF (modified_solid);
	deleted_face_set : SET [1:?] OF face_surface;
	thickness : length_measure;
WHERE
	WR1 : thickness <> 0;
END_ENTITY;


ENTITY si_absorbed_dose_unit
	SUBTYPE OF (absorbed_dose_unit, si_unit);
WHERE
	WR1 : SELF\si_unit.name = si_unit_name.gray;
	WR2 : NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;


ENTITY si_capacitance_unit
	SUBTYPE OF (capacitance_unit, si_unit);
WHERE
	WR1 : SELF\si_unit.name = si_unit_name.farad;
	WR2 : NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;


ENTITY si_conductance_unit
	SUBTYPE OF (conductance_unit, si_unit);
WHERE
	WR1 : SELF\si_unit.name = si_unit_name.siemens;
	WR2 : NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;


ENTITY si_dose_equivalent_unit
	SUBTYPE OF (dose_equivalent_unit, si_unit);
WHERE
	WR1 : SELF\si_unit.name = si_unit_name.sievert;
	WR2 : NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;


ENTITY si_electric_charge_unit
	SUBTYPE OF (electric_charge_unit, si_unit);
WHERE
	WR1 : SELF\si_unit.name = si_unit_name.coulomb;
	WR2 : NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;


ENTITY si_electric_potential_unit
	SUBTYPE OF (electric_potential_unit, si_unit);
WHERE
	WR1 : SELF\si_unit.name = si_unit_name.volt;
	WR2 : NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;


ENTITY si_energy_unit
	SUBTYPE OF (energy_unit, si_unit);
WHERE
	WR1 : SELF\si_unit.name = si_unit_name.joule;
	WR2 : NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;


ENTITY si_force_unit
	SUBTYPE OF (force_unit, si_unit);
WHERE
	WR1 : SELF\si_unit.name = si_unit_name.newton;
	WR2 : NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;


ENTITY si_frequency_unit
	SUBTYPE OF (frequency_unit, si_unit);
WHERE
	WR1 : SELF\si_unit.name = si_unit_name.hertz;
	WR2 : NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;


ENTITY si_illuminance_unit
	SUBTYPE OF (illuminance_unit, si_unit);
WHERE
	WR1 : SELF\si_unit.name = si_unit_name.lux;
	WR2 : NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;


ENTITY si_inductance_unit
	SUBTYPE OF (inductance_unit, si_unit);
WHERE
	WR1 : SELF\si_unit.name = si_unit_name.henry;
	WR2 : NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;


ENTITY si_magnetic_flux_density_unit
	SUBTYPE OF (magnetic_flux_density_unit, si_unit);
WHERE
	WR1 : SELF\si_unit.name = si_unit_name.tesla;
	WR2 : NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;


ENTITY si_magnetic_flux_unit
	SUBTYPE OF (magnetic_flux_unit, si_unit);
WHERE
	WR1 : SELF\si_unit.name = si_unit_name.weber;
	WR2 : NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;


ENTITY si_power_unit
	SUBTYPE OF (power_unit, si_unit);
WHERE
	WR1 : SELF\si_unit.name = si_unit_name.watt;
	WR2 : NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;


ENTITY si_pressure_unit
	SUBTYPE OF (pressure_unit, si_unit);
WHERE
	WR1 : SELF\si_unit.name = si_unit_name.pascal;
	WR2 : NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;


ENTITY si_radioactivity_unit
	SUBTYPE OF (radioactivity_unit, si_unit);
WHERE
	WR1 : SELF\si_unit.name = si_unit_name.becquerel;
	WR2 : NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;


ENTITY si_resistance_unit
	SUBTYPE OF (resistance_unit, si_unit);
WHERE
	WR1 : SELF\si_unit.name = si_unit_name.ohm;
	WR2 : NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;


ENTITY si_unit
	SUBTYPE OF (named_unit);
	prefix : OPTIONAL si_prefix;
	name : si_unit_name;
DERIVE
	SELF\named_unit.dimensions : dimensional_exponents := dimensions_for_si_unit(name);
WHERE
	WR1 : NOT(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MASS_UNIT' IN TYPEOF(SELF)) AND
             (SIZEOF(USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DERIVED_UNIT_ELEMENT.UNIT')) > 0)) OR
            (prefix = si_prefix.kilo);
END_ENTITY;


ENTITY simple_boolean_expression
	ABSTRACT SUPERTYPE OF (ONEOF (boolean_literal, boolean_variable))
	SUBTYPE OF (boolean_expression, simple_generic_expression);
END_ENTITY;


ENTITY simple_clause
	SUBTYPE OF (compound_representation_item);
END_ENTITY;


ENTITY simple_generic_expression
	ABSTRACT SUPERTYPE OF (ONEOF (generic_literal, generic_variable))
	SUBTYPE OF (generic_expression);
END_ENTITY;


ENTITY simple_numeric_expression
	ABSTRACT SUPERTYPE OF (ONEOF (literal_number, numeric_variable))
	SUBTYPE OF (numeric_expression, simple_generic_expression);
END_ENTITY;


ENTITY simple_plane_2d_element_property
	SUBTYPE OF (plane_2d_element_property);
END_ENTITY;


ENTITY simple_string_expression
	ABSTRACT SUPERTYPE OF (ONEOF (string_literal, string_variable))
	SUBTYPE OF (string_expression, simple_generic_expression);
END_ENTITY;


ENTITY simulation_run;
	id : identifier;
	name : label;
	description : text;
	simulated : numerical_model;
	results : SET [0:?] OF model_property_distribution;
END_ENTITY;


ENTITY sin_function
	SUBTYPE OF (unary_function_call);
END_ENTITY;


ENTITY single_point_constraint_element
	SUBTYPE OF (constraint_element);
	required_node : node_output_reference;
	coordinate_system : fea_axis2_placement_3d;
	freedoms_and_values : SET [1:?] OF freedom_and_coefficient;
	description : text;
END_ENTITY;


ENTITY single_point_constraint_element_values
	SUBTYPE OF (state_definition);
	element : single_point_constraint_element;
	degrees_of_freedom : freedoms_list;
	b : LIST [1:?] OF measure_or_unspecified_value;
WHERE
	WR1 : SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (b);
END_ENTITY;


ENTITY slash_expression
	SUBTYPE OF (binary_numeric_expression);
END_ENTITY;


ENTITY smeared_material_definition
	SUBTYPE OF (zone_structural_makeup);
END_ENTITY;


ENTITY solid_angle_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY solid_angle_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;


ENTITY solid_constraint
	SUBTYPE OF (constraint_element);
	required_solid : analysis_item_within_representation;
	coordinate_system : fea_axis2_placement_3d;
	freedoms_and_coefficients : SET [1:?] OF freedom_and_coefficient;
	description : text;
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_MODEL' IN TYPEOF (required_solid.item);
END_ENTITY;


ENTITY solid_curve_font
	SUBTYPE OF (pre_defined_curve_font);
END_ENTITY;


ENTITY solid_freedom_action_definition
	SUBTYPE OF (solid_freedom_and_value_definition);
	action : action_type;
END_ENTITY;


ENTITY solid_freedom_and_value_definition
	SUPERTYPE OF (ONEOF (solid_freedom_values, solid_freedom_action_definition))
	SUBTYPE OF (state_definition);
	required_solid : analysis_item_within_representation;
	coordinate_system : fea_axis2_placement_3d;
	degrees_of_freedom : freedoms_list;
	values : LIST [1:?] OF measure_or_unspecified_value;
WHERE
	WR1 : SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (values);
	WR2 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_MODEL' IN TYPEOF (required_solid.item);
END_ENTITY;


ENTITY solid_freedom_values
	SUBTYPE OF (solid_freedom_and_value_definition);
END_ENTITY;


ENTITY solid_model
	SUPERTYPE OF (ONEOF (csg_solid, manifold_solid_brep, swept_face_solid, swept_area_solid, swept_disk_solid, solid_replica))
	SUBTYPE OF (geometric_representation_item);
END_ENTITY;


ENTITY solid_replica
	SUBTYPE OF (solid_model);
	parent_solid : solid_model;
	transformation : cartesian_transformation_operator_3d;
WHERE
	WR1 : acyclic_solid_replica(SELF, parent_solid);
	WR2 : parent_solid\geometric_representation_item.dim = 3;
END_ENTITY;


ENTITY solid_with_angle_based_chamfer
	SUBTYPE OF (solid_with_chamfered_edges);
	offset_distance : positive_length_measure;
	left_offset : BOOLEAN;
	offset_angle : positive_plane_angle_measure;
END_ENTITY;


ENTITY solid_with_chamfered_edges
	ABSTRACT SUPERTYPE OF (ONEOF (solid_with_single_offset_chamfer, solid_with_double_offset_chamfer, solid_with_angle_based_chamfer))
	SUBTYPE OF (edge_blended_solid);
END_ENTITY;


ENTITY solid_with_circular_pattern
	SUPERTYPE OF (solid_with_incomplete_circular_pattern)
	SUBTYPE OF (solid_with_shape_element_pattern);
	replicate_count : positive_integer;
	angular_spacing : plane_angle_measure;
	radial_alignment : BOOLEAN;
	reference_point : point;
END_ENTITY;


ENTITY solid_with_circular_pocket
	SUBTYPE OF (solid_with_pocket);
	pocket_radius : positive_length_measure;
WHERE
	WR1 : SELF\solid_with_pocket.floor_blend_radius <= pocket_radius;
END_ENTITY;


ENTITY solid_with_circular_protrusion
	SUBTYPE OF (solid_with_protrusion);
	protrusion_radius : positive_length_measure;
END_ENTITY;


ENTITY solid_with_conical_bottom_round_hole
	SUBTYPE OF (solid_with_stepped_round_hole);
	semi_apex_angle : positive_plane_angle_measure;
	tip_radius : non_negative_length_measure;
WHERE
	WR1 : tip_radius < 
          SELF\solid_with_stepped_round_hole.segment_radii[segments];
END_ENTITY;


ENTITY solid_with_constant_radius_edge_blend
	SUBTYPE OF (edge_blended_solid);
	radius : positive_length_measure;
END_ENTITY;


ENTITY solid_with_curved_slot
	SUBTYPE OF (solid_with_slot);
	slot_centreline : bounded_curve;
END_ENTITY;


ENTITY solid_with_depression
	ABSTRACT SUPERTYPE OF ((solid_with_through_depression ANDOR ONEOF (solid_with_hole, solid_with_pocket, solid_with_slot, solid_with_groove)))
	SUBTYPE OF (modified_solid_with_placed_configuration);
	depth : positive_length_measure;
END_ENTITY;


ENTITY solid_with_double_offset_chamfer
	SUBTYPE OF (solid_with_chamfered_edges);
	left_offset_distance : positive_length_measure;
	right_offset_distance : positive_length_measure;
END_ENTITY;


ENTITY solid_with_flat_bottom_round_hole
	SUBTYPE OF (solid_with_stepped_round_hole);
	fillet_radius : non_negative_length_measure;
WHERE
	WR1 : fillet_radius < 
          SELF\solid_with_stepped_round_hole.segment_radii[segments];
END_ENTITY;


ENTITY solid_with_general_pocket
	SUBTYPE OF (solid_with_pocket);
	profile : positioned_sketch;
	reference_point : point;
WHERE
	WR1 : SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_BOUNDED_SURFACE',
    'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_SURFACE'] * TYPEOF(profile.sketch_basis)) = 1;
	WR2 : profile IN using_items(reference_point,[]);
END_ENTITY;


ENTITY solid_with_general_protrusion
	SUBTYPE OF (solid_with_protrusion);
	profile : positioned_sketch;
	reference_point : point;
WHERE
	WR1 : SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_BOUNDED_SURFACE',
    'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_SURFACE'] * TYPEOF(profile.sketch_basis)) = 1;
	WR2 : profile IN using_items(reference_point,[]);
END_ENTITY;


ENTITY solid_with_groove
	SUBTYPE OF (solid_with_depression);
	groove_radius : positive_length_measure;
	groove_width : positive_length_measure;
	draft_angle : plane_angle_measure;
	floor_fillet_radius : non_negative_length_measure;
	external_groove : BOOLEAN;
WHERE
	WR1 : NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_WITH_THROUGH_DEPRESSION'
         IN TYPEOF(SELF));
END_ENTITY;


ENTITY solid_with_hole
	ABSTRACT SUPERTYPE OF (solid_with_stepped_round_hole)
	SUBTYPE OF (solid_with_depression);
END_ENTITY;


ENTITY solid_with_incomplete_circular_pattern
	SUBTYPE OF (solid_with_circular_pattern);
	omitted_instances : SET [1:?] OF positive_integer;
WHERE
	WR1 : SIZEOF(omitted_instances) <
         SELF\solid_with_circular_pattern.replicate_count;
	WR2 : SIZEOF(QUERY(q <* omitted_instances | q > 
         SELF\solid_with_circular_pattern.replicate_count)) = 0;
END_ENTITY;


ENTITY solid_with_incomplete_rectangular_pattern
	SUBTYPE OF (solid_with_rectangular_pattern);
	omitted_instances : SET [1:?] OF LIST [2:2] OF positive_integer;
WHERE
	WR1 : NOT([1,1] IN omitted_instances);
	WR2 : SIZEOF(omitted_instances) <
         ((SELF\solid_with_rectangular_pattern.row_count *
           SELF\solid_with_rectangular_pattern.column_count) - 1);
	WR3 : SIZEOF(QUERY(q <* omitted_instances |
         ((q[1] > SELF\solid_with_rectangular_pattern.row_count) OR
          (q[2] > SELF\solid_with_rectangular_pattern.column_count)))) = 0;
END_ENTITY;


ENTITY solid_with_pocket
	ABSTRACT SUPERTYPE OF (ONEOF (solid_with_rectangular_pocket, solid_with_circular_pocket, solid_with_general_pocket))
	SUBTYPE OF (solid_with_depression);
	floor_blend_radius : non_negative_length_measure;
	draft_angle : plane_angle_measure;
END_ENTITY;


ENTITY solid_with_protrusion
	ABSTRACT SUPERTYPE OF (ONEOF (solid_with_circular_protrusion, solid_with_rectangular_protrusion, solid_with_general_protrusion))
	SUBTYPE OF (modified_solid_with_placed_configuration);
	protrusion_height : positive_length_measure;
	protrusion_draft_angle : plane_angle_measure;
END_ENTITY;


ENTITY solid_with_rectangular_pattern
	SUPERTYPE OF (solid_with_incomplete_rectangular_pattern)
	SUBTYPE OF (solid_with_shape_element_pattern);
	row_count : positive_integer;
	column_count : positive_integer;
	row_spacing : length_measure;
	column_spacing : length_measure;
WHERE
	WR1 : (row_count * column_count) > 1;
END_ENTITY;


ENTITY solid_with_rectangular_pocket
	SUBTYPE OF (solid_with_pocket);
	pocket_length : positive_length_measure;
	pocket_width : positive_length_measure;
	corner_radius : non_negative_length_measure;
WHERE
	WR1 : (corner_radius < pocket_width/2) 
         AND (corner_radius < pocket_length/2);
END_ENTITY;


ENTITY solid_with_rectangular_protrusion
	SUBTYPE OF (solid_with_protrusion);
	protrusion_length : positive_length_measure;
	protrusion_width : positive_length_measure;
	protrusion_corner_radius : non_negative_length_measure;
WHERE
	WR1 : (protrusion_corner_radius <= protrusion_width/2) 
         AND (protrusion_corner_radius <= protrusion_length/2);
END_ENTITY;


ENTITY solid_with_shape_element_pattern
	ABSTRACT SUPERTYPE OF (ONEOF (solid_with_circular_pattern, solid_with_rectangular_pattern))
	SUBTYPE OF (modified_solid_with_placed_configuration);
	replicated_element : modified_solid_with_placed_configuration;
END_ENTITY;


ENTITY solid_with_single_offset_chamfer
	SUBTYPE OF (solid_with_chamfered_edges);
	offset_distance : positive_length_measure;
END_ENTITY;


ENTITY solid_with_slot
	ABSTRACT SUPERTYPE OF ((ONEOF (solid_with_trapezoidal_section_slot, solid_with_tee_section_slot) AND ONEOF (solid_with_straight_slot, solid_with_curved_slot)))
	SUBTYPE OF (solid_with_depression);
	slot_width : positive_length_measure;
	closed_ends : LIST [2:2] OF LOGICAL;
	end_exit_faces : LIST [2:2] OF SET [0:?] OF face_surface;
WHERE
	WR1 : NOT(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_WITH_THROUGH_DEPRESSION' IN
         TYPEOF(SELF)) AND (closed_ends = [FALSE,FALSE]));
	WR2 : NOT(((closed_ends[1] = TRUE) AND (SIZEOF(end_exit_faces[1]) <> 0))
         OR ((closed_ends[2] = TRUE) AND (SIZEOF(end_exit_faces[2]) <> 0)));
END_ENTITY;


ENTITY solid_with_spherical_bottom_round_hole
	SUBTYPE OF (solid_with_stepped_round_hole);
	sphere_radius : positive_length_measure;
WHERE
	WR1 : sphere_radius >= 
          SELF\solid_with_stepped_round_hole.segment_radii[segments];
END_ENTITY;


ENTITY solid_with_stepped_round_hole
	SUPERTYPE OF ((solid_with_stepped_round_hole_and_conical_transitions ANDOR ONEOF (solid_with_flat_bottom_round_hole, solid_with_conical_bottom_round_hole, solid_with_spherical_bottom_round_hole)))
	SUBTYPE OF (solid_with_hole);
	segments : positive_integer;
	segment_radii : LIST [1:segments] OF positive_length_measure;
	segment_depths : LIST [1:segments] OF positive_length_measure;
DERIVE
	SELF\solid_with_depression.depth : positive_length_measure := compute_total_depth(SELF);
WHERE
	WR1 : NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_WITH_THROUGH_DEPRESSION'
       IN TYPEOF(SELF)) AND (SIZEOF(TYPEOF(SELF) *
       ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_WITH_FLAT_BOTTOM_ROUND_HOLE',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_WITH_SPHERICAL_BOTTOM_ROUND_HOLE',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_WITH_FLAT_BOTTOM_ROUND_HOLE']) 
       <> 0));
END_ENTITY;


ENTITY solid_with_stepped_round_hole_and_conical_transitions
	SUBTYPE OF (solid_with_stepped_round_hole);
	conical_transitions : SET [1:?] OF conical_stepped_hole_transition;
WHERE
	WR1 : SIZEOF (conical_transitions) <= 
         (SELF\solid_with_stepped_round_hole.segments + 1);
	WR2 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_WITH_THROUGH_DEPRESSION'
         IN TYPEOF(SELF)) XOR (SIZEOF(conical_transitions) <= 
         SELF\solid_with_stepped_round_hole.segments);
	WR3 : validate_countersink_radii(SELF);
END_ENTITY;


ENTITY solid_with_straight_slot
	SUBTYPE OF (solid_with_slot);
	slot_length : positive_length_measure;
END_ENTITY;


ENTITY solid_with_tee_section_slot
	SUBTYPE OF (solid_with_slot);
	tee_section_width : positive_length_measure;
	collar_depth : positive_length_measure;
WHERE
	WR1 : collar_depth < SELF\solid_with_depression.depth;
	WR2 : tee_section_width > SELF\solid_with_slot.slot_width;
END_ENTITY;


ENTITY solid_with_through_depression
	SUBTYPE OF (solid_with_depression);
	exit_faces : SET [1:?] OF face_surface;
WHERE
	WR1 : SIZEOF(TYPEOF(SELF) *
         ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_WITH_HOLE',
          'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_WITH_POCKET',
          'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_WITH_SLOT']) = 1;
END_ENTITY;


ENTITY solid_with_trapezoidal_section_slot
	SUBTYPE OF (solid_with_slot);
	draft_angle : plane_angle_measure;
	floor_fillet_radius : non_negative_length_measure;
END_ENTITY;


ENTITY solid_with_variable_radius_edge_blend
	SUBTYPE OF (edge_blended_solid, track_blended_solid);
	point_list : LIST [2:?] OF point;
	radius_list : LIST [2:?] OF positive_length_measure;
	edge_function_list : LIST [1:?] OF blend_radius_variation_type;
WHERE
	WR1 : SIZEOF(point_list) = SIZEOF(radius_list);
	WR2 : SIZEOF(edge_function_list) = SIZEOF(radius_list) - 1;
	WR3 : NOT((point_list[1] = point_list[HIINDEX(point_list)]) AND NOT 
         (radius_list[1] = radius_list[HIINDEX(radius_list)]));
END_ENTITY;


ENTITY source_for_requirement
	SUBTYPE OF (group_assignment);
	items : SET [1:1] OF requirement_source_item;
	SELF\group_assignment.assigned_group : requirement_source;
END_ENTITY;


ENTITY sourced_requirement
	SUBTYPE OF (group_assignment);
	items : SET [1:1] OF product_definition;
	SELF\group_assignment.assigned_group : requirement_source;
END_ENTITY;


ENTITY space_for_physical_quantity
	SUBTYPE OF (general_property_relationship);
	SELF\general_property_relationship.related_property : physical_quantity_instance;
	SELF\general_property_relationship.relating_property : physical_quantity_space;
END_ENTITY;


ENTITY spatial_decomposition_of_numerical_model;
	parts : SET [2:?] OF numerical_model;
	whole : numerical_model;
END_ENTITY;


ENTITY spatial_decomposition_of_temporal_spatial_domain;
	parts : SET [2:?] OF temporal_spatial_domain;
	whole : temporal_spatial_domain;
END_ENTITY;


ENTITY specification_definition
	SUBTYPE OF (product_definition);
END_ENTITY;


ENTITY specified_general_property
	SUBTYPE OF (general_property);
	name_specifier : choose_general_property_identifier;
END_ENTITY;


ENTITY specified_higher_usage_occurrence
	SUBTYPE OF (assembly_component_usage);
	upper_usage : assembly_component_usage;
	next_usage : next_assembly_usage_occurrence;
UNIQUE
	UR1 : upper_usage, next_usage;
WHERE
	WR1 : SELF :<>: upper_usage;
	WR2 : SELF\product_definition_relationship.relating_product_definition
       :=: upper_usage.relating_product_definition;
	WR3 : SELF\product_definition_relationship.related_product_definition
       :=: next_usage.related_product_definition;
	WR4 : (upper_usage.related_product_definition :=:
       next_usage.relating_product_definition) OR
       (SIZEOF (QUERY (pdr <* USEDIN (upper_usage.related_product_definition,
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
        pdr.relating_product_definition :=: 
        next_usage.relating_product_definition)) = 1);
	WR5 : SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NEXT_ASSEMBLY_USAGE_OCCURRENCE',
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SPECIFIED_HIGHER_USAGE_OCCURRENCE']
       * TYPEOF(upper_usage)) = 1;
END_ENTITY;


ENTITY specified_representation_context
	SUBTYPE OF (representation_context);
	class_specifier : choose_representation_context_identifier;
END_ENTITY;


ENTITY specified_state
	SUBTYPE OF (state);
END_ENTITY;


ENTITY sphere
	SUBTYPE OF (geometric_representation_item);
	radius : positive_length_measure;
	centre : point;
END_ENTITY;


ENTITY spherical_point
	SUBTYPE OF (cartesian_point);
	r : length_measure;
	theta : plane_angle_measure;
	phi : plane_angle_measure;
DERIVE
	SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure := [r*sin(theta)*cos(phi), r*sin(theta)*sin(phi), r*cos(theta)];
WHERE
	WR1 : r >= 0.0;
END_ENTITY;


ENTITY spherical_surface
	SUBTYPE OF (elementary_surface);
	radius : positive_length_measure;
END_ENTITY;


ENTITY SQL_mappable_defined_function
	ABSTRACT SUPERTYPE
	SUBTYPE OF (defined_function);
END_ENTITY;


ENTITY square_root_function
	SUBTYPE OF (unary_function_call);
END_ENTITY;


ENTITY standard_physical_quantity_symmetry
	SUBTYPE OF (physical_quantity_symmetry_by_library_reference);
WHERE
	valid_standard_class : (SELF\physical_quantity_symmetry_by_library_reference\externally_defined_item.source.source_id = 'ISO-TS-10303-1099') AND (SELF\physical_quantity_symmetry_by_library_reference\externally_defined_item.item_id IN ['PS001', 'PS002', 'PS003', 'PS004', 'PS005', 'PS006', 'PS007', 'PS008', 'PS009', 'PS010', 'PS011', 'PS012', 'PS013']);
END_ENTITY;


ENTITY standard_table_function
	SUBTYPE OF (linearized_table_function);
	order : ordering_type;
WHERE
	WR1 : extremal_position_check(SELF);
END_ENTITY;


ENTITY standard_tensor_order_and_symmetry
	SUBTYPE OF (tensor_order_and_symmetry_by_library_reference);
WHERE
	valid_standard_class : (SELF\tensor_order_and_symmetry_by_library_reference\externally_defined_item.source.source_id = 'ISO-TS-10303-1080') AND (SELF\tensor_order_and_symmetry_by_library_reference\externally_defined_item.item_id IN ['TO001', 'TO002', 'TO003', 'TO004', 'TO005', 'TO006', 'TO007', 'TO008', 'TO009']);
END_ENTITY;


ENTITY standard_uncertainty
	SUPERTYPE OF (expanded_uncertainty)
	SUBTYPE OF (uncertainty_qualifier);
	uncertainty_value : REAL;
END_ENTITY;


ENTITY start_request
	SUBTYPE OF (action_request_assignment);
	items : SET [1:?] OF start_request_item;
END_ENTITY;


ENTITY start_work
	SUBTYPE OF (action_assignment);
	items : SET [1:?] OF work_item;
END_ENTITY;


ENTITY state
	SUPERTYPE OF (ONEOF (specified_state, calculated_state, linearly_superimposed_state, output_request_state));
	state_id : identifier;
	description : text;
END_ENTITY;


ENTITY state_component
	SUBTYPE OF (state);
	state : linearly_superimposed_state;
	factor : context_dependent_measure;
END_ENTITY;


ENTITY state_definition
	SUPERTYPE OF (ONEOF (field_variable_definition, nodal_freedom_and_value_definition, element_nodal_freedom_actions, point_freedom_and_value_definition, curve_freedom_and_value_definition, surface_freedom_and_value_definition, solid_freedom_and_value_definition, linear_constraint_equation_element_value, single_point_constraint_element_values, analysis_message));
	defined_state : state;
END_ENTITY;


ENTITY state_relationship;
	name : label;
	description : text;
	relating_state : state;
	related_state : state;
END_ENTITY;


ENTITY state_type;
	name : label;
	description : OPTIONAL text;
END_ENTITY;


ENTITY state_type_assignment
	ABSTRACT SUPERTYPE;
	assigned_state_type : state_type;
	role : state_type_role;
END_ENTITY;


ENTITY state_type_relationship;
	name : label;
	description : OPTIONAL text;
	relating_state_type : SET [1:?] OF state_type;
	related_state_type : SET [1:?] OF state_type;
END_ENTITY;


ENTITY state_type_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY;


ENTITY state_view_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	discretised_model : discretised_state_model_select;
	idealised_state : idealised_state_select;
END_ENTITY;


ENTITY state_with_harmonic
	SUBTYPE OF (state);
	symmetry : cylindrical_symmetry_control;
END_ENTITY;


ENTITY stationary_mass
	SUBTYPE OF (point_element_matrix);
	mass : ARRAY [1:3] OF context_dependent_measure;
	moments_of_inertia : symmetric_tensor2_3d;
	coordinate_system : fea_axis2_placement_3d;
	offset_vector : ARRAY [1:3] OF context_dependent_measure;
END_ENTITY;


ENTITY straightness_tolerance
	SUBTYPE OF (geometric_tolerance);
WHERE
	WR1 : NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF));
END_ENTITY;


ENTITY strict_triangular_matrix
	SUBTYPE OF (triangular_matrix);
	main_diagonal_value : maths_value;
END_ENTITY;


ENTITY string_defined_function
	ABSTRACT SUPERTYPE
	SUBTYPE OF (defined_function, string_expression);
END_ENTITY;


ENTITY string_expression
	ABSTRACT SUPERTYPE OF (ONEOF (simple_string_expression, index_expression, substring_expression, concat_expression, format_function, string_defined_function))
	SUBTYPE OF (expression);
END_ENTITY;


ENTITY string_literal
	SUBTYPE OF (simple_string_expression, generic_literal);
	the_value : STRING;
END_ENTITY;


ENTITY string_variable
	SUBTYPE OF (simple_string_expression, variable);
END_ENTITY;


ENTITY structural_response_property
	SUBTYPE OF (property_definition);
END_ENTITY;


ENTITY structural_response_property_definition_representation
	SUBTYPE OF (property_definition_representation);
WHERE
	WR1 : (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
         'STRUCTURAL_RESPONSE_PROPERTY') IN TYPEOF 
         (SELF\property_definition_representation.definition));
	WR2 : ((('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FEA_MODEL'
        IN TYPEOF 
        (SELF\property_definition_representation.used_representation))
        AND
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FEA_MODEL_DEFINITION'
        IN TYPEOF 
        (SELF\property_definition_representation.definition.definition)))
       OR
      (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELEMENT_REPRESENTATION'
        IN TYPEOF 
        (SELF\property_definition_representation.used_representation))
        AND
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELEMENT_DEFINITION'
        IN TYPEOF 
        (SELF\property_definition_representation.definition.definition)))
       OR
      (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NODE_REPRESENTATION'
        IN TYPEOF 
        (SELF\property_definition_representation.used_representation))
        AND
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NODE_DEFINITION'
        IN TYPEOF 
        (SELF\property_definition_representation.definition.definition))));
END_ENTITY;


ENTITY structured_dimension_callout
	SUBTYPE OF (draughting_callout);
WHERE
	WR1 : SIZEOF (TYPEOF (SELF) *
       ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DATUM_FEATURE_CALLOUT',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DATUM_TARGET_CALLOUT',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRICAL_TOLERANCE_CALLOUT',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_DIRECTED_CALLOUT',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROJECTION_DIRECTED_CALLOUT',
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIMENSION_CURVE_DIRECTED_CALLOUT']) = 0;
	WR2 : SIZEOF (QUERY (ato <* QUERY (con <* SELF.contents |
         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (con))) |
         NOT (ato.name IN
             ['dimension value', 'tolerance value', 'unit text',
              'prefix text', 'suffix text']))) = 0;
	WR3 : SIZEOF (QUERY (ato <* QUERY (con <* SELF.contents |
         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (con))) |
         (ato.name = 'dimension value')
       )) >= 1;
	WR4 : SIZEOF (QUERY (dcr <* USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
         'DRAUGHTING_CALLOUT_RELATIONSHIP.' +
         'RELATING_DRAUGHTING_CALLOUT') |
         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
          'DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP' IN TYPEOF (dcr)) AND 
         (dcr.name = 'prefix') )) <= 1;
	WR5 : SIZEOF (QUERY (dcr <* USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
         'DRAUGHTING_CALLOUT_RELATIONSHIP.' +
         'RELATING_DRAUGHTING_CALLOUT') |
         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
          'DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP' IN TYPEOF (dcr)) AND 
         (dcr.name = 'suffix') )) <= 1;
	WR6 : NOT((SIZEOF (QUERY (ato <* QUERY (con <* SELF.contents |
         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(con)) ) |
         (ato.name = 'prefix text')
       )) > 0)) OR
       (SIZEOF (QUERY (dcr <* USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                               'DRAUGHTING_CALLOUT_RELATIONSHIP.' +
                               'RELATING_DRAUGHTING_CALLOUT') |
         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
          'DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP' IN TYPEOF (dcr)) AND  
         (dcr.name = 'prefix') )) = 1);
	WR7 : NOT(SIZEOF (QUERY (ato <* QUERY (con <* SELF.contents |
         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(con))) |
         (ato.name = 'suffix text')
       )) > 0) OR
       (SIZEOF (QUERY (dcr <* USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                               'DRAUGHTING_CALLOUT_RELATIONSHIP.' +
                               'RELATING_DRAUGHTING_CALLOUT') |
         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
          'DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP' IN TYPEOF (dcr)) AND    
            (dcr.name = 'suffix') )) = 1);
END_ENTITY;


ENTITY structured_donor_mesh
	SUBTYPE OF (mismatched_donor_mesh);
	points : listed_real_data;
	vsize : INTEGER;
	SELF\mismatched_donor_mesh.donor : structured_mesh;
DERIVE
	index_count : INTEGER := donor.index_count;
END_ENTITY;


ENTITY structured_mesh
	SUBTYPE OF (mesh);
	vertex_counts : ARRAY [1:SELF\mesh.index_count] OF INTEGER;
	cell_counts : ARRAY [1:SELF\mesh.index_count] OF INTEGER;
	kind : structured_mesh_type;
END_ENTITY;


ENTITY structured_mesh_with_rind
	SUBTYPE OF (structured_mesh);
	rind_planes : rind;
END_ENTITY;


ENTITY structured_text_composition
	SUBTYPE OF (compound_representation_item);
END_ENTITY;


ENTITY structured_text_representation
	SUBTYPE OF (representation);
	SELF\representation.items : SET [1:?] OF string_representation_item_select;
END_ENTITY;


ENTITY styled_item
	SUBTYPE OF (representation_item);
	styles : SET [1:?] OF presentation_style_assignment;
	item : representation_item;
WHERE
	WR1 : (SIZEOF(SELF.styles) = 1)
               XOR
         (SIZEOF(QUERY(pres_style <* SELF.styles |
         NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
              'PRESENTATION_STYLE_BY_CONTEXT' IN
         TYPEOF(pres_style))
         )) = 0);
END_ENTITY;


ENTITY subedge
	SUBTYPE OF (edge);
	parent_edge : edge;
END_ENTITY;


ENTITY subface
	SUBTYPE OF (face);
	parent_face : face;
WHERE
	WR1 : NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF)) +
              list_to_set(list_face_loops(parent_face))));
END_ENTITY;


ENTITY submesh
	SUBTYPE OF (mesh);
END_ENTITY;


ENTITY substring_expression
	SUBTYPE OF (string_expression, multiple_arity_generic_expression);
DERIVE
	index1 : generic_expression := SELF\multiple_arity_generic_expression.operands[2];
	index2 : generic_expression := SELF\multiple_arity_generic_expression.operands[3];
	operand : generic_expression := SELF\multiple_arity_generic_expression.operands[1];
WHERE
	WR1 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRING_EXPRESSION' 
					IN TYPEOF(operand))
			AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NUMERIC_EXPRESSION' 
					IN TYPEOF(index1))
			AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NUMERIC_EXPRESSION' 
					IN TYPEOF(index2));
	WR2 : SIZEOF(SELF\multiple_arity_generic_expression.operands)=3;
	WR3 : is_int_expr (index1);
	WR4 : is_int_expr (index2);
END_ENTITY;


ENTITY substructure_element_representation
	SUBTYPE OF (element_representation);
	model_ref : fea_model;
	substructure_model_ref : fea_model;
UNIQUE
	UR1 : model_ref, SELF\representation.name;
END_ENTITY;


ENTITY substructure_node_reference;
	substructure_element_ref : substructure_element_representation;
	node_ref : node_representation;
END_ENTITY;


ENTITY substructure_node_relationship
	SUBTYPE OF (representation_relationship);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NODE_REPRESENTATION' 
        IN TYPEOF (SELF\representation_relationship.rep_1);
	WR2 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NODE_REPRESENTATION' 
        IN TYPEOF (SELF\representation_relationship.rep_2);
END_ENTITY;


ENTITY supplied_part_relationship
	SUBTYPE OF (product_definition_relationship);
END_ENTITY;


ENTITY surface
	SUPERTYPE OF (ONEOF (elementary_surface, swept_surface, bounded_surface, offset_surface, surface_replica))
	SUBTYPE OF (geometric_representation_item);
END_ENTITY;


ENTITY surface_2d_element_basis;
	descriptor : surface_2d_element_descriptor;
	variable : surface_element_variable;
	variable_order : element_order;
	variable_shape_function : shape_function;
	evaluation_points : LIST [1:?] OF surface_element_location;
END_ENTITY;


ENTITY surface_2d_element_boundary_constant_specified_surface_variable_value
	SUBTYPE OF (surface_2d_element_field_variable_definition);
	simple_value : field_value;
	variable : boundary_variable;
	element_face : surface_2d_face;
	coordinate_system : OPTIONAL surface_2d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_2d_element_boundary_constant_specified_variable_value
	SUBTYPE OF (surface_2d_element_field_variable_definition);
	simple_value : field_value;
	variable : boundary_aggregated_variable;
	element_face : surface_2d_face;
	coordinate_system : OPTIONAL surface_2d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_2d_element_boundary_edge_constant_specified_surface_variable_value
	SUBTYPE OF (surface_2d_element_field_variable_definition);
	simple_value : field_value;
	variable : boundary_edge_variable;
	element_edge : surface_2d_edge;
	coordinate_system : OPTIONAL surface_2d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_2d_element_boundary_edge_constant_specified_variable_value
	SUBTYPE OF (surface_2d_element_field_variable_definition);
	simple_value : field_value;
	variable : boundary_edge_variable;
	element_edge : surface_2d_edge;
	coordinate_system : OPTIONAL surface_2d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_2d_element_boundary_edge_location_point_surface_variable_values
	SUBTYPE OF (surface_2d_element_field_variable_definition);
	basis : BOOLEAN;
	values_and_locations : SET [1:?] OF surface_2d_element_value_and_volume_location;
	variable : boundary_edge_variable;
	element_edge : surface_2d_edge;
WHERE
	WR1 : consistent_set_values (values_and_locations, variable);
	WR2 : appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_2d_element_boundary_edge_location_point_variable_values
	SUBTYPE OF (surface_2d_element_field_variable_definition);
	basis : BOOLEAN;
	values_and_locations : SET [1:?] OF surface_2d_element_value_and_location;
	variable : boundary_edge_variable;
	element_edge : surface_2d_edge;
WHERE
	WR1 : consistent_set_values (values_and_locations, variable);
	WR2 : appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_2d_element_boundary_edge_nodal_specified_variable_values
	SUBTYPE OF (surface_2d_element_field_variable_definition);
	values : LIST [1:?] OF field_value;
	additional_node_values : BOOLEAN;
	variable : boundary_edge_variable;
	element_edge : surface_2d_edge;
WHERE
	WR1 : consistent_list_values (values, variable);
	WR2 : appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_2d_element_boundary_edge_whole_edge_variable_value
	SUBTYPE OF (surface_2d_element_field_variable_definition);
	simple_value : field_value;
	variable : boundary_aggregated_variable;
	element_edge : surface_2d_edge;
	coordinate_system : OPTIONAL surface_2d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_2d_element_boundary_location_point_surface_variable_values
	SUBTYPE OF (surface_2d_element_field_variable_definition);
	basis : BOOLEAN;
	values_and_locations : SET [1:?] OF surface_2d_element_value_and_location;
	variable : boundary_variable;
	element_face : surface_2d_face;
WHERE
	WR1 : consistent_set_values (values_and_locations, variable);
	WR2 : appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_2d_element_boundary_nodal_specified_variable_values
	SUBTYPE OF (surface_2d_element_field_variable_definition);
	values : LIST [1:?] OF field_value;
	additional_node_values : BOOLEAN;
	variable : boundary_variable;
	element_face : surface_2d_face;
WHERE
	WR1 : consistent_list_values (values, variable);
	WR2 : appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_2d_element_boundary_whole_face_variable_value
	SUBTYPE OF (surface_2d_element_field_variable_definition);
	simple_value : field_value;
	variable : boundary_aggregated_variable;
	element_face : surface_2d_face;
	coordinate_system : OPTIONAL surface_2d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_2d_element_constant_specified_variable_value
	SUBTYPE OF (surface_2d_element_field_variable_definition);
	simple_value : field_value;
	variable : surface_element_variable;
	coordinate_system : OPTIONAL surface_2d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_2d_element_constant_specified_volume_variable_value
	SUBTYPE OF (surface_2d_element_field_variable_definition);
	simple_value : field_value;
	variable : volume_variable;
	coordinate_system : OPTIONAL surface_2d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_2d_element_field_variable_definition
	SUPERTYPE OF (ONEOF (surface_2d_element_location_point_volume_variable_values, surface_2d_element_location_point_variable_values, surface_2d_whole_element_variable_value, surface_2d_element_constant_specified_variable_value, surface_2d_element_constant_specified_volume_variable_value, surface_2d_element_nodal_specified_variable_values, surface_2d_element_boundary_location_point_surface_variable_values, surface_2d_element_boundary_whole_face_variable_value, surface_2d_element_boundary_constant_specified_variable_value, surface_2d_element_boundary_constant_specified_surface_variable_value, surface_2d_element_boundary_nodal_specified_variable_values, surface_2d_element_boundary_edge_location_point_surface_variable_values, surface_2d_element_boundary_edge_location_point_variable_values, surface_2d_element_boundary_edge_whole_edge_variable_value, surface_2d_element_boundary_edge_constant_specified_variable_value, surface_2d_element_boundary_edge_constant_specified_surface_variable_value, surface_2d_element_boundary_edge_nodal_specified_variable_values))
	SUBTYPE OF (field_variable_element_definition);
	element : surface_2d_element_output_reference;
END_ENTITY;


ENTITY surface_2d_element_group
	SUBTYPE OF (element_group);
WHERE
	WR1 : SIZEOF(QUERY(item <* elements |
       (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
             'AXISYMMETRIC_SURFACE_2D_ELEMENT_REPRESENTATION'
              IN TYPEOF(item)) AND
        NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
             'PLANE_SURFACE_2D_ELEMENT_REPRESENTATION'
              IN TYPEOF(item)))))=0;
END_ENTITY;


ENTITY surface_2d_element_integrated_matrix;
	descriptor : surface_2d_element_descriptor;
	property_type : surface_matrix_property_type;
	integration_description : text;
END_ENTITY;


ENTITY surface_2d_element_integrated_matrix_with_definition
	SUBTYPE OF (surface_2d_element_integrated_matrix);
	integration_definition : surface_2d_element_integration;
END_ENTITY;


ENTITY surface_2d_element_integration;
	element_length : surface_2d_element_length_integration;
	section : surface_section_integration;
END_ENTITY;


ENTITY surface_2d_element_length_integration_explicit;
	integration_positions_and_weights : SET [1:?] OF surface_position_weight;
END_ENTITY;


ENTITY surface_2d_element_length_integration_rule;
	integration_method : integration_rule;
	integration_order : INTEGER;
END_ENTITY;


ENTITY surface_2d_element_location_point_variable_values
	SUBTYPE OF (surface_2d_element_field_variable_definition);
	basis : BOOLEAN;
	values_and_locations : SET [1:?] OF surface_2d_element_value_and_location;
	variable : surface_element_variable;
WHERE
	WR1 : consistent_set_values (values_and_locations, variable);
	WR2 : appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_2d_element_location_point_volume_variable_values
	SUBTYPE OF (surface_2d_element_field_variable_definition);
	basis : BOOLEAN;
	values_and_locations : SET [1:?] OF surface_2d_element_value_and_volume_location;
	variable : volume_variable;
WHERE
	WR1 : consistent_set_values (values_and_locations, variable);
	WR2 : appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_2d_element_nodal_specified_variable_values
	SUBTYPE OF (surface_2d_element_field_variable_definition);
	values : LIST [1:?] OF field_value;
	additional_node_values : BOOLEAN;
	variable : surface_element_variable;
WHERE
	WR1 : consistent_list_values (values, variable);
	WR2 : appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_2d_element_value_and_location;
	simple_value : field_value;
	location : surface_element_location;
	coordinate_system : OPTIONAL surface_2d_state_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;


ENTITY surface_2d_element_value_and_volume_location;
	simple_value : field_value;
	location : surface_volume_element_location;
	coordinate_system : OPTIONAL surface_2d_state_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;


ENTITY surface_2d_node_field_aggregated_variable_values
	SUBTYPE OF (surface_2d_node_field_variable_definition);
	simple_value : field_value;
	variable : volume_aggregated_variable;
	coordinate_system : OPTIONAL surface_2d_state_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_2d_node_field_section_variable_values
	SUBTYPE OF (surface_2d_node_field_variable_definition);
	simple_value : field_value;
	variable : surface_element_variable;
	location : surface_section_element_location;
	coordinate_system : OPTIONAL surface_2d_state_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_2d_node_field_variable_definition
	SUPERTYPE OF (ONEOF (surface_2d_node_field_section_variable_values, surface_2d_node_field_aggregated_variable_values))
	SUBTYPE OF (field_variable_node_definition);
END_ENTITY;


ENTITY surface_2d_substructure_element_reference;
	substructure_element_ref : substructure_element_representation;
	element_ref : surface_2d_element_representation;
END_ENTITY;


ENTITY surface_2d_whole_element_variable_value
	SUBTYPE OF (surface_2d_element_field_variable_definition);
	simple_value : field_value;
	variable : volume_aggregated_variable;
	coordinate_system : OPTIONAL surface_2d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_3d_element_basis;
	descriptor : surface_3d_element_descriptor;
	variable : surface_element_variable;
	variable_order : element_order;
	variable_shape_function : shape_function;
	evaluation_points : LIST [1:?] OF surface_element_location;
END_ENTITY;


ENTITY surface_3d_element_boundary_constant_specified_surface_variable_value
	SUBTYPE OF (surface_3d_element_field_variable_definition);
	simple_value : field_value;
	variable : boundary_variable;
	element_face : surface_3d_face;
	coordinate_system : OPTIONAL surface_3d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_3d_element_boundary_constant_specified_variable_value
	SUBTYPE OF (surface_3d_element_field_variable_definition);
	simple_value : field_value;
	variable : boundary_aggregated_variable;
	element_face : surface_3d_face;
	coordinate_system : OPTIONAL surface_3d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_3d_element_boundary_edge_constant_specified_surface_variable_value
	SUBTYPE OF (surface_3d_element_field_variable_definition);
	simple_value : field_value;
	variable : boundary_edge_variable;
	element_edge : surface_3d_edge;
	coordinate_system : OPTIONAL surface_3d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_3d_element_boundary_edge_constant_specified_variable_value
	SUBTYPE OF (surface_3d_element_field_variable_definition);
	simple_value : field_value;
	variable : boundary_edge_variable;
	element_edge : surface_3d_edge;
	coordinate_system : OPTIONAL surface_3d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_3d_element_boundary_edge_location_point_surface_variable_values
	SUBTYPE OF (surface_3d_element_field_variable_definition);
	basis : BOOLEAN;
	values_and_locations : SET [1:?] OF surface_3d_element_value_and_volume_location;
	variable : boundary_edge_variable;
	element_edge : surface_3d_edge;
WHERE
	WR1 : consistent_set_values (values_and_locations, variable);
	WR2 : appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_3d_element_boundary_edge_location_point_variable_values
	SUBTYPE OF (surface_3d_element_field_variable_definition);
	basis : BOOLEAN;
	values_and_locations : SET [1:?] OF surface_3d_element_value_and_location;
	variable : boundary_edge_variable;
	element_edge : surface_3d_edge;
WHERE
	WR1 : consistent_set_values (values_and_locations, variable);
	WR2 : appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_3d_element_boundary_edge_nodal_specified_variable_values
	SUBTYPE OF (surface_3d_element_field_variable_definition);
	values : LIST [1:?] OF field_value;
	additional_node_values : BOOLEAN;
	variable : boundary_edge_variable;
	element_edge : surface_3d_edge;
WHERE
	WR1 : consistent_list_values (values, variable);
	WR2 : appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_3d_element_boundary_edge_whole_edge_variable_value
	SUBTYPE OF (surface_3d_element_field_variable_definition);
	simple_value : field_value;
	variable : boundary_aggregated_variable;
	element_edge : surface_3d_edge;
	coordinate_system : OPTIONAL surface_3d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_3d_element_boundary_location_point_surface_variable_values
	SUBTYPE OF (surface_3d_element_field_variable_definition);
	basis : BOOLEAN;
	values_and_locations : SET [1:?] OF surface_3d_element_value_and_location;
	variable : boundary_variable;
	element_face : surface_3d_face;
WHERE
	WR1 : consistent_set_values (values_and_locations, variable);
	WR2 : appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_3d_element_boundary_nodal_specified_variable_values
	SUBTYPE OF (surface_3d_element_field_variable_definition);
	values : LIST [1:?] OF field_value;
	additional_node_values : BOOLEAN;
	variable : boundary_variable;
	element_face : surface_3d_face;
WHERE
	WR1 : consistent_list_values (values, variable);
	WR2 : appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_3d_element_boundary_whole_face_variable_value
	SUBTYPE OF (surface_3d_element_field_variable_definition);
	simple_value : field_value;
	variable : boundary_aggregated_variable;
	element_face : surface_3d_face;
	coordinate_system : OPTIONAL surface_3d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_3d_element_constant_specified_variable_value
	SUBTYPE OF (surface_3d_element_field_variable_definition);
	simple_value : field_value;
	variable : surface_element_variable;
	coordinate_system : OPTIONAL surface_3d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_3d_element_constant_specified_volume_variable_value
	SUBTYPE OF (surface_3d_element_field_variable_definition);
	simple_value : field_value;
	variable : volume_variable;
	coordinate_system : OPTIONAL surface_3d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_3d_element_descriptor
	SUBTYPE OF (element_descriptor);
	purpose : SET [1:?] OF SET [1:?] OF surface_element_purpose;
	shape : element_2d_shape;
END_ENTITY;


ENTITY surface_3d_element_field_integration_explicit;
	integration_positions_and_weights : SET [1:?] OF surface_position_weight;
END_ENTITY;


ENTITY surface_3d_element_field_integration_rule;
	integration_method : integration_rule;
	integration_order : ARRAY [1:2] OF INTEGER;
END_ENTITY;


ENTITY surface_3d_element_field_variable_definition
	SUPERTYPE OF (ONEOF (surface_3d_element_location_point_volume_variable_values, surface_3d_element_location_point_variable_values, surface_3d_whole_element_variable_value, surface_3d_element_constant_specified_variable_value, surface_3d_element_constant_specified_volume_variable_value, surface_3d_element_nodal_specified_variable_values, surface_3d_element_boundary_location_point_surface_variable_values, surface_3d_element_boundary_whole_face_variable_value, surface_3d_element_boundary_constant_specified_variable_value, surface_3d_element_boundary_constant_specified_surface_variable_value, surface_3d_element_boundary_nodal_specified_variable_values, surface_3d_element_boundary_edge_location_point_surface_variable_values, surface_3d_element_boundary_edge_location_point_variable_values, surface_3d_element_boundary_edge_whole_edge_variable_value, surface_3d_element_boundary_edge_constant_specified_variable_value, surface_3d_element_boundary_edge_constant_specified_surface_variable_value, surface_3d_element_boundary_edge_nodal_specified_variable_values))
	SUBTYPE OF (field_variable_element_definition);
	element : surface_3d_element_output_reference;
END_ENTITY;


ENTITY surface_3d_element_group
	SUBTYPE OF (element_group);
WHERE
	WR1 : SIZEOF(query(item <* elements |
       NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
            'SURFACE_3D_ELEMENT_REPRESENTATION' IN TYPEOF (item))))=0;
END_ENTITY;


ENTITY surface_3d_element_integrated_matrix;
	descriptor : surface_3d_element_descriptor;
	property_type : surface_matrix_property_type;
	integration_description : text;
END_ENTITY;


ENTITY surface_3d_element_integrated_matrix_with_definition
	SUBTYPE OF (surface_3d_element_integrated_matrix);
	integration_definition : surface_3d_element_integration;
END_ENTITY;


ENTITY surface_3d_element_integration;
	field : surface_3d_element_field_integration;
	section : surface_section_integration;
END_ENTITY;


ENTITY surface_3d_element_location_point_variable_values
	SUBTYPE OF (surface_3d_element_field_variable_definition);
	basis : BOOLEAN;
	values_and_locations : SET [1:?] OF surface_3d_element_value_and_location;
	variable : surface_element_variable;
WHERE
	WR1 : consistent_set_values (values_and_locations, variable);
	WR2 : appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_3d_element_location_point_volume_variable_values
	SUBTYPE OF (surface_3d_element_field_variable_definition);
	basis : BOOLEAN;
	values_and_locations : SET [1:?] OF surface_3d_element_value_and_volume_location;
	variable : volume_variable;
WHERE
	WR1 : consistent_set_values (values_and_locations, variable);
	WR2 : appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_3d_element_nodal_specified_variable_values
	SUBTYPE OF (surface_3d_element_field_variable_definition);
	values : LIST [1:?] OF field_value;
	additional_node_values : BOOLEAN;
	variable : surface_element_variable;
WHERE
	WR1 : consistent_list_values (values, variable);
	WR2 : appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_3d_element_representation
	SUBTYPE OF (element_representation);
	model_ref : fea_model_3d;
	element_descriptor : surface_3d_element_descriptor;
	property : surface_element_property;
	material : element_material;
UNIQUE
	UR1 : model_ref, SELF\representation.name;
WHERE
	WR1 : SIZEOF (QUERY(item <* SELF\representation.items |
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
              'PARAMETRIC_SURFACE_3D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) +
       SIZEOF (QUERY(item <* SELF\representation.items |
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
              'CONSTANT_SURFACE_3D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) +
       SIZEOF (QUERY(item <* SELF\representation.items |
              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
              'ALIGNED_SURFACE_3D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) = 1;
	WR2 : SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_MASS_DENSITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_AREA_DENSITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_MOISTURE_ABSORPTION',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_SHELL_MEMBRANE_STIFFNESS',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_SHELL_BENDING_STIFFNESS',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_SHELL_MEMBRANE_BENDING_COUPLING_STIFFNESS',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_SHELL_SHEAR_STIFFNESS'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
	WR3 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items);
	FU1 : required_2d_nodes (
        SELF\element_representation.node_list,
        element_descriptor.shape,
        element_descriptor\element_descriptor.topology_order);
END_ENTITY;


ENTITY surface_3d_element_value_and_location;
	simple_value : field_value;
	location : surface_element_location;
	coordinate_system : OPTIONAL surface_3d_state_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;


ENTITY surface_3d_element_value_and_volume_location;
	simple_value : field_value;
	location : surface_volume_element_location;
	coordinate_system : OPTIONAL surface_3d_state_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;


ENTITY surface_3d_node_field_aggregated_variable_values
	SUBTYPE OF (surface_3d_node_field_variable_definition);
	simple_value : field_value;
	variable : volume_aggregated_variable;
	coordinate_system : OPTIONAL surface_3d_state_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_3d_node_field_section_variable_values
	SUBTYPE OF (surface_3d_node_field_variable_definition);
	simple_value : field_value;
	variable : surface_element_variable;
	location : surface_section_element_location;
	coordinate_system : OPTIONAL surface_3d_state_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_3d_node_field_variable_definition
	SUPERTYPE OF (ONEOF (surface_3d_node_field_section_variable_values, surface_3d_node_field_aggregated_variable_values))
	SUBTYPE OF (field_variable_node_definition);
END_ENTITY;


ENTITY surface_3d_substructure_element_reference;
	substructure_element_ref : substructure_element_representation;
	element_ref : surface_3d_element_representation;
END_ENTITY;


ENTITY surface_3d_whole_element_variable_value
	SUBTYPE OF (surface_3d_element_field_variable_definition);
	simple_value : field_value;
	variable : volume_aggregated_variable;
	coordinate_system : OPTIONAL surface_3d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY surface_condition_callout
	SUBTYPE OF (draughting_callout);
WHERE
	WR1 : SIZEOF ( QUERY ( c <* SELF.contents | SIZEOF (
         ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'ANNOTATION_CURVE_OCCURRENCE' ,
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'ANNOTATION_SYMBOL_OCCURRENCE' ,
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'ANNOTATION_TEXT_OCCURRENCE']* TYPEOF
         ( c ) ) <>1 ) ) =0;
END_ENTITY;


ENTITY surface_constraint
	SUBTYPE OF (constraint_element);
	required_surface : analysis_item_within_representation;
	coordinate_system : fea_axis2_placement_3d;
	freedoms_and_coefficients : SET [1:?] OF freedom_and_coefficient;
	description : text;
WHERE
	WR1 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE' IN TYPEOF (required_surface.item)) OR
       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_SURFACE' IN TYPEOF (required_surface.item));
END_ENTITY;


ENTITY surface_curve
	SUPERTYPE OF ((ONEOF (intersection_curve, seam_curve) ANDOR bounded_surface_curve))
	SUBTYPE OF (curve);
	curve_3d : curve;
	associated_geometry : LIST [1:2] OF pcurve_or_surface;
	master_representation : preferred_surface_curve_representation;
DERIVE
	basis_surface : SET [1:2] OF surface := get_basis_surface(SELF);
WHERE
	WR1 : curve_3d.dim = 3;
	WR2 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN TYPEOF(associated_geometry[1])) OR
                        (master_representation <> pcurve_s1);
	WR3 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN TYPEOF(associated_geometry[2])) OR
                        (master_representation <> pcurve_s2);
	WR4 : NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN TYPEOF(curve_3d));
END_ENTITY;


ENTITY surface_curve_swept_area_solid
	SUBTYPE OF (swept_area_solid);
	directrix : curve;
	start_param : REAL;
	end_param : REAL;
	reference_surface : surface;
WHERE
	WR1 : (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE' IN TYPEOF(directrix))) OR
          (reference_surface IN (directrix\surface_curve.basis_surface));
END_ENTITY;


ENTITY surface_element_location;
	coordinates : fea_parametric_point;
END_ENTITY;


ENTITY surface_element_property;
	property_id : identifier;
	description : text;
	section : surface_section_field;
END_ENTITY;


ENTITY surface_freedom_action_definition
	SUBTYPE OF (surface_freedom_and_value_definition);
	action : action_type;
END_ENTITY;


ENTITY surface_freedom_and_value_definition
	SUPERTYPE OF (ONEOF (surface_freedom_values, surface_freedom_action_definition))
	SUBTYPE OF (state_definition);
	required_surface : analysis_item_within_representation;
	coordinate_system : fea_axis2_placement_3d;
	degrees_of_freedom : freedoms_list;
	values : LIST [1:?] OF measure_or_unspecified_value;
WHERE
	WR1 : SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (values);
	WR2 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE' IN TYPEOF (required_surface.item)) OR
       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_SURFACE' IN TYPEOF (required_surface.item));
END_ENTITY;


ENTITY surface_freedom_values
	SUBTYPE OF (surface_freedom_and_value_definition);
END_ENTITY;


ENTITY surface_of_linear_extrusion
	SUBTYPE OF (swept_surface);
	extrusion_axis : vector;
END_ENTITY;


ENTITY surface_of_revolution
	SUBTYPE OF (swept_surface);
	axis_position : axis1_placement;
DERIVE
	axis_line : line := representation_item('')||
                     geometric_representation_item()|| curve()||
                     line(axis_position.location, representation_item('')||
                     geometric_representation_item()||
                     vector(axis_position.z, 1.0));
END_ENTITY;


ENTITY surface_patch
	SUBTYPE OF (founded_item);
	parent_surface : bounded_surface;
	u_transition : transition_code;
	v_transition : transition_code;
	u_sense : BOOLEAN;
	v_sense : BOOLEAN;
INVERSE
	using_surfaces: BAG [1:?] OF rectangular_composite_surface FOR segments;
WHERE
	WR1 : (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_BOUNDED_SURFACE' 
                 IN TYPEOF(parent_surface)));
END_ENTITY;


ENTITY surface_position_weight;
	integration_position : surface_element_location;
	integration_weight : context_dependent_measure;
END_ENTITY;


ENTITY surface_profile_tolerance
	SUBTYPE OF (geometric_tolerance);
WHERE
	WR1 : NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF)) OR ( SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) <= 3);
END_ENTITY;


ENTITY surface_rendering_properties;
	rendered_colour : colour;
END_ENTITY;


ENTITY surface_replica
	SUBTYPE OF (surface);
	parent_surface : surface;
	transformation : cartesian_transformation_operator_3d;
WHERE
	WR1 : acyclic_surface_replica(SELF, parent_surface);
END_ENTITY;


ENTITY surface_section
	SUPERTYPE OF (ONEOF (uniform_surface_section, uniform_surface_section_layered));
	offset : measure_or_unspecified_value;
	non_structural_mass : measure_or_unspecified_value;
	non_structural_mass_offset : measure_or_unspecified_value;
END_ENTITY;


ENTITY surface_section_element_location
	SUPERTYPE OF (ONEOF (surface_section_element_location_absolute, surface_section_element_location_dimensionless));
	above_material_discontinuity : LOGICAL;
END_ENTITY;


ENTITY surface_section_element_location_absolute
	SUBTYPE OF (surface_section_element_location);
	offset : context_dependent_measure;
END_ENTITY;


ENTITY surface_section_element_location_dimensionless
	SUBTYPE OF (surface_section_element_location);
	coordinate : LIST [1:1] OF parameter_value;
WHERE
	WR1 : valid_parametric_coordinate (coordinate);
END_ENTITY;


ENTITY surface_section_field
	SUPERTYPE OF (ONEOF (surface_section_field_constant, surface_section_field_varying));
END_ENTITY;


ENTITY surface_section_field_constant
	SUBTYPE OF (surface_section_field);
	definition : surface_section;
END_ENTITY;


ENTITY surface_section_field_varying
	SUBTYPE OF (surface_section_field);
	definitions : LIST [1:?] OF surface_section;
	additional_node_values : BOOLEAN;
END_ENTITY;


ENTITY surface_section_integration_explicit;
	integration_positions_and_weights : SET [1:?] OF surface_section_position_weight;
END_ENTITY;


ENTITY surface_section_integration_rule;
	integration_method : integration_rule;
	integration_order : INTEGER;
END_ENTITY;


ENTITY surface_section_position_weight;
	integration_position : surface_section_element_location;
	integration_weight : context_dependent_measure;
END_ENTITY;


ENTITY surface_side_style
	SUBTYPE OF (founded_item);
	name : label;
	styles : SET [1:7] OF surface_style_element_select;
WHERE
	WR1 : SIZEOF(QUERY( style1 <* SELF.styles |
           SIZEOF(QUERY( style2 <* SELF.styles - style1 |
           TYPEOF(style1) = TYPEOF(style2)
           )) > 0
           )) = 0;
END_ENTITY;


ENTITY surface_style_boundary
	SUBTYPE OF (founded_item);
	style_of_boundary : curve_or_render;
END_ENTITY;


ENTITY surface_style_control_grid
	SUBTYPE OF (founded_item);
	style_of_control_grid : curve_or_render;
END_ENTITY;


ENTITY surface_style_fill_area
	SUBTYPE OF (founded_item);
	fill_area : fill_area_style;
END_ENTITY;


ENTITY surface_style_parameter_line
	SUBTYPE OF (founded_item);
	style_of_parameter_lines : curve_or_render;
	direction_counts : SET [1:2] OF direction_count_select;
WHERE
	WR1 : (HIINDEX(SELF.direction_counts) = 1)
                        XOR
         (TYPEOF(SELF.direction_counts[1]) <>
          TYPEOF(SELF.direction_counts[2]));
END_ENTITY;


ENTITY surface_style_reflectance_ambient;
	ambient_reflectance : REAL;
END_ENTITY;


ENTITY surface_style_reflectance_ambient_diffuse
	SUBTYPE OF (surface_style_reflectance_ambient);
	diffuse_reflectance : REAL;
END_ENTITY;


ENTITY surface_style_reflectance_ambient_diffuse_specular
	SUBTYPE OF (surface_style_reflectance_ambient_diffuse);
	specular_reflectance : REAL;
	specular_exponent : REAL;
	specular_colour : colour;
END_ENTITY;


ENTITY surface_style_rendering;
	rendering_method : shading_surface_method;
	surface_colour : colour;
END_ENTITY;


ENTITY surface_style_rendering_with_properties
	SUBTYPE OF (surface_style_rendering);
	properties : SET [1:2] OF rendering_properties_select;
WHERE
	WR1 : (HIINDEX(SELF.properties) = 1)
                   XOR
         (TYPEOF(SELF.properties[1]) <> TYPEOF(SELF.properties[2]));
END_ENTITY;


ENTITY surface_style_segmentation_curve
	SUBTYPE OF (founded_item);
	style_of_segmentation_curve : curve_or_render;
END_ENTITY;


ENTITY surface_style_silhouette
	SUBTYPE OF (founded_item);
	style_of_silhouette : curve_or_render;
END_ENTITY;


ENTITY surface_style_transparent;
	transparency : REAL;
WHERE
	WR1 : {0.0 <= transparency <= 1.0};
END_ENTITY;


ENTITY surface_style_usage
	SUBTYPE OF (founded_item);
	side : surface_side;
	style : surface_side_style_select;
END_ENTITY;


ENTITY surface_texture_representation
	SUBTYPE OF (representation);
WHERE
	WR1 : SIZEOF ( QUERY ( i <* SELF.items | SIZEOF (
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'MEASURE_REPRESENTATION_ITEM' ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'VALUE_RANGE' , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'DESCRIPTIVE_REPRESENTATION_ITEM']* TYPEOF ( i ) ) <>1 ) )
        =0;
	WR2 : ( SIZEOF ( QUERY ( i <* SELF.items | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) ) =1 )
        AND ( SIZEOF ( QUERY ( i <* SELF.items | (
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'DESCRIPTIVE_REPRESENTATION_ITEM' IN
        TYPEOF ( i ) ) AND ( i.name = 'measuring method' ) ) ) =1 );
	WR3 : SIZEOF ( QUERY ( i <* SELF.items | SIZEOF (
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'MEASURE_REPRESENTATION_ITEM' ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'VALUE_RANGE']* TYPEOF ( i ) ) =1 ) )
        >0;
	WR4 : ( SIZEOF ( USEDIN ( SELF ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'REPRESENTATION_RELATIONSHIP.'+
        'REP_1' ) ) <=1 ) AND ( SIZEOF ( USEDIN ( SELF ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'REPRESENTATION_RELATIONSHIP.'+
        'REP_2' ) ) =0 ) AND ( SIZEOF ( QUERY ( rr <* USEDIN ( SELF
        , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'REPRESENTATION_RELATIONSHIP.'+
        'REP_1' ) | rr. rep_2.name = 'measuring direction' ) ) =
        SIZEOF ( USEDIN ( SELF ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'REPRESENTATION_RELATIONSHIP.'+
        'REP_1' ) ) );
	WR5 : ( SIZEOF ( USEDIN ( SELF ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
        'USED_REPRESENTATION' ) ) =1 ) AND ( SIZEOF ( QUERY ( pdr
        <* USEDIN ( SELF ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
        'USED_REPRESENTATION' ) | SIZEOF ( QUERY ( gpa <* USEDIN (
        pdr. definition ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'GENERAL_PROPERTY_ASSOCIATION.'+
        'DERIVED_DEFINITION' ) | ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'GENERAL_PROPERTY' IN TYPEOF ( gpa. base_definition ) ) AND
        ( gpa. base_definition.name ='surface_condition' ) ) ) =1 )
        ) =1 );
END_ENTITY;


ENTITY surface_volume_element_location;
	field_location : surface_element_location;
	section_location : surface_section_element_location;
END_ENTITY;


ENTITY surfaced_open_shell
	SUBTYPE OF (open_shell);
WHERE
	WR1 : SIZEOF(QUERY(q <* SELF\connected_face_set.cfs_faces |
         NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_SURFACE' IN TYPEOF(q)))) = 0;
END_ENTITY;


ENTITY swept_area_solid
	SUPERTYPE OF (ONEOF (revolved_area_solid, extruded_area_solid, surface_curve_swept_area_solid))
	SUBTYPE OF (solid_model);
	swept_area : curve_bounded_surface;
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLANE' IN TYPEOF(swept_area.basis_surface);
END_ENTITY;


ENTITY swept_disk_solid
	SUBTYPE OF (solid_model);
	directrix : curve;
	radius : positive_length_measure;
	inner_radius : OPTIONAL positive_length_measure;
	start_param : REAL;
	end_param : REAL;
WHERE
	WR1 : directrix.dim = 3;
	WR2 : (NOT EXISTS(inner_radius)) OR (radius > inner_radius);
END_ENTITY;


ENTITY swept_face_solid
	SUPERTYPE OF (ONEOF (extruded_face_solid, revolved_face_solid))
	SUBTYPE OF (solid_model);
	swept_face : face_surface;
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLANE' IN TYPEOF(swept_face.face_geometry);
END_ENTITY;


ENTITY swept_surface
	SUPERTYPE OF (ONEOF (surface_of_linear_extrusion, surface_of_revolution))
	SUBTYPE OF (surface);
	swept_curve : curve;
END_ENTITY;


ENTITY symbol
	SUBTYPE OF (representation_item);
END_ENTITY;


ENTITY symbol_colour;
	colour_of_symbol : colour;
END_ENTITY;


ENTITY symbol_representation
	SUBTYPE OF (representation);
END_ENTITY;


ENTITY symbol_representation_map
	SUBTYPE OF (representation_map);
	SELF\representation_map.mapped_representation : symbol_representation;
	SELF\representation_map.mapping_origin : axis2_placement;
END_ENTITY;


ENTITY symbol_style
	SUBTYPE OF (founded_item);
	name : label;
	style_of_symbol : symbol_style_select;
END_ENTITY;


ENTITY symbol_target
	SUBTYPE OF (geometric_representation_item);
	placement : axis2_placement;
	x_scale : positive_ratio_measure;
	y_scale : positive_ratio_measure;
END_ENTITY;


ENTITY symmetric_banded_matrix
	SUBTYPE OF (symmetric_matrix);
	default_entry : maths_value;
	above : nonnegative_integer;
WHERE
	WR1 : member_of(default_entry,
       factor1(SELF\linearized_table_function.source.range));
END_ENTITY;


ENTITY symmetric_matrix
	SUBTYPE OF (linearized_table_function);
	symmetry : symmetry_type;
	triangle : lower_upper;
	order : ordering_type;
WHERE
	WR1 : SIZEOF (SELF\explicit_table_function.shape) = 2;
	WR2 : SELF\explicit_table_function.shape[1] =
       SELF\explicit_table_function.shape[2];
	WR3 : NOT (symmetry = skew) OR (
       (space_dimension(SELF\linearized_table_function.source.range) = 1) AND
        subspace_of_es(factor1(SELF\linearized_table_function.source.range),
        es_numbers));
	WR4 : NOT ((symmetry = hermitian) OR (symmetry = skew_hermitian)) OR (
       (space_dimension(SELF\linearized_table_function.source.range) = 1) AND
        subspace_of_es(factor1(SELF\linearized_table_function.source.range),
        es_complex_numbers));
END_ENTITY;


ENTITY symmetric_shape_aspect
	SUBTYPE OF (shape_aspect);
INVERSE
	basis_relationships: SET [1:?] OF shape_aspect_relationship FOR relating_shape_aspect;
WHERE
	WR1 : SIZEOF (QUERY (x<*SELF\symmetric_shape_aspect.basis_relationships |
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CENTRE_OF_SYMMETRY' IN TYPEOF 
       (x\shape_aspect_relationship.related_shape_aspect)))>=1;
END_ENTITY;


ENTITY symmetry_control
	SUPERTYPE OF (ONEOF (no_symmetry_control, cylindrical_symmetry_control));
END_ENTITY;


ENTITY symmetry_for_physical_quantity
	SUBTYPE OF (general_property_relationship);
	SELF\general_property_relationship.related_property : physical_quantity_instance;
	SELF\general_property_relationship.relating_property : physical_quantity_symmetry;
END_ENTITY;


ENTITY symmetry_tolerance
	SUBTYPE OF (geometric_tolerance_with_datum_reference);
WHERE
	WR1 : SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) <= 3;
END_ENTITY;


ENTITY system_and_freedom;
	matrix_coordinate_system : directionally_explicit_element_coordinate_system;
	freedom : degree_of_freedom;
END_ENTITY;


ENTITY table_representation_item
	SUBTYPE OF (compound_representation_item);
WHERE
	WR1 : SIZEOF(QUERY(itet <* SELF\compound_representation_item.item_element |
        NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ROW_REPRESENTATION_ITEM' IN TYPEOF(itet))
            )) = 0;
END_ENTITY;


ENTITY tactile_appearance_representation
	SUBTYPE OF (representation);
WHERE
	WR1 : SIZEOF ( QUERY ( i <* SELF.items | SIZEOF (
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'MEASURE_REPRESENTATION_ITEM' ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'VALUE_RANGE']* TYPEOF ( i ) ) <>1 )) =0;
	WR2 : SIZEOF ( QUERY ( i <* SELF.items | name ='depth' ) ) <=1;
	WR3 : ( SIZEOF ( USEDIN ( SELF ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
        'USED_REPRESENTATION' ) ) =1 ) AND ( SIZEOF ( QUERY ( pdr
        <* USEDIN ( SELF ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
        'USED_REPRESENTATION' ) | SIZEOF ( QUERY ( gpa <* USEDIN (
        pdr. definition ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'GENERAL_PROPERTY_ASSOCIATION.'+
        'DERIVED_DEFINITION' ) | ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'GENERAL_PROPERTY' IN TYPEOF ( gpa. base_definition ) ) AND
        ( gpa. base_definition.name ='surface_condition' ) ) ) =1 )) =1 );
END_ENTITY;


ENTITY tagged_text_format
	SUBTYPE OF (representation_context);
END_ENTITY;


ENTITY tagged_text_item
	SUBTYPE OF (descriptive_representation_item);
END_ENTITY;


ENTITY tan_function
	SUBTYPE OF (unary_function_call);
END_ENTITY;


ENTITY tangent
	SUBTYPE OF (derived_shape_aspect);
WHERE
	WR1 : SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;


ENTITY temporal_decomposition_of_action_domain;
	whole : physical_action_domain;
	parts : LIST [2:?] OF physical_action_domain;
END_ENTITY;


ENTITY temporal_decomposition_of_model_action;
	parts : LIST [2:?] OF model_action_domain;
	whole : model_action_domain;
END_ENTITY;


ENTITY temporal_spatial_domain;
	id : identifier;
	name : label;
	description : text;
WHERE
	wr1 : definition_for_temporal_spatial_domain(SELF);
END_ENTITY;


ENTITY tensor_order_and_symmetry
	SUBTYPE OF (general_property, class);
END_ENTITY;


ENTITY tensor_order_and_symmetry_by_library_reference
	SUBTYPE OF (tensor_order_and_symmetry, externally_defined_item);
END_ENTITY;


ENTITY tensor_order_and_symmetry_for_physical_quantity_space
	SUBTYPE OF (general_property_relationship);
	SELF\general_property_relationship.related_property : physical_quantity_space;
	SELF\general_property_relationship.relating_property : tensor_order_and_symmetry;
END_ENTITY;


ENTITY tensor_representation_item
	SUBTYPE OF (representation_item);
	tensor_value : tensor_type;
END_ENTITY;


ENTITY terminator_symbol
	SUBTYPE OF (annotation_symbol_occurrence);
	annotated_curve : annotation_curve_occurrence;
END_ENTITY;


ENTITY text_font;
	id : identifier;
	name : label;
	description : text;
INVERSE
	glyphs: SET [1:?] OF character_glyph_font_usage FOR font;
END_ENTITY;


ENTITY text_font_family;
	id : identifier;
	name : label;
	description : text;
INVERSE
	fonts: SET [1:?] OF text_font_in_family FOR family;
END_ENTITY;


ENTITY text_font_in_family;
	font : text_font;
	family : text_font_family;
END_ENTITY;


ENTITY text_literal
	SUBTYPE OF (geometric_representation_item);
	literal : presentable_text;
	placement : axis2_placement;
	alignment : text_alignment;
	path : text_path;
	font : font_select;
END_ENTITY;


ENTITY text_literal_with_associated_curves
	SUBTYPE OF (text_literal);
	associated_curves : SET [1:?] OF curve;
END_ENTITY;


ENTITY text_literal_with_blanking_box
	SUBTYPE OF (text_literal);
	blanking : planar_box;
END_ENTITY;


ENTITY text_literal_with_delineation
	SUBTYPE OF (text_literal);
	delineation : text_delineation;
END_ENTITY;


ENTITY text_literal_with_extent
	SUBTYPE OF (text_literal);
	extent : planar_extent;
END_ENTITY;


ENTITY text_string_representation
	SUBTYPE OF (representation);
	SELF\representation.items : SET [1:?] OF text_string_representation_item;
WHERE
	WR1 : SIZEOF (
         QUERY (item <* SELF\representation.items |
           NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TEXT_LITERAL',
                         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT',
                         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_CHARACTER',
                         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DEFINED_CHARACTER_GLYPH',
                         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_TEXT'] *
                 TYPEOF (item)) = 0)
         )) >= 1;
	WR2 : SIZEOF (
         QUERY (a2p <* 
           QUERY (item <* SELF\representation.items | 
             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT' IN TYPEOF (item)) |
           NOT ((SIZEOF (
             QUERY (at <* 
               QUERY (item <* SELF\representation.items | 
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'ANNOTATION_TEXT' IN TYPEOF (item)) | 
               (at\mapped_item.mapping_target :=: a2p))) >= 1) OR
           (SIZEOF (
             QUERY (atc <* 
               QUERY (item <* SELF\representation.items |
                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                 'ANNOTATION_TEXT_CHARACTER' IN TYPEOF (item)) | 
               (atc\mapped_item.mapping_target :=: a2p))) >= 1)
          ))) = 0;
END_ENTITY;


ENTITY text_style
	SUBTYPE OF (founded_item);
	name : label;
	character_appearance : character_style_select;
END_ENTITY;


ENTITY text_style_for_defined_font;
	text_colour : colour;
END_ENTITY;


ENTITY text_style_with_box_characteristics
	SUBTYPE OF (text_style);
	characteristics : SET [1:4] OF box_characteristic_select;
WHERE
	WR1 : SIZEOF( QUERY( c1 <* SELF.characteristics |
           SIZEOF( QUERY( c2 <* SELF.characteristics - c1 |
           TYPEOF (c1) = TYPEOF (c2)
           )) > 0
           )) = 0;
END_ENTITY;


ENTITY text_style_with_mirror
	SUBTYPE OF (text_style);
	mirror_placement : axis2_placement;
END_ENTITY;


ENTITY text_style_with_spacing
	SUBTYPE OF (text_style);
	character_spacing : character_spacing_select;
END_ENTITY;


ENTITY thermal_conductivity_model
	SUBTYPE OF (mbna_behaviour_model);
	model_type : thermal_conductivity_model_type;
END_ENTITY;


ENTITY thermal_resistance_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.THERMAL_RESISTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY thermal_resistance_unit
	SUBTYPE OF (derived_unit);
WHERE
	WR1 : derive_dimensional_exponents(SELF) = 
        dimensional_exponents ( -1.0, -1.0, -3.0, 0.0, 1.0, 0.0, 0.0 );
END_ENTITY;


ENTITY thermodynamic_temperature_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY thermodynamic_temperature_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;


ENTITY thickened_face_solid
	SUBTYPE OF (solid_model);
	base_element : generalized_surface_select;
	offset1 : length_measure;
	offset2 : length_measure;
WHERE
	WR1 : NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE' IN TYPEOF(base_element)) AND
    (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BOUNDED_SURFACE' IN TYPEOF(base_element))));
	WR2 : offset1 <> offset2;
END_ENTITY;


ENTITY thickness_laminate_definition
	SUBTYPE OF (product_definition);
WHERE
	WR1 : SIZEOF (QUERY (pdr <* USEDIN (SELF, 
                             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                             'PRODUCT_DEFINITION_RELATIONSHIP.' +
                             'RELATING_PRODUCT_DEFINITION') |
                             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                             'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN
                             TYPEOF (pdr))) = 1;
END_ENTITY;


ENTITY thickness_laminate_table
	SUBTYPE OF (zone_structural_makeup);
END_ENTITY;


ENTITY time_interval;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY;


ENTITY time_interval_assignment
	ABSTRACT SUPERTYPE;
	assigned_time_interval : time_interval;
	role : time_interval_role;
END_ENTITY;


ENTITY time_interval_based_effectivity
	SUBTYPE OF (effectivity);
	effectivity_period : time_interval;
END_ENTITY;


ENTITY time_interval_relationship;
	name : label;
	description : OPTIONAL text;
	relating_time_interval : time_interval;
	related_time_interval : time_interval;
END_ENTITY;


ENTITY time_interval_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY;


ENTITY time_interval_with_bounds
	SUBTYPE OF (time_interval);
	primary_bound : OPTIONAL date_time_or_event_occurrence;
	secondary_bound : OPTIONAL date_time_or_event_occurrence;
	duration : OPTIONAL time_measure_with_unit;
WHERE
	WR1 : NOT (EXISTS(secondary_bound) AND EXISTS(duration));
	WR2 : EXISTS(primary_bound) OR EXISTS(secondary_bound);
END_ENTITY;


ENTITY time_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TIME_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY time_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 1.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;


ENTITY tolerance_value;
	lower_bound : measure_with_unit;
	upper_bound : measure_with_unit;
DERIVE
	lbvc : REAL := lower_bound\measure_with_unit.value_component;
	ubvc : REAL := upper_bound\measure_with_unit.value_component;
WHERE
	WR1 : ubvc > lbvc;
	WR2 : upper_bound\measure_with_unit.unit_component =
        lower_bound\measure_with_unit.unit_component;
END_ENTITY;


ENTITY tolerance_zone
	SUBTYPE OF (shape_aspect);
	defining_tolerance : SET [1:?] OF geometric_tolerance;
	form : tolerance_zone_form;
END_ENTITY;


ENTITY tolerance_zone_definition
	SUPERTYPE OF (ONEOF (projected_zone_definition, runout_zone_definition));
	zone : tolerance_zone;
	boundaries : SET [1:?] OF shape_aspect;
END_ENTITY;


ENTITY tolerance_zone_form;
	name : label;
END_ENTITY;


ENTITY topological_representation_item
	SUPERTYPE OF (ONEOF (vertex, edge, face_bound, face, vertex_shell, wire_shell, connected_edge_set, connected_face_set, (loop ANDOR path)))
	SUBTYPE OF (representation_item);
END_ENTITY;


ENTITY toroidal_surface
	SUBTYPE OF (elementary_surface);
	major_radius : positive_length_measure;
	minor_radius : positive_length_measure;
END_ENTITY;


ENTITY torus
	SUBTYPE OF (geometric_representation_item);
	position : axis1_placement;
	major_radius : positive_length_measure;
	minor_radius : positive_length_measure;
WHERE
	WR1 : major_radius > minor_radius;
END_ENTITY;


ENTITY total_runout_tolerance
	SUBTYPE OF (geometric_tolerance_with_datum_reference);
WHERE
	WR1 : SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) <= 2;
END_ENTITY;


ENTITY track_blended_solid
	ABSTRACT SUPERTYPE OF (track_blended_solid_with_end_conditions)
	SUBTYPE OF (edge_blended_solid);
WHERE
	WR1 : check_continuous_edges(SELF\edge_blended_solid.blended_edges);
END_ENTITY;


ENTITY track_blended_solid_with_end_conditions
	SUBTYPE OF (track_blended_solid);
	end_conditions : LIST [2:2] OF blend_end_condition_select;
WHERE
	WR1 : SIZEOF(TYPEOF(SELF) *
    ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_WITH_CONSTANT_RADIUS_EDGE_BLEND',
     'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_WITH_VARIABLE_RADIUS_EDGE_BLEND',
     'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_WITH_CHAMFERED_EDGES']) = 1;
	WR2 : NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX' IN TYPEOF(end_conditions[1]))
       AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX' IN TYPEOF(end_conditions[2])));
	WR3 : NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX' IN TYPEOF(end_conditions[1]))
       AND (NOT ((end_conditions[1] 
            :=: SELF\edge_blended_solid.blended_edges[1].edge_start)
            XOR (end_conditions[1] 
            :=: SELF\edge_blended_solid.blended_edges[1].edge_end))));
	WR4 : NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX' IN TYPEOF(end_conditions[2]))
       AND (NOT ((end_conditions[2] 
            :=: SELF\edge_blended_solid.blended_edges[HIINDEX(
                SELF\edge_blended_solid.blended_edges)].edge_start)
            XOR (end_conditions[2] 
            :=: SELF\edge_blended_solid.blended_edges[HIINDEX(
                SELF\edge_blended_solid.blended_edges)].edge_end))));
END_ENTITY;


ENTITY transformation_with_derived_angle
	SUPERTYPE OF (ONEOF (draped_defined_transformation, laid_defined_transformation))
	SUBTYPE OF (item_defined_transformation);
	SELF\item_defined_transformation.transform_item_1 : angle_direction_reference_with_a2p3d_select;
	SELF\item_defined_transformation.transform_item_2 : axis2_placement_3d;
DERIVE
	orientation_angle : plane_angle_measure := derive_angle (
        SELF\item_defined_transformation.transform_item_1,
        SELF\item_defined_transformation.transform_item_2);
WHERE
	WR1 : (SELF\item_defined_transformation.transform_item_1\
            axis2_placement_3d.p[3].direction_ratios[1] =
            SELF\item_defined_transformation.transform_item_2\
            axis2_placement_3d.p[3].direction_ratios[1])
          AND
           (SELF\item_defined_transformation.transform_item_1\
            axis2_placement_3d.p[3].direction_ratios[2] =
            SELF\item_defined_transformation.transform_item_2\
            axis2_placement_3d.p[3].direction_ratios[2])
          AND
           (SELF\item_defined_transformation.transform_item_1\
            axis2_placement_3d.p[3].direction_ratios[3] =
            SELF\item_defined_transformation.transform_item_2\
            axis2_placement_3d.p[3].direction_ratios[3]);
END_ENTITY;


ENTITY triangular_matrix
	SUBTYPE OF (linearized_table_function);
	default_entry : maths_value;
	lo_up : lower_upper;
	order : ordering_type;
WHERE
	WR1 : SIZEOF (SELF\explicit_table_function.shape) = 2;
	WR2 : member_of(default_entry, SELF\maths_function.range);
END_ENTITY;


ENTITY trimmed_curve
	SUBTYPE OF (bounded_curve);
	basis_curve : curve;
	trim_1 : SET [1:2] OF trimming_select;
	trim_2 : SET [1:2] OF trimming_select;
	sense_agreement : BOOLEAN;
	master_representation : trimming_preference;
WHERE
	WR1 : (HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) <> TYPEOF(trim_1[2]));
	WR2 : (HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) <> TYPEOF(trim_2[2]));
END_ENTITY;


ENTITY turbulence_closure
	SUBTYPE OF (mbna_behaviour_model);
	closure_type : turbulence_closure_type;
END_ENTITY;


ENTITY turbulence_model
	SUBTYPE OF (mbna_behaviour_model);
	model_type : turbulence_model_type;
	diffusion_model : OPTIONAL fd_diffusion_model;
END_ENTITY;


ENTITY two_direction_repeat_factor
	SUBTYPE OF (one_direction_repeat_factor);
	second_repeat_factor : vector;
END_ENTITY;


ENTITY type_qualifier;
	name : label;
END_ENTITY;


ENTITY unary_boolean_expression
	ABSTRACT SUPERTYPE OF (ONEOF (not_expression, odd_function))
	SUBTYPE OF (boolean_expression, unary_generic_expression);
END_ENTITY;


ENTITY unary_function_call
	ABSTRACT SUPERTYPE OF (ONEOF (abs_function, minus_function, sin_function, cos_function, tan_function, asin_function, acos_function, exp_function, log_function, log2_function, log10_function, square_root_function))
	SUBTYPE OF (unary_numeric_expression);
END_ENTITY;


ENTITY unary_generic_expression
	ABSTRACT SUPERTYPE
	SUBTYPE OF (generic_expression);
	operand : generic_expression;
END_ENTITY;


ENTITY unary_numeric_expression
	ABSTRACT SUPERTYPE
	SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand : numeric_expression;
END_ENTITY;


ENTITY uncertainty_assigned_representation
	SUBTYPE OF (representation);
	uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY;


ENTITY uncertainty_measure_with_unit
	SUBTYPE OF (measure_with_unit);
	name : label;
	description : OPTIONAL text;
WHERE
	WR1 : valid_measure_value (SELF\measure_with_unit.value_component);
END_ENTITY;


ENTITY uncertainty_qualifier
	SUPERTYPE OF (ONEOF (standard_uncertainty, qualitative_uncertainty));
	measure_name : label;
	description : text;
END_ENTITY;


ENTITY uniform_curve
	SUBTYPE OF (b_spline_curve);
END_ENTITY;


ENTITY uniform_product_space
	SUBTYPE OF (maths_space, generic_literal);
	base : maths_space;
	exponent : positive_integer;
WHERE
	WR1 : expression_is_constant(base);
	WR2 : no_cyclic_space_reference(SELF, []);
	WR3 : base <> the_empty_space;
END_ENTITY;


ENTITY uniform_resource_identifier
	SUBTYPE OF (descriptive_representation_item);
END_ENTITY;


ENTITY uniform_surface
	SUBTYPE OF (b_spline_surface);
END_ENTITY;


ENTITY uniform_surface_section
	SUBTYPE OF (surface_section);
	thickness : context_dependent_measure;
	bending_thickness : measure_or_unspecified_value;
	shear_thickness : measure_or_unspecified_value;
END_ENTITY;


ENTITY uniform_surface_section_layered
	SUBTYPE OF (surface_section);
END_ENTITY;


ENTITY unit_defined_maths_space_context
	SUBTYPE OF (defined_maths_space_context);
	unit_basis : unit;
END_ENTITY;


ENTITY unstructured_donor_mesh
	SUBTYPE OF (mismatched_donor_mesh);
	cells : indices_group;
	interpolant : property_distribution_description;
	vsize : INTEGER;
	SELF\mismatched_donor_mesh.donor : unstructured_mesh;
DERIVE
	index_count : INTEGER := donor.index_count;
END_ENTITY;


ENTITY unstructured_mesh
	ABSTRACT SUPERTYPE OF (ONEOF (array_based_unstructured_mesh, explicit_unstructured_mesh))
	SUBTYPE OF (mesh);
	cell_count : INTEGER;
END_ENTITY;


ENTITY usage_association
	SUBTYPE OF (action_method_relationship);
	SELF\action_method_relationship.related_method : information_usage_right;
	SELF\action_method_relationship.relating_method : information_usage_right;
DERIVE
	related : information_usage_right := SELF\action_method_relationship.related_method;
	relating : information_usage_right := SELF\action_method_relationship.relating_method;
END_ENTITY;


ENTITY user_defined_curve_font
	SUBTYPE OF (curve_style_font, mapped_item);
END_ENTITY;


ENTITY user_defined_marker
	SUBTYPE OF (mapped_item, pre_defined_marker);
END_ENTITY;


ENTITY user_defined_terminator_symbol
	SUBTYPE OF (mapped_item, pre_defined_symbol);
END_ENTITY;


ENTITY user_selected_elements
	SUBTYPE OF (representation_item);
	picked_items : SET [1:?] OF representation_item;
END_ENTITY;


ENTITY user_selected_shape_elements
	SUBTYPE OF (user_selected_elements);
WHERE
	WR1 : SIZEOF(QUERY(q <* 
    SELF\user_selected_elements.picked_items | NOT
    ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHAPE_REPRESENTATION_ITEM'
    IN TYPEOF(q)))) = 0;
END_ENTITY;


ENTITY value_function
	SUPERTYPE OF (int_value_function)
	SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand : string_expression;
END_ENTITY;


ENTITY value_range
	SUBTYPE OF (compound_representation_item);
WHERE
	WR1 : ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'SET_REPRESENTATION_ITEM' IN TYPEOF ( item_element ) ) AND value_range_wr1 ( item_element );
	WR2 : value_range_wr2 ( item_element );
	WR3 : value_range_wr3 ( item_element );
END_ENTITY;


ENTITY value_representation_item
	SUBTYPE OF (representation_item);
	value_component : measure_value;
WHERE
	WR1 : SIZEOF (QUERY (rep <* using_representations (SELF) |
        NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GLOBAL_UNIT_ASSIGNED_CONTEXT'
        IN TYPEOF (rep.context_of_items)
        ))) = 0;
END_ENTITY;


ENTITY variable
	ABSTRACT SUPERTYPE OF (ONEOF (numeric_variable, boolean_variable, string_variable))
	SUBTYPE OF (generic_variable);
END_ENTITY;


ENTITY variable_semantics
	ABSTRACT SUPERTYPE;
END_ENTITY;


ENTITY variational_representation_item
	ABSTRACT SUPERTYPE OF (auxiliary_geometric_representation_item)
	SUBTYPE OF (representation_item);
WHERE
	WR1 : SIZEOF(QUERY(q <* using_representations(SELF) |
    NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VARIATIONAL_REPRESENTATION'  
    IN TYPEOF(q)))) = 0;
	WR2 : SIZEOF(QUERY(q <* using_representations(SELF) |
    NOT (SELF IN q.items))) = 0;
END_ENTITY;


ENTITY vector
	SUBTYPE OF (geometric_representation_item);
	orientation : direction;
	magnitude : length_measure;
WHERE
	WR1 : magnitude >= 0.0;
END_ENTITY;


ENTITY vector_style
	SUBTYPE OF (curve_style, pre_defined_terminator_symbol);
END_ENTITY;


ENTITY velocity_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VELOCITY_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY velocity_unit
	SUBTYPE OF (derived_unit);
WHERE
	WR1 : derive_dimensional_exponents(SELF) = 
       dimensional_exponents ( 1.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0 );
END_ENTITY;


ENTITY versioned_action_request;
	id : identifier;
	version : label;
	purpose : text;
	description : OPTIONAL text;
END_ENTITY;


ENTITY versioned_action_request_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_versioned_action_request : versioned_action_request;
	related_versioned_action_request : versioned_action_request;
END_ENTITY;


ENTITY vertex
	SUBTYPE OF (topological_representation_item);
END_ENTITY;


ENTITY vertex_defined_cell
	SUBTYPE OF (cell);
	shape : cell_shape;
	order : element_order;
	vertices : ARRAY [1:vn_count] OF  OPTIONAL vertex;
DERIVE
	bound_count : INTEGER := cell_counts(SELF)[1];
	edge_node_count : INTEGER := cell_counts(SELF)[2];
	opt_node_count : INTEGER := cell_counts(SELF)[3];
	required_count : INTEGER := bound_count + edge_node_count;
	required_vertices : ARRAY [1:required_count] OF vertex := shorten_array(vertices, vn_count, required_count);
	vn_count : INTEGER := required_count + opt_node_count;
END_ENTITY;


ENTITY vertex_loop
	SUBTYPE OF (loop);
	loop_vertex : vertex;
END_ENTITY;


ENTITY vertex_point
	SUBTYPE OF (vertex, geometric_representation_item);
	vertex_geometry : point;
END_ENTITY;


ENTITY vertex_shell
	SUBTYPE OF (topological_representation_item);
	vertex_shell_extent : vertex_loop;
END_ENTITY;


ENTITY view_relationship;
	id : identifier;
	name : label;
	description : text;
	viewed : temporal_spatial_domain;
	view : numerical_model;
END_ENTITY;


ENTITY view_volume
	SUBTYPE OF (founded_item);
	projection_type : central_or_parallel;
	projection_point : cartesian_point;
	view_plane_distance : length_measure;
	front_plane_distance : length_measure;
	front_plane_clipping : BOOLEAN;
	back_plane_distance : length_measure;
	back_plane_clipping : BOOLEAN;
	view_volume_sides_clipping : BOOLEAN;
	view_window : planar_box;
INVERSE
	camera_usages: SET [1:?] OF camera_model_d3 FOR perspective_of_volume;
WHERE
	WR1 : ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D' 
              IN TYPEOF(SELF.view_window.placement)) AND
                   (dot_product (
                     (representation_item(' ') || geometric_representation_item() || direction([0.0,0.0,1.0])),
                     SELF.view_window\planar_box.placement\axis2_placement_3d.p[3]
                    ) = 1.0);
	WR2 : view_plane_distance = view_window.placement.location.coordinates[3];
END_ENTITY;


ENTITY viscosity_model
	SUBTYPE OF (mbna_behaviour_model);
	model_type : viscosity_model_type;
END_ENTITY;


ENTITY visual_appearance_representation
	SUBTYPE OF (representation);
WHERE
	WR1 : ( {3<= SIZEOF ( SELF.items ) <=9} ) AND ( SIZEOF ( QUERY (
        i <* items | ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND (
        i.name IN [ 'colour id' , 'colour name' , 'lustre' , 'pattern' , 'transparency', 'orientation'] ) ) 
        ) + SIZEOF ( QUERY ( i <* items | ( SIZEOF (
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'MEASURE_REPRESENTATION_ITEM' ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'VALUE_RANGE']* TYPEOF ( i ) ) =1 )							
        AND ( i.name IN ['refraction index' , 'opacity'] ) ) 
        ) + SIZEOF ( QUERY ( i <* items | ( 
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'DOCUMENT_FILE' IN TYPEOF ( i ) ) 
        AND ( i.name IN [ 'texture map' ] ) )	)
        = SIZEOF ( SELF.items ) );
	WR2 : SIZEOF ( QUERY ( i <* SELF.items | i.name = 'colour id' )) =1;
	WR3 : SIZEOF ( QUERY ( i <* SELF.items | i.name ='lustre' ) )=1;
	WR4 : SIZEOF ( QUERY ( i <* SELF.items | i.name = 'colour name') ) <=1;
	WR5 : SIZEOF ( QUERY ( i <* SELF.items | i.name ='pattern' ) )<=1;
	WR6 : SIZEOF ( QUERY ( i <* SELF.items | i.name ='transparency') ) <=1;
	WR7 : SIZEOF ( QUERY ( i <* SELF.items | i.name = 'texture map') ) <=1;
	WR8 : SIZEOF ( QUERY ( i <* SELF.items | i.name ='refraction index' ) )<=1;
	WR9 : SIZEOF ( QUERY ( i <* SELF.items | i.name ='opacity') ) <=1;
	WR10 : SIZEOF ( QUERY ( i <* SELF.items | i.name ='orientation') ) <=1;
	WR11 : ( SIZEOF ( USEDIN ( SELF ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
        'USED_REPRESENTATION' ) ) =1 ) AND ( SIZEOF ( QUERY ( pdr
        <* USEDIN ( SELF ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
        'USED_REPRESENTATION' ) | SIZEOF ( QUERY ( gpa <* USEDIN (
        pdr. definition ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'GENERAL_PROPERTY_ASSOCIATION.'+
        'DERIVED_DEFINITION' ) | ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
        'GENERAL_PROPERTY' IN TYPEOF ( gpa. base_definition ) ) AND
        ( gpa. base_definition.name ='surface_condition' ) ) ) =1 )) =1 );
END_ENTITY;


ENTITY volume
	SUBTYPE OF (geometric_representation_item);
WHERE
	WR1 : SELF\geometric_representation_item.dim = 3;
END_ENTITY;


ENTITY volume_2d_element_basis;
	descriptor : volume_2d_element_descriptor;
	variable : volume_variable;
	variable_order : element_order;
	variable_shape_function : shape_function;
	evaluation_points : LIST [1:?] OF volume_element_location;
END_ENTITY;


ENTITY volume_2d_element_boundary_constant_specified_variable_value
	SUBTYPE OF (volume_2d_element_field_variable_definition);
	simple_value : field_value;
	variable : boundary_variable;
	element_face : volume_2d_face;
	coordinate_system : OPTIONAL volume_2d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY volume_2d_element_boundary_edge_constant_specified_volume_variable_value
	SUBTYPE OF (volume_2d_element_field_variable_definition);
	simple_value : field_value;
	variable : boundary_edge_variable;
	element_edge : volume_2d_edge;
	coordinate_system : OPTIONAL volume_2d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY volume_2d_element_boundary_edge_location_point_volume_variable_values
	SUBTYPE OF (volume_2d_element_field_variable_definition);
	basis : BOOLEAN;
	values_and_locations : SET [1:?] OF volume_2d_element_value_and_location;
	variable : boundary_edge_variable;
	element_edge : volume_2d_edge;
WHERE
	WR1 : consistent_set_values (values_and_locations, variable);
	WR2 : appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY volume_2d_element_boundary_edge_nodal_specified_variable_values
	SUBTYPE OF (volume_2d_element_field_variable_definition);
	values : LIST [1:?] OF field_value;
	additional_node_values : BOOLEAN;
	variable : boundary_edge_variable;
	element_edge : volume_2d_edge;
WHERE
	WR1 : consistent_list_values (values, variable);
	WR2 : appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY volume_2d_element_boundary_edge_whole_edge_variable_value
	SUBTYPE OF (volume_2d_element_field_variable_definition);
	simple_value : field_value;
	variable : boundary_aggregated_variable;
	element_edge : volume_2d_edge;
	coordinate_system : OPTIONAL volume_2d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY volume_2d_element_boundary_location_point_variable_values
	SUBTYPE OF (volume_2d_element_field_variable_definition);
	basis : BOOLEAN;
	values_and_locations : SET [1:?] OF volume_2d_element_value_and_location;
	variable : boundary_variable;
	element_face : volume_2d_face;
WHERE
	WR1 : consistent_set_values (values_and_locations, variable);
	WR2 : appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY volume_2d_element_boundary_nodal_specified_variable_values
	SUBTYPE OF (volume_2d_element_field_variable_definition);
	values : LIST [1:?] OF field_value;
	variable : boundary_variable;
	additional_node_values : BOOLEAN;
	element_face : volume_2d_face;
WHERE
	WR1 : consistent_list_values (values, variable);
	WR2 : appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY volume_2d_element_boundary_whole_face_variable_value
	SUBTYPE OF (volume_2d_element_field_variable_definition);
	simple_value : field_value;
	variable : boundary_aggregated_variable;
	element_face : volume_2d_face;
	coordinate_system : OPTIONAL volume_2d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY volume_2d_element_constant_specified_variable_value
	SUBTYPE OF (volume_2d_element_field_variable_definition);
	simple_value : field_value;
	variable : volume_variable;
	coordinate_system : OPTIONAL volume_2d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY volume_2d_element_field_integration_explicit;
	integration_positions_and_weights : SET [1:?] OF volume_position_weight;
END_ENTITY;


ENTITY volume_2d_element_field_integration_rule;
	integration_method : integration_rule;
	integration_order : ARRAY [1:2] OF INTEGER;
END_ENTITY;


ENTITY volume_2d_element_field_variable_definition
	SUPERTYPE OF (ONEOF (volume_2d_element_location_point_variable_values, volume_2d_whole_element_variable_value, volume_2d_element_constant_specified_variable_value, volume_2d_element_nodal_specified_variable_values, volume_2d_element_boundary_location_point_variable_values, volume_2d_element_boundary_whole_face_variable_value, volume_2d_element_boundary_constant_specified_variable_value, volume_2d_element_boundary_nodal_specified_variable_values, volume_2d_element_boundary_edge_location_point_volume_variable_values, volume_2d_element_boundary_edge_whole_edge_variable_value, volume_2d_element_boundary_edge_constant_specified_volume_variable_value, volume_2d_element_boundary_edge_nodal_specified_variable_values))
	SUBTYPE OF (field_variable_element_definition);
	element : volume_2d_element_output_reference;
END_ENTITY;


ENTITY volume_2d_element_group
	SUBTYPE OF (element_group);
WHERE
	WR1 : SIZEOF(QUERY(item <* elements |
       (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
             'AXISYMMETRIC_VOLUME_2D_ELEMENT_REPRESENTATION'
              IN TYPEOF(item)) AND
        NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
             'PLANE_VOLUME_2D_ELEMENT_REPRESENTATION'
              IN TYPEOF(item)))))=0;
END_ENTITY;


ENTITY volume_2d_element_integrated_matrix;
	descriptor : volume_2d_element_descriptor;
	property_type : matrix_property_type;
	integration_description : text;
END_ENTITY;


ENTITY volume_2d_element_integrated_matrix_with_definition
	SUBTYPE OF (volume_2d_element_integrated_matrix);
	integration_definition : volume_2d_element_field_integration;
END_ENTITY;


ENTITY volume_2d_element_location_point_variable_values
	SUBTYPE OF (volume_2d_element_field_variable_definition);
	basis : BOOLEAN;
	values_and_locations : SET [1:?] OF volume_2d_element_value_and_location;
	variable : volume_variable;
WHERE
	WR1 : consistent_set_values (values_and_locations, variable);
	WR2 : appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY volume_2d_element_nodal_specified_variable_values
	SUBTYPE OF (volume_2d_element_field_variable_definition);
	values : LIST [1:?] OF field_value;
	additional_node_values : BOOLEAN;
	variable : volume_variable;
WHERE
	WR1 : consistent_list_values (values, variable);
	WR2 : appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY volume_2d_element_value_and_location;
	simple_value : field_value;
	location : volume_element_location;
	coordinate_system : OPTIONAL volume_2d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;


ENTITY volume_2d_node_field_variable_definition
	SUBTYPE OF (field_variable_node_definition);
	simple_value : field_value;
	variable : volume_variable;
	coordinate_system : OPTIONAL volume_2d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY volume_2d_substructure_element_reference;
	substructure_element_ref : substructure_element_representation;
	element_ref : volume_2d_element_representation;
END_ENTITY;


ENTITY volume_2d_whole_element_variable_value
	SUBTYPE OF (volume_2d_element_field_variable_definition);
	simple_value : field_value;
	variable : volume_aggregated_variable;
	coordinate_system : OPTIONAL volume_2d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY volume_3d_element_basis;
	descriptor : volume_3d_element_descriptor;
	variable : volume_variable;
	variable_order : element_order;
	variable_shape_function : shape_function;
	evaluation_points : LIST [1:?] OF volume_element_location;
END_ENTITY;


ENTITY volume_3d_element_boundary_constant_specified_variable_value
	SUBTYPE OF (volume_3d_element_field_variable_definition);
	simple_value : field_value;
	variable : boundary_variable;
	element_face : volume_3d_face;
	coordinate_system : OPTIONAL volume_3d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY volume_3d_element_boundary_edge_constant_specified_volume_variable_value
	SUBTYPE OF (volume_3d_element_field_variable_definition);
	simple_value : field_value;
	variable : boundary_edge_variable;
	element_edge : volume_3d_edge;
	coordinate_system : OPTIONAL volume_3d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY volume_3d_element_boundary_edge_location_point_volume_variable_values
	SUBTYPE OF (volume_3d_element_field_variable_definition);
	basis : BOOLEAN;
	values_and_locations : SET [1:?] OF volume_3d_element_value_and_location;
	variable : boundary_edge_variable;
	element_edge : volume_3d_edge;
WHERE
	WR1 : consistent_set_values (values_and_locations, variable);
	WR2 : appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY volume_3d_element_boundary_edge_nodal_specified_variable_values
	SUBTYPE OF (volume_3d_element_field_variable_definition);
	values : LIST [1:?] OF field_value;
	additional_node_values : BOOLEAN;
	variable : boundary_edge_variable;
	element_edge : volume_3d_edge;
WHERE
	WR1 : consistent_list_values (values, variable);
	WR2 : appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY volume_3d_element_boundary_edge_whole_edge_variable_value
	SUBTYPE OF (volume_3d_element_field_variable_definition);
	simple_value : field_value;
	variable : boundary_aggregated_variable;
	element_edge : volume_3d_edge;
	coordinate_system : OPTIONAL volume_3d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY volume_3d_element_boundary_location_point_variable_values
	SUBTYPE OF (volume_3d_element_field_variable_definition);
	basis : BOOLEAN;
	values_and_locations : SET [1:?] OF volume_3d_element_value_and_location;
	variable : boundary_variable;
	element_face : volume_3d_face;
WHERE
	WR1 : consistent_set_values (values_and_locations, variable);
	WR2 : appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY volume_3d_element_boundary_nodal_specified_variable_values
	SUBTYPE OF (volume_3d_element_field_variable_definition);
	values : LIST [1:?] OF field_value;
	additional_node_values : BOOLEAN;
	variable : boundary_variable;
	element_face : volume_3d_face;
WHERE
	WR1 : consistent_list_values (values, variable);
	WR2 : appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY volume_3d_element_boundary_whole_face_variable_value
	SUBTYPE OF (volume_3d_element_field_variable_definition);
	simple_value : field_value;
	variable : boundary_aggregated_variable;
	element_face : volume_3d_face;
	coordinate_system : OPTIONAL volume_3d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY volume_3d_element_constant_specified_variable_value
	SUBTYPE OF (volume_3d_element_field_variable_definition);
	simple_value : field_value;
	variable : volume_variable;
	coordinate_system : OPTIONAL volume_3d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY volume_3d_element_descriptor
	SUBTYPE OF (element_descriptor);
	purpose : SET [1:?] OF volume_element_purpose;
	shape : volume_3d_element_shape;
END_ENTITY;


ENTITY volume_3d_element_field_integration_explicit;
	integration_positions_and_weights : SET [1:?] OF volume_position_weight;
END_ENTITY;


ENTITY volume_3d_element_field_integration_rule;
	integration_method : integration_rule;
	integration_order : ARRAY [1:3] OF INTEGER;
END_ENTITY;


ENTITY volume_3d_element_field_variable_definition
	SUPERTYPE OF (ONEOF (volume_3d_element_location_point_variable_values, volume_3d_whole_element_variable_value, volume_3d_element_constant_specified_variable_value, volume_3d_element_nodal_specified_variable_values, volume_3d_element_boundary_location_point_variable_values, volume_3d_element_boundary_whole_face_variable_value, volume_3d_element_boundary_constant_specified_variable_value, volume_3d_element_boundary_nodal_specified_variable_values, volume_3d_element_boundary_edge_location_point_volume_variable_values, volume_3d_element_boundary_edge_whole_edge_variable_value, volume_3d_element_boundary_edge_constant_specified_volume_variable_value, volume_3d_element_boundary_edge_nodal_specified_variable_values))
	SUBTYPE OF (field_variable_element_definition);
	element : volume_3d_element_output_reference;
END_ENTITY;


ENTITY volume_3d_element_group
	SUBTYPE OF (element_group);
WHERE
	WR1 : SIZEOF(query(item <* elements |
       NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+
            'VOLUME_3D_ELEMENT_REPRESENTATION' IN TYPEOF (item))))=0;
END_ENTITY;


ENTITY volume_3d_element_integrated_matrix;
	descriptor : volume_3d_element_descriptor;
	property_type : matrix_property_type;
	integration_description : text;
END_ENTITY;


ENTITY volume_3d_element_integrated_matrix_with_definition
	SUBTYPE OF (volume_3d_element_integrated_matrix);
	integration_definition : volume_3d_element_field_integration;
END_ENTITY;


ENTITY volume_3d_element_location_point_variable_values
	SUBTYPE OF (volume_3d_element_field_variable_definition);
	basis : BOOLEAN;
	values_and_locations : SET [1:?] OF volume_3d_element_value_and_location;
	variable : volume_variable;
WHERE
	WR1 : consistent_set_values (values_and_locations, variable);
	WR2 : appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY volume_3d_element_nodal_specified_variable_values
	SUBTYPE OF (volume_3d_element_field_variable_definition);
	values : LIST [1:?] OF field_value;
	additional_node_values : BOOLEAN;
	variable : volume_variable;
WHERE
	WR1 : consistent_list_values (values, variable);
	WR2 : appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY volume_3d_element_representation
	SUBTYPE OF (element_representation);
	model_ref : fea_model_3d;
	element_descriptor : volume_3d_element_descriptor;
	material : element_material;
UNIQUE
	UR1 : model_ref, SELF\representation.name;
WHERE
	WR1 : SIZEOF (QUERY(item <* SELF\representation.items |
               'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
               'PARAMETRIC_VOLUME_3D_ELEMENT_COORDINATE_SYSTEM'
               IN TYPEOF (item))) +
       SIZEOF (QUERY(item <* SELF\representation.items |
               'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
               'ARBITRARY_VOLUME_3D_ELEMENT_COORDINATE_SYSTEM'
               IN TYPEOF (item))) = 1;
	WR2 : SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_MASS_DENSITY',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 
                  'FEA_MOISTURE_ABSORPTION'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
	WR3 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items);
	FU1 : required_3d_nodes (
        SELF\element_representation.node_list,
        element_descriptor.shape,
        element_descriptor\element_descriptor.topology_order);
END_ENTITY;


ENTITY volume_3d_element_value_and_location;
	simple_value : field_value;
	location : volume_element_location;
	coordinate_system : OPTIONAL volume_3d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;


ENTITY volume_3d_node_field_variable_definition
	SUBTYPE OF (field_variable_node_definition);
	simple_value : field_value;
	variable : volume_variable;
	coordinate_system : OPTIONAL volume_3d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY volume_3d_substructure_element_reference;
	substructure_element_ref : substructure_element_representation;
	element_ref : volume_3d_element_representation;
END_ENTITY;


ENTITY volume_3d_whole_element_variable_value
	SUBTYPE OF (volume_3d_element_field_variable_definition);
	simple_value : field_value;
	variable : volume_aggregated_variable;
	coordinate_system : OPTIONAL volume_3d_element_coordinate_system;
WHERE
	WR1 : necessary_value_coordinate_system (simple_value, coordinate_system);
	WR2 : consistent_value (simple_value, variable);
	WR3 : appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;


ENTITY volume_element_location;
	coordinates : fea_parametric_point;
END_ENTITY;


ENTITY volume_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VOLUME_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;


ENTITY volume_position_weight;
	integration_position : volume_element_location;
	integration_weight : context_dependent_measure;
END_ENTITY;


ENTITY volume_unit
	SUBTYPE OF (derived_unit);
WHERE
	WR1 : derive_dimensional_exponents(SELF) = 
          dimensional_exponents ( 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 );
END_ENTITY;


ENTITY week_of_year_and_day_date
	SUBTYPE OF (date);
	week_component : week_in_year_number;
	day_component : OPTIONAL day_in_week_number;
END_ENTITY;


ENTITY whole_model_analysis_message
	SUPERTYPE OF (whole_model_modes_and_frequencies_analysis_message)
	SUBTYPE OF (analysis_message);
END_ENTITY;


ENTITY whole_model_modes_and_frequencies_analysis_message
	SUBTYPE OF (whole_model_analysis_message);
	mode : count_measure;
	frequency : context_dependent_measure;
END_ENTITY;


ENTITY wire_shell
	SUBTYPE OF (topological_representation_item);
	wire_shell_extent : SET [1:?] OF loop;
WHERE
	WR1 : NOT mixed_loop_type_set(wire_shell_extent);
END_ENTITY;


ENTITY xor_expression
	SUBTYPE OF (binary_boolean_expression);
	SELF\binary_generic_expression.operands : LIST [2:2] OF boolean_expression;
END_ENTITY;


ENTITY year_month
	SUBTYPE OF (date);
	month_component : month_in_year_number;
END_ENTITY;


ENTITY zone_structural_makeup
	SUPERTYPE OF (ONEOF ((smeared_material_definition AND thickness_laminate_table), (smeared_material_definition AND percentage_laminate_table), thickness_laminate_table, percentage_laminate_table, smeared_material_definition))
	SUBTYPE OF (laminate_table);
END_ENTITY;


RULE alternative_solution_requires_solution_definition FOR (product_definition_formation);
    LOCAL
      solution_versions: SET OF product_definition_formation := [];
    END_LOCAL;
    solution_versions :=  QUERY( pdf <* product_definition_formation |
	  SIZEOF( QUERY( prpc <* USEDIN(pdf.of_product, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | 
      prpc.name = 'alternative solution')) = 1);
WHERE
	WR1 : SIZEOF( QUERY( pdf <* solution_versions |
        SIZEOF( QUERY( pd <* USEDIN(pdf, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF' + '.PRODUCT_DEFINITION.FORMATION') | 
        pd.frame_of_reference.name = 'alternative definition')) <> 1))= 0;
END_RULE;

RULE application_protocol_definition_required FOR (application_context);

WHERE
	WR1 : SIZEOF( QUERY( ac <* application_context | 
              (SIZEOF (QUERY (apd <* USEDIN(ac,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.APPLICATION_PROTOCOL_DEFINITION.APPLICATION') | 
                apd.application_interpreted_model_schema_name = 'ap203_configuration_controlled_3d_design_of_mechanical_parts_and_assemblies' 
                )) > 0) 
              )) > 0;
END_RULE;

RULE breakdown_element_requires_product_definition FOR (product_definition_formation);

WHERE
	WR1 : SIZEOF ( QUERY ( pdf <* product_definition_formation | 
        ( SIZEOF ( QUERY ( prpc <* USEDIN ( pdf.of_product ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | 
	    prpc.name =  'functionality' ) ) =  1 ) AND 
	    ( SIZEOF ( QUERY ( pd <* USEDIN ( pdf ,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION.FORMATION') | 
	    pd.frame_of_reference.name =  'functional definition' ) ) <1 ) ) ) =  0;
	WR2 : SIZEOF ( QUERY ( pdf <* product_definition_formation | 
        ( SIZEOF ( QUERY ( prpc <* USEDIN ( pdf.of_product , 
	    'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | 
        prpc.name =  'conceptual design' ) ) =  1 ) AND 
        ( SIZEOF (QUERY ( pd <* USEDIN ( pdf , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION.FORMATION' ) | 
        pd.frame_of_reference.name =  'conceptual definition' ) ) <1) ) ) =  0;
END_RULE;

RULE compatible_dimension FOR (cartesian_point, direction, representation_context, geometric_representation_context);

WHERE
	WR1 : SIZEOF(QUERY(x <* cartesian_point| SIZEOF(QUERY
       (y <* geometric_representation_context | item_in_context(x,y) AND
       (HIINDEX(x.coordinates) <> y.coordinate_space_dimension))) > 0 )) =0;
	WR2 : SIZEOF(QUERY(x <* direction | SIZEOF( QUERY
       (y <* geometric_representation_context | item_in_context(x,y) AND
       (HIINDEX(x.direction_ratios) <> y.coordinate_space_dimension)))
       > 0 )) = 0;
END_RULE;

RULE component_class_for_assembly_select FOR (composite_assembly_sequence_definition, next_assembly_usage_occurrence, product_related_product_category);
    LOCAL
      i,j,k :  INTEGER :=0;
      dkuhr :  LOGICAL :=TRUE;
      nnauo :  INTEGER :=0;
      nprpc :  INTEGER :=0;
      rp    :  product;
    END_LOCAL;
    REPEAT i:= LOINDEX (composite_assembly_sequence_definition) TO
               HIINDEX (composite_assembly_sequence_definition);
      nnauo := 0;  
      REPEAT j:= LOINDEX (next_assembly_usage_occurrence) TO
                 HIINDEX (next_assembly_usage_occurrence);
        IF (composite_assembly_sequence_definition[i] = 
          next_assembly_usage_occurrence[j].relating_product_definition) THEN
          rp := next_assembly_usage_occurrence[j].related_product_definition.
                formation.of_product;
          nprpc := 0;
          REPEAT k:= LOINDEX (product_related_product_category) TO
                     HIINDEX (product_related_product_category);
            IF ((rp IN product_related_product_category[k].products) AND
                (product_related_product_category[k].name IN ['ply',
                 'ply laminate', 'filament laminate', 'processed core',
                 'composite assembly'])) THEN
                nprpc := nprpc + 1;
            END_IF;
          END_REPEAT;
          IF (nprpc = 1) THEN
            nnauo := nnauo + 1;
          ELSE
            dkuhr := FALSE;
            ESCAPE;
          END_IF;
        END_IF;
      END_REPEAT;
      IF (dkuhr = FALSE) THEN
        ESCAPE; 
      END_IF;
      IF(nnauo = 0) THEN
        dkuhr := FALSE;
        ESCAPE;
      END_IF;
    END_REPEAT;
WHERE
	WR1 : dkuhr;
END_RULE;

RULE consistent_uncertainty FOR (global_uncertainty_assigned_context, qualified_representation_item, uncertainty_assigned_representation);

WHERE
	WR1 : SIZEOF ( QUERY ( guac <* global_uncertainty_assigned_context | 
    SIZEOF ( QUERY ( u1 <* guac.uncertainty | 
	SIZEOF ( QUERY ( u2 <* guac.uncertainty | u2.name =  u1.name ) ) >1 ) ) >0 ) ) =  0;
	WR2 : SIZEOF ( QUERY ( uar <* uncertainty_assigned_representation | 
	SIZEOF ( QUERY ( u1<* uar.uncertainty | 
	SIZEOF ( QUERY ( u2 <* uar.uncertainty | u2.name =  u1.name ) ) >1 ) ) >0 ) ) =  0;
	WR3 : SIZEOF ( QUERY ( qri <* qualified_representation_item |
     SIZEOF ( QUERY ( u1 <* qri.qualifiers |
     ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF' + '.UNCERTAINTY_QUALIFIER' IN TYPEOF ( u1 ) ) AND 
	( SIZEOF ( QUERY ( u2 <* qri.qualifiers |
     ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF' + '.UNCERTAINTY_QUALIFIER' IN TYPEOF ( u2 ) ) AND 
	( u2\uncertainty_qualifier.measure_name =  u1\uncertainty_qualifier.measure_name ) )
     ) >1 ) ) ) >0 ) ) =  0;
END_RULE;

RULE constraint_definition_requires_constraint_category FOR (product_definition);
    LOCAL
      constraint_definitions: SET OF product_definition := [];
    END_LOCAL;
      constraint_definitions :=  QUERY( pd <* product_definition |
      (pd.frame_of_reference.name = 'design constraint definition'));
WHERE
	WR1 : SIZEOF ( QUERY ( pd <* constraint_definitions | 
	    ( SIZEOF ( QUERY ( prpc <* USEDIN ( pd.formation.of_product ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | 
	    prpc. name ='requirement' ) ) =0 ) ) ) =0;
END_RULE;

RULE design_constraint_requires_product_definition FOR (product_definition_formation);

WHERE
	WR1 : SIZEOF ( QUERY ( pdf <* product_definition_formation | (
        SIZEOF ( QUERY ( prpc <* USEDIN ( pdf.of_product ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | 
	    prpc.name =  'requirement' ) ) >0 ) AND 
        ( SIZEOF ( QUERY ( pd <* USEDIN ( pdf , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION.FORMATION') | 
	    pd.frame_of_reference.name = 'design constraint definition' ) ) <1 ) ) ) =  0;
END_RULE;

RULE draughting_model_items_constraint FOR (draughting_model);

WHERE
	WR1 : SIZEOF(QUERY(dm <* draughting_model |
        NOT(SIZEOF(QUERY(it1 <* dm\representation.items |
        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_OCCURRENCE' IN TYPEOF(it1))
        AND
        NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DRAUGHTING_ANNOTATION_OCCURRENCE' IN TYPEOF(it1)))
          )) = 0)
        )) = 0;
	WR2 : SIZEOF(QUERY(dm <* draughting_model |
        NOT(SIZEOF(QUERY(it1 <* dm\representation.items |
        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAUGHTING_CALLOUT' IN TYPEOF(it1))
        AND
        NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAUGHTING_ELEMENTS' IN TYPEOF(it1)))
          )) = 0)
        )) = 0;
END_RULE;

RULE external_version_assignments_are_valid FOR (applied_external_identification_assignment);

WHERE
	WR1 : SIZEOF(QUERY(aia <* applied_external_identification_assignment | 
        NOT external_version_assignment_is_valid(aia)))=0;
END_RULE;

RULE material_for_coating_layer FOR (shape_aspect);
    LOCAL
      coating_layers: SET OF shape_aspect := [];
    END_LOCAL;
    coating_layers:= QUERY( r <* shape_aspect | 
	  (r.name = 'coating layer') );
WHERE
	WR1 : SIZEOF( QUERY( r <* coating_layers |
	    SIZEOF(USEDIN(r , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MATERIAL_DESIGNATION.DEFINITIONS'))<>1
        )) = 0;
END_RULE;

RULE plib_property_reference_requires_name_scope FOR (externally_defined_general_property);
    LOCAL
      known_sourced_properties : SET OF externally_defined_general_property;
    END_LOCAL;
      known_sourced_properties := QUERY( edc <* externally_defined_general_property | 
	    'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'KNOWN_SOURCE' IN TYPEOF(edc.source) );
WHERE
	WR1 : SIZEOF ( QUERY ( edgp <* known_sourced_properties | 
        ( SIZEOF ( QUERY ( edir <* USEDIN ( edgp, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.RELATING_ITEM' )| 
        ( edir.name =  'name scope' ) AND 
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_CLASS' IN  TYPEOF ( edir.related_item ) ) AND 
        ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'KNOWN_SOURCE' IN TYPEOF ( edir.related_item.source ) ) ) ) <>1 ) ) ) =  0;
END_RULE;

RULE plib_property_reference_requires_version FOR (externally_defined_general_property);
	LOCAL
	  plib_properties : SET OF externally_defined_general_property := [];
	END_LOCAL;
	  plib_properties := QUERY ( edgp <* externally_defined_general_property | 
		( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'KNOWN_SOURCE' IN TYPEOF ( edgp.source ) ) AND
		( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'KNOWN_SOURCE' + '.NAME' = 'ISO 13584 library' ) );
WHERE
	WR1 : SIZEOF( QUERY( edgp <* plib_properties | 
		(SIZEOF( QUERY( edir <* USEDIN(edgp, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT.ITEMS') | 
		(edir.role.name = 'version') )) <> 1) )) = 0;
END_RULE;

RULE ply_reference FOR (ply_laminate_sequence_definition, next_assembly_usage_occurrence, product_related_product_category);
    LOCAL
      i,j,k :  INTEGER;
      dkuhr :  LOGICAL := TRUE;
      nnauo :  INTEGER;
      nprpc :  INTEGER := 0;
      rp    :  product;
    END_LOCAL;
    REPEAT i:= LOINDEX (ply_laminate_sequence_definition) TO
               HIINDEX (ply_laminate_sequence_definition);
      nnauo := 0;  
      REPEAT j:= LOINDEX (next_assembly_usage_occurrence) TO 
                 HIINDEX (next_assembly_usage_occurrence);
        IF (ply_laminate_sequence_definition[i] = 
          next_assembly_usage_occurrence[j].relating_product_definition) THEN
          rp := next_assembly_usage_occurrence[j].related_product_definition.
                formation.of_product;
          nprpc := 0;
          REPEAT k:= LOINDEX (product_related_product_category) TO
                     HIINDEX (product_related_product_category);
            IF ((product_related_product_category[k].name = 'ply') AND
                (rp IN product_related_product_category[k].products)) THEN
                nprpc := nprpc + 1;
            END_IF;
          END_REPEAT;
          IF (nprpc = 1) THEN
            nnauo := nnauo + 1;
          ELSE
            dkuhr := FALSE;
            ESCAPE;
          END_IF;
        END_IF;
      END_REPEAT;
      IF (dkuhr = FALSE) THEN
        ESCAPE; 
      END_IF;
      IF(nnauo = 0) THEN
        dkuhr := FALSE;
        ESCAPE;
      END_IF;
    END_REPEAT;
WHERE
	WR1 : dkuhr;
END_RULE;

RULE ply_stock_material_select FOR (product_related_product_category, make_from_usage_option);
  LOCAL
    i,j,k,kp :  INTEGER;
    dkuhr    :  LOGICAL;
    nmfuo    :  INTEGER;
    nprpc    :  INTEGER := 0;
    rp       :  product;
  END_LOCAL;

  dkuhr := TRUE;
  REPEAT kp:= LOINDEX (product_related_product_category) TO
              HIINDEX (product_related_product_category);
 
    IF (product_related_product_category[kp].name = 'ply') THEN
    REPEAT i:= LOINDEX (product_related_product_category[kp].products) TO
               HIINDEX (product_related_product_category[kp].products);

      nmfuo := 0;  
      REPEAT j:= LOINDEX (make_from_usage_option) TO 
                 HIINDEX (make_from_usage_option);

          rp := make_from_usage_option[j].related_product_definition.
                formation.of_product;

        IF (product_related_product_category[kp].products[i] = rp) THEN

          REPEAT k:= LOINDEX (product_related_product_category) TO
                     HIINDEX (product_related_product_category);

            IF ((rp IN product_related_product_category[k].products) AND
                (product_related_product_category[k].name IN 
                 ['isotropic material', 'filament assembly', 
                  'discontinuous fiber assembly'])) THEN
                nprpc := nprpc + 1;
            END_IF;

          END_REPEAT;

          IF (nprpc = 1) THEN
            nmfuo := nmfuo + 1;
          ELSE
            dkuhr := FALSE;
            ESCAPE;
          END_IF;

        END_IF;

      END_REPEAT;

      IF (dkuhr = FALSE) THEN
        ESCAPE; 
      END_IF;
      IF(nmfuo <> 1) THEN
        dkuhr := FALSE;
        ESCAPE;
      END_IF;

    END_REPEAT;
    END_IF;

  END_REPEAT;
WHERE
	WR1 : dkuhr;
END_RULE;

RULE product_concept_feature_requires_category FOR (product_concept_feature);

WHERE
	WR1 : SIZEOF ( QUERY ( pcf <* product_concept_feature |
(SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE',
'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE'] * TYPEOF(pcf)) = 0) AND 
(SIZEOF ( QUERY ( aga <* USEDIN ( pcf , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'APPLIED_GROUP_ASSIGNMENT.' + 'ITEMS' ) | 
( aga.role.name = 'specification category member' ) AND 
('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'PRODUCT_CONCEPT_FEATURE_CATEGORY' IN TYPEOF ( aga.assigned_group )))) <>1 ) ) ) = 0;
END_RULE;

RULE product_definition_replacement_requires_effectivity_assignment FOR (product_definition_relationship);

WHERE
	WR1 : SIZEOF( QUERY( pdr <* product_definition_relationship | 
        (pdr.name = 'definition replacement') AND 
        (SIZEOF( USEDIN(pdr,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.APPLIED_EFFECTIVITY_ASSIGNMENT.ITEMS') ) = 0) ))
        = 0;
END_RULE;

RULE restrict_alternative_definition FOR (product_definition);
    LOCAL
      solution_definitions: SET OF product_definition := [];
    END_LOCAL;
      solution_definitions :=  QUERY( pd <* product_definition |
	 (pd.frame_of_reference.name = 'alternative definition'));
WHERE
	WR1 : SIZEOF ( QUERY ( pd <* solution_definitions | 
	    ( SIZEOF ( QUERY ( pdr <* USEDIN ( pd ,
	    'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF' + '.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) | 
	    pdr.name = 'solution alternative definition' ) ) <>1 ) ) ) = 0;
	WR2 : SIZEOF ( QUERY ( pd <* solution_definitions | 
	    NOT ( pd.name IN ['technical' , 'supplier' , 'technical supplier' , ''] ) ) ) = 0;
	WR3 : SIZEOF ( QUERY ( pd <* solution_definitions | 
	    ( pd.name IN ['supplier' , 'technical supplier'] ) AND (
	    SIZEOF ( QUERY ( aoa <* USEDIN ( pd.formation ,
	    'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF' + '.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS' ) | 
	    aoa.role.name = 'supplier' )) <>1 ) )) = 0;
END_RULE;

RULE restrict_assembly_category FOR (product_definition);
    LOCAL
      assembly_definitions: SET OF product_definition := [];
    END_LOCAL;
      assembly_definitions :=  QUERY( pd <* product_definition | 
        SIZEOF( QUERY( pdca <* USEDIN( pd, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION') |
        pdca.frame_of_reference.name= 'assembly definition')) > 0 );
WHERE
	WR1 : SIZEOF( QUERY( pd <* assembly_definitions | 
          NOT ('assembly' IN categories_of_product(pd.formation.of_product)) ))= 0;
END_RULE;

RULE restrict_centre_of_mass_representation FOR (representation);

WHERE
	WR1 : SIZEOF ( QUERY ( r <* representation | 
	( r.name ='centre of mass' ) AND 
	( ( SIZEOF ( r.items ) <>1 ) OR 
	(SIZEOF ( QUERY ( i <* r.items | 
	( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'POINT' IN TYPEOF ( i ) ) AND 
	( i.name = 'centre point' ) )) <>1 ) ) ) ) 
	=0;
END_RULE;

RULE restrict_classification_assignments FOR (applied_classification_assignment);

WHERE
	WR1 : SIZEOF(QUERY(aia <* applied_classification_assignment | 
		NOT class_assignment_is_valid(aia)))=0;
END_RULE;

RULE restrict_collection_category FOR (product_definition);
    LOCAL
      collection_definitions: SET OF product_definition := [];
    END_LOCAL;
      collection_definitions :=  QUERY( pd <* product_definition | 
        SIZEOF( QUERY( pdca <* USEDIN( pd, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF' + '.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION') |
        pdca.frame_of_reference.name= 'collection definition')) > 0 );
WHERE
	WR1 : SIZEOF( QUERY( pd <* collection_definitions | 
	    NOT ('collection' IN categories_of_product(pd.formation.of_product)) ))= 0;
END_RULE;

RULE restrict_concept_feature_operator FOR (concept_feature_operator);

WHERE
	WR1 : SIZEOF ( QUERY ( cfo <* concept_feature_operator | NOT
		( cfo.name IN ['and' , 'or' , 'oneof' , 'not' , 'implication'] ) ) ) = 0;
	WR2 : SIZEOF ( QUERY ( cfo <* concept_feature_operator | (cfo.name = 'implication' ) AND
	 ( SIZEOF ( QUERY (cfrwc <* USEDIN ( cfo , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION.' +
	'CONDITIONAL_OPERATOR' ) | 
		SIZEOF ( QUERY ( ccf <* USEDIN( cfrwc , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE.CONDITION' ) | 
		NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( ccf )))) >0 )) >0 ))) = 0;
	WR3 : SIZEOF( QUERY (cfo <* concept_feature_operator | (cfo.name = 'not')
	AND (SIZEOF(QUERY(cfrwc <* USEDIN(cfo, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION.CONDITIONAL_OPERATOR') | 
		cfrwc.related_product_concept_feature :<>: cfrwc.relating_product_concept_feature)) >0 ))) = 0;
END_RULE;

RULE restrict_configuration_design_for_class_breakdown_association FOR (configuration_design);

WHERE
	WR1 : SIZEOF ( QUERY ( cd <* configuration_design | 
	    ( cd.name ='functionality' ) AND 
        ( NOT ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF ( cd. design ) ) OR 
        ( cd.design\product_definition.frame_of_reference.name<> 'functional definition' ) ) 
        ) ) =0;
	WR2 : SIZEOF ( QUERY ( cd <* configuration_design | 
        ( cd.name='realization' ) AND 
        ( NOT ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF ( cd.design ) ) OR 
        ( cd.design\product_definition.frame_of_reference.name<> 'conceptual definition' ) ) 
        ) ) =0;
	WR3 : SIZEOF ( QUERY ( cd <* configuration_design | 
        ( cd.name IN ['functionality' , 'realization'] ) AND 
        ( NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_CLASS' IN TYPEOF ( cd.configuration.item_concept ) ) ) 
        ) ) =0;
END_RULE;

RULE restrict_configuration_design_for_design_constraint FOR (configuration_design);

WHERE
	WR1 : SIZEOF ( QUERY (cd <* configuration_design | 
	    (cd.name = 'design constraint usage') AND 
        (NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF ( cd.design ) ) OR 
        (cd.design\product_definition.frame_of_reference.name <> 'design constraint definition')))) = 0;
END_RULE;

RULE restrict_group_relationship_for_classification_hierarchy FOR (group_relationship);

WHERE
	WR1 : SIZEOF( QUERY( gr <* group_relationship | 
  (gr\group_relationship.name = 'class hierarchy') AND 
  (NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CLASS' IN TYPEOF(gr\group_relationship.related_group)) OR 
  NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CLASS' IN TYPEOF(gr\group_relationship.relating_group))) )) = 0;
END_RULE;

RULE restrict_group_relationship_for_specification_category FOR (group_relationship);

WHERE
	WR1 : SIZEOF( QUERY( gr <* group_relationship | 
  (gr.name = 'specification category hierarchy') AND 
  (NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY' IN TYPEOF(gr.related_group)) 
  OR NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY' IN TYPEOF(gr.relating_group))) )) = 0;
END_RULE;

RULE restrict_language_assignment_per_attribute FOR (attribute_language_assignment);

WHERE
	WR1 : SIZEOF ( QUERY ( ala1 <* attribute_language_assignment |
	SIZEOF(QUERY( it <* ala1.items |
	   SIZEOF ( QUERY ( ala2 <* USEDIN ( it ,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS' ) | 
		( ala1\attribute_classification_assignment.attribute_name = ala2\attribute_classification_assignment.attribute_name ) AND 
		( ala1\attribute_classification_assignment.assigned_class :=: ala2\attribute_classification_assignment.assigned_class )
		 )) >1 
	   )) >0 
	)) =0;
END_RULE;

RULE restrict_part_occurrence FOR (product_definition);
    LOCAL
      part_occurrences: SET OF product_definition := QUERY(pd <* product_definition | 
	    ( pd.frame_of_reference.name = 'part occurrence' ));
    END_LOCAL;
WHERE
	WR1 : SIZEOF ( QUERY ( pd <* part_occurrences | 
	    ( NOT( pd.name IN 
        ['single instance' , 'selected instance' ,'quantified instance' , 'specified instance' ] ) ) ) ) = 0;
	WR2 : SIZEOF ( QUERY ( pd <* part_occurrences | 
 	    (SIZEOF ( QUERY ( pdr <* USEDIN ( pd ,
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) | 
	    pdr.name = 'definition usage' ) ) <>1 ) AND 
        ( SIZEOF ( QUERY ( cd <* USEDIN ( pd , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CONFIGURATION_DESIGN.DESIGN' ) | 
        ( cd.name = 'occurrence usage definition' ) AND 
        ( NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'PRODUCT_IDENTIFICATION' IN TYPEOF( cd.configuration ) ) ) ) ) <>1 ) ) ) = 0;
	WR3 : SIZEOF ( QUERY ( pd <* part_occurrences |  
        (SIZEOF ( QUERY ( cd <* USEDIN ( pd , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) |
        ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +'PRODUCT_DEFINITION_USAGE' IN TYPEOF ( cd ) ) ) ) = 0 )AND
        ( SIZEOF ( USEDIN ( pd , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE' ) ) = 0 ) ) ) = 0;
	WR4 : SIZEOF ( QUERY ( pd <* part_occurrences | 
        ( pd.name = 'selected instance' ) AND 
        NOT valid_selected_instance_representation(pd) ))=0;
	WR5 : SIZEOF ( QUERY ( pd <* part_occurrences | 
        ( pd.name = 'quantified instance' ) AND 
        ( SIZEOF ( QUERY (ppd <* USEDIN ( pd , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +'PROPERTY_DEFINITION.DEFINITION' ) |
        ( ppd.name ='occurrence quantity' ) AND 
        ( SIZEOF ( QUERY ( pdr <*USEDIN ( ppd , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION' ) | (
        pdr.used_representation.name = 'quantity' ) AND 
        (SIZEOF ( pdr.used_representation.items ) = 1 ) AND 
        (SIZEOF ( QUERY ( i <* pdr.used_representation.items | 
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND
        ( i.name = 'quantity measure' ) ) ) = 1)))= 1 )))= 0 )))= 0;
	WR6 : SIZEOF ( QUERY ( pd <* part_occurrences | 
        ( pd.name = 'specified instance' ) AND 
        ( SIZEOF ( QUERY (
        pdor <* USEDIN ( pd , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +'PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE' ) | 
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +'SPECIFIED_HIGHER_USAGE_OCCURRENCE' IN TYPEOF ( pdor.occurrence_usage ) ) ) = 0 ) ) ) = 0;
END_RULE;

RULE restrict_part_occurrence_category FOR (product_definition);
    LOCAL
      part_occurrences: SET OF product_definition := QUERY( pd <* product_definition |(
        pd.frame_of_reference.name = 'part occurrence'));
    END_LOCAL;
WHERE
	WR1 : SIZEOF( QUERY( pd <* part_occurrences | 
        (SIZEOF( QUERY( prpc <* USEDIN(pd.formation.of_product, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | 
        prpc.name IN ['part','raw material','tool'] )) = 0 ) )) = 0;
END_RULE;

RULE restrict_product_definitions_for_base_element FOR (product_definition_relationship);

WHERE
	WR1 : SIZEOF ( QUERY ( pdr <* product_definition_relationship |
       ( pdr. name = 'solution alternative definition' ) AND 
       ( NOT( pdr. relating_product_definition.frame_of_reference.name
        IN [ 'alternative definition' , 'functional definition' , 'conceptual definition' ] ) OR 
       ( pdr.related_product_definition.frame_of_reference.name<>'alternative definition' ) ) ) ) =0;
END_RULE;

RULE restrict_product_definitions_for_collection FOR (product_definition_relationship);

WHERE
	WR1 : SIZEOF ( QUERY ( pdr <* product_definition_relationship |
       ( pdr. name = 'collection membership' ) AND 
       ( ( pdr.relating_product_definition.frame_of_reference.name<>'part definition' ) OR 
       ( pdr.related_product_definition.frame_of_reference.name<>'part occurrence' ) OR 
       ( SIZEOF ( QUERY ( pdca <* USEDIN (pdr.relating_product_definition ,
       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF' + '.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION') | 
       ( pdca.role.name = 'part definition type' ) AND 
       ( pdca.frame_of_reference.name = 'collection definition' ) )) =0 ) ) ) ) =0;
END_RULE;

RULE restrict_product_definitions_for_definition_usage FOR (product_definition_relationship);

WHERE
	WR1 : SIZEOF ( QUERY ( pdr <* product_definition_relationship |
        ( pdr.name = 'definition usage' ) AND 
        ( ( pdr.relating_product_definition.frame_of_reference.name<> 'part definition' ) OR 
        ( pdr.related_product_definition.frame_of_reference.name<>'part occurrence' )))) =0;
END_RULE;

RULE restrict_product_definitions_for_design_constraint_association FOR (product_definition_relationship);

WHERE
	WR1 : SIZEOF ( QUERY ( pdr <* product_definition_relationship |
        ( pdr. name = 'design constraint association' ) AND 
	    ( (pdr. relating_product_definition.frame_of_reference.name<>'design constraint definition' ) OR 
	    NOT ( pdr.related_product_definition.frame_of_reference.name IN 
	    ['alternative definition' , 'functional definition' ,'conceptual definition' ] ) ) ) ) =0;
END_RULE;

RULE restrict_product_definitions_for_part_definition_relationship FOR (product_definition_relationship);

WHERE
	WR1 : SIZEOF ( QUERY ( pdr <* product_definition_relationship |
        ( pdr.name IN [ 'geometrical relationship' , 'definition replacement' ] ) AND 
	    ( ( pdr.relating_product_definition.frame_of_reference.name <>'part definition' ) OR 
        ( pdr.related_product_definition.frame_of_reference.name <>'part definition' ) ) ) ) =0;
END_RULE;

RULE restrict_representation_for_surface_condition FOR (property_definition_representation);

WHERE
	WR1 : SIZEOF(QUERY(pdr <* property_definition_representation | 
        NOT surface_condition_correlation(pdr.definition, pdr.used_representation) ))=0;
END_RULE;

RULE restrict_treatment_result FOR (representation);
    LOCAL
      treatment_results: SET OF representation := [];
    END_LOCAL;
    treatment_results:= QUERY( r <* representation | 
	  (r.name = 'treatment result') );
WHERE
	WR1 : (SIZEOF( QUERY( r <* treatment_results | (SIZEOF(r.items) > 2) )) = 0) AND
        (SIZEOF( QUERY( r <* treatment_results |
        (SIZEOF( QUERY( i <* r.items | 
         NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i)) )) > 0) )) = 0);
	WR2 : SIZEOF( QUERY( r <* treatment_results | 
        (SIZEOF( QUERY( i <* r.items | i.name = 'result' )) = 0) )) = 0;
	WR3 : SIZEOF( QUERY( r <* treatment_results | 
        (SIZEOF( QUERY( i <* r.items | i.name = 'purpose' )) > 1) )) = 0;
END_RULE;

RULE selected_instance_usage_requires_representation FOR (assembly_component_usage);
    LOCAL
      selected_instance_usages: SET OF assembly_component_usage := QUERY( acr <* assembly_component_usage|
        (acr.name = 'selected instance usage'));
    END_LOCAL;
WHERE
	WR1 : SIZEOF ( QUERY ( acr <* selected_instance_usages | 
        NOT valid_selected_instance_representation(acr) ))=0;
END_RULE;

RULE solution_definition_requires_solution_category FOR (product_definition);
    LOCAL
      solution_definitions: SET OF product_definition := [];
    END_LOCAL;
      solution_definitions :=  QUERY( pd <* product_definition |
        (pd.frame_of_reference.name = 'alternative definition'));
WHERE
	WR1 : SIZEOF( QUERY( pd <* solution_definitions | 
        (SIZEOF( QUERY( prpc <* USEDIN(pd.formation.of_product, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | 
	     prpc.name = 'alternative solution')) = 0 ) )) = 0;
END_RULE;

RULE stock_material_reference FOR (percentage_ply_definition, make_from_usage_option, product_related_product_category);
    LOCAL
      i,j,k :  INTEGER;
      dkuhr :  LOGICAL;
      nmfuo :  INTEGER;
      nprpc :  INTEGER;
      rp     :  product;
    END_LOCAL;
    dkuhr := TRUE;
    REPEAT i:= LOINDEX (percentage_ply_definition) TO
               HIINDEX (percentage_ply_definition);
      nmfuo := 0;  
      REPEAT j:= LOINDEX (make_from_usage_option) TO 
                 HIINDEX (make_from_usage_option);
        IF (percentage_ply_definition[i] = 
          make_from_usage_option[j].relating_product_definition) THEN
          rp := make_from_usage_option[j].related_product_definition.
                formation.of_product;
          nprpc := 0;
          REPEAT k:= LOINDEX (product_related_product_category) TO
                     HIINDEX (product_related_product_category);
            IF ((rp IN product_related_product_category[k].products) AND
                (product_related_product_category[k].name IN 
                ['anisotropic material', 'isotropic material', 'stock core',
                 'filament assembly', 'discontinuous fiber assembly'])) THEN
                nprpc := nprpc + 1;
            END_IF;
          END_REPEAT;
          IF (nprpc = 1) THEN
            nmfuo := nmfuo + 1;
          ELSE
            dkuhr := FALSE;
            ESCAPE;
          END_IF;
        END_IF;
      END_REPEAT;
      IF (dkuhr = FALSE) THEN
        ESCAPE; 
      END_IF;
      IF(nmfuo = 0) THEN
        dkuhr := FALSE;
        ESCAPE;
      END_IF;
    END_REPEAT;
WHERE
	WR1 : dkuhr;
END_RULE;

RULE styled_curve FOR (styled_item);

WHERE
	WR1 : SIZEOF( QUERY( si <* styled_item | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE' IN TYPEOF (si.item)) AND (SIZEOF (QUERY (psa <* si.styles | (SIZEOF (QUERY (cs <* psa.styles | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE' IN TYPEOF (cs)) )) > 0) )) <> 1) )) = 0;
END_RULE;

RULE subtype_exclusiveness_geometric_tolerance FOR (geometric_tolerance);

WHERE
	WR1 : SIZEOF(QUERY (gt <* geometric_tolerance | NOT (type_check_function(gt, ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANGULARITY_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CIRCULAR_RUNOUT_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COAXIALITY_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONCENTRICITY_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CYLINDRICITY_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FLATNESS_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE_PROFILE_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARALLELISM_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PERPENDICULARITY_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POSITION_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ROUNDNESS_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRAIGHTNESS_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_PROFILE_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SYMMETRY_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TOTAL_RUNOUT_TOLERANCE'] , 3)))) = 0;
END_RULE;

RULE subtype_exclusiveness_representation_item FOR (representation_item);

WHERE
	WR1 : SIZEOF(QUERY (cri <* representation_item | 
      NOT (type_check_function(cri,['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM',
                                    'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VALUE_REPRESENTATION_ITEM',
                                    'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOUND_REPRESENTATION_ITEM'] , 3)))) = 0;
END_RULE;

RULE subtype_mandatory_geometric_tolerance FOR (geometric_tolerance);

WHERE
	WR1 : SIZEOF(QUERY (gt <* geometric_tolerance | NOT (type_check_function(gt, ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANGULARITY_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CIRCULAR_RUNOUT_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COAXIALITY_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONCENTRICITY_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CYLINDRICITY_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FLATNESS_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE_PROFILE_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARALLELISM_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PERPENDICULARITY_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POSITION_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ROUNDNESS_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRAIGHTNESS_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_PROFILE_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SYMMETRY_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TOTAL_RUNOUT_TOLERANCE'] , 0)))) = 0;
END_RULE;

RULE text_font_usage FOR (externally_defined_text_font, pre_defined_text_font);

WHERE
	WR1 : SIZEOF (QUERY (pdtf <* pre_defined_text_font | SIZEOF (USEDIN (pdtf, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TEXT_LITERAL.FONT')) = 0 )) = 0;
	WR2 : SIZEOF (QUERY (edtf <* externally_defined_text_font | SIZEOF (USEDIN (edtf, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TEXT_LITERAL.FONT')) = 0 )) = 0;
END_RULE;

RULE thickness_laminate_table_component_select FOR (thickness_laminate_definition, next_assembly_usage_occurrence, product_related_product_category);
    LOCAL
      i,j,k :  INTEGER;
      dkuhr :  LOGICAL;
      nnauo :  INTEGER;
      nprpc :  INTEGER;
      rp    :  product;
    END_LOCAL;
    dkuhr := TRUE;
    REPEAT i:= LOINDEX (thickness_laminate_definition) TO
               HIINDEX (thickness_laminate_definition);
      nnauo := 0;  
      REPEAT j:= LOINDEX (next_assembly_usage_occurrence) TO 
                 HIINDEX (next_assembly_usage_occurrence);
        IF (thickness_laminate_definition[i] = 
          next_assembly_usage_occurrence[j].relating_product_definition) THEN
          rp := next_assembly_usage_occurrence[j].related_product_definition.
                formation.of_product;
          nprpc := 0;
          REPEAT k:= LOINDEX (product_related_product_category) TO
                     HIINDEX (product_related_product_category);
            IF ((rp IN product_related_product_category[k].products) AND
                (product_related_product_category[k].name IN 
                 ['ply', 'filament laminate', 'processed core'])) THEN
                nprpc := nprpc + 1;
            END_IF;
          END_REPEAT;
          IF (nprpc = 1) THEN
            nnauo := nnauo + 1;
          ELSE
            dkuhr := FALSE;
            ESCAPE;
          END_IF;
        END_IF;
      END_REPEAT;
      IF (dkuhr = FALSE) THEN
        ESCAPE;
      END_IF;
      IF (nnauo <> 1) THEN
        dkuhr := FALSE;
        ESCAPE;
      END_IF;
    END_REPEAT;
WHERE
	WR1 : dkuhr;
END_RULE;

RULE validate_dependently_instantiable_entity_data_types FOR (action_method_role, annotation_text, attribute_value_role, auxiliary_geometric_representation_item, bounded_curve, bounded_surface, cartesian_transformation_operator, concept_feature_relationship, concept_feature_relationship_with_condition, document_usage_constraint, edge_blended_solid, effectivity_context_role, event_occurrence_role, explicit_procedural_representation_item_relationship, indirectly_selected_elements, local_time, modified_solid_with_placed_configuration, one_direction_repeat_factor, oriented_open_shell, oriented_path, positioned_sketch, procedural_representation, procedural_representation_sequence, property_distribution_description, runout_zone_orientation, solid_with_depression, solid_with_hole, solid_with_pocket, solid_with_protrusion, solid_with_shape_element_pattern, solid_with_slot, state_type_role, swept_area_solid, symbol_target, tolerance_zone_form, two_direction_repeat_factor, user_selected_elements, variational_representation_item, view_volume, volume);
LOCAL
  number_of_input_instances : INTEGER;
  previous_in_chain : LIST OF GENERIC := [];
  set_of_input_types : SET OF STRING := [];
  all_instances : SET OF GENERIC := [];
END_LOCAL;

  all_instances := action_method_role + annotation_text + attribute_value_role + auxiliary_geometric_representation_item + bounded_curve + bounded_surface + cartesian_transformation_operator + concept_feature_relationship + concept_feature_relationship_with_condition + document_usage_constraint + edge_blended_solid + effectivity_context_role + event_occurrence_role + explicit_procedural_representation_item_relationship + indirectly_selected_elements + local_time + modified_solid_with_placed_configuration + one_direction_repeat_factor + oriented_open_shell + oriented_path + positioned_sketch + procedural_representation + procedural_representation_sequence + property_distribution_description + runout_zone_orientation + solid_with_depression + solid_with_hole + solid_with_pocket + solid_with_protrusion + solid_with_shape_element_pattern + solid_with_slot + state_type_role + swept_area_solid + symbol_target + tolerance_zone_form + two_direction_repeat_factor + user_selected_elements + variational_representation_item + view_volume + volume;--<make a union of all implicit populations of the FOR-clause>
number_of_input_instances := SIZEOF(all_instances);
(* Collect all type strings of all FOR instances into one set. *)
REPEAT i:=1 TO number_of_input_instances;
  set_of_input_types := set_of_input_types + TYPEOF(all_instances[i]);
END_REPEAT;
WHERE
	WR1 : dependently_instantiated(all_instances, set_of_input_types,
                                previous_in_chain);
END_RULE;

FUNCTION acyclic
	(arg1: generic_expression; arg2: SET [0:?] OF generic_expression) : BOOLEAN;
LOCAL
	result: BOOLEAN := TRUE;
END_LOCAL;

IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SIMPLE_GENERIC_EXPRESSION'
	IN TYPEOF (arg1)) 
THEN
	RETURN (TRUE);
END_IF;

IF arg1 IN arg2 
THEN 
	RETURN (FALSE);
END_IF;

IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.UNARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	RETURN 
	(acyclic(arg1\unary_generic_expression.operand,arg2+[arg1]));
END_IF;

IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BINARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	RETURN 
	(acyclic(arg1\binary_generic_expression.operands[1],arg2+[arg1])
	AND
	acyclic(arg1\binary_generic_expression.operands[2],arg2+[arg1]));
END_IF;

IF 
'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MULTIPLE_ARITY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	result := TRUE;
	REPEAT i := 1 TO 
			SIZEOF (arg1\multiple_arity_generic_expression.operands);
		result := result AND
		acyclic(arg1\multiple_arity_generic_expression.operands[i], arg2+[arg1]);
	END_REPEAT;

	RETURN (result);
END_IF;
	RETURN (result);
END_FUNCTION;

FUNCTION acyclic_composite_text
	(start_composite: composite_text; child_text: SET [1:?] OF text_or_character) : LOGICAL;
    LOCAL
      i : INTEGER;
      local_composite_text : SET [0:?] OF composite_text;
      local_annotation_text : SET [0:?] OF annotation_text;
      local_children : SET [0:?] OF text_or_character;
    END_LOCAL;

    local_composite_text := QUERY (child <* child_text |
                          ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_TEXT'
                           IN TYPEOF (child)));

    IF (SIZEOF (local_composite_text) > 0) 
      THEN
        REPEAT i := 1 TO HIINDEX (local_composite_text);
          IF (start_composite :=: local_composite_text[i]) 
            THEN
              RETURN (FALSE);
          END_IF;
        END_REPEAT;
    END_IF;

    local_children := child_text;

    IF (SIZEOF (local_composite_text)) > 0 THEN
      REPEAT i := 1 TO HIINDEX (local_composite_text);
        local_children := local_children +
                          local_composite_text[i].collected_text;
      END_REPEAT;
    END_IF;

    local_annotation_text := QUERY (child <* child_text |
                            ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT'
                             IN TYPEOF (child)));

    IF (SIZEOF (local_annotation_text) > 0) THEN
      REPEAT i := 1 TO HIINDEX (local_annotation_text);
        local_children := local_children +
        QUERY (item <* local_annotation_text[i]\mapped_item.
                       mapping_source.mapped_representation.items |
          SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_TEXT'] *
                  TYPEOF(item)) > 0);
      END_REPEAT;
    END_IF;

    IF (local_children :<>: child_text) THEN
      RETURN (acyclic_composite_text (start_composite, local_children));
    ELSE
      RETURN (TRUE);
    END_IF;
END_FUNCTION;

FUNCTION acyclic_curve_replica
	(rep: curve_replica; parent: curve) : BOOLEAN;
IF NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type curve_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same curve_replica, otherwise,
   call function again with the parents own parent_curve.     *)
    ELSE
    RETURN(acyclic_curve_replica(rep,
               parent\curve_replica.parent_curve));
    END_IF;
END_FUNCTION;

FUNCTION acyclic_mapped_representation
	(mi: mapped_item) : BOOLEAN;
    LOCAL
      rms : SET OF representation_map;
      mis : SET OF mapped_item;
      rs1, rs2 : SET OF representation;
    END_LOCAL;
 
    rs1 := using_representations(mi);
    rs2 := [];
    -- loop as long as there are elements in rs1
    REPEAT WHILE SIZEOF(rs1) > 0; 
      REPEAT i := 1 TO HIINDEX(rs1);
        -- Determine the set of representation_map that reference the parent_set
        rms := bag_to_set(USEDIN(rs1[i], 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REPRESENTATION_MAP.MAPPED_REPRESENTATION'));
        IF SIZEOF(rms) > 0 THEN
          REPEAT j := 1 TO HIINDEX(rms);
            mis := bag_to_set(USEDIN(rms[i], 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM.MAPPING_SOURCE'));
            IF SIZEOF(mis) > 0 THEN
              REPEAT j := 1 TO HIINDEX(mis);
                -- check mis members for instance equal with mi. If so then there is a cycle
                IF mis[i] :=: mi THEN
                  RETURN (FALSE);
                END_IF;
                rs2 := rs2 + using_representations(mis[i]);
              END_REPEAT;
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
      rs1 := rs2;
      rs2 := [];
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION;

FUNCTION acyclic_point_replica
	(rep: point_replica; parent: point) : BOOLEAN;
IF NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type point_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same point_replica, otherwise,
   call function again with the parents own parent_pt.     *)
    ELSE RETURN(acyclic_point_replica(rep, parent\point_replica.parent_pt));
    END_IF;
END_FUNCTION;

FUNCTION acyclic_product_category_relationship
	(relation: product_category_relationship; children: SET [0:?] OF product_category) : BOOLEAN;
    LOCAL
      x : SET OF product_category_relationship;
      local_children : SET OF product_category;
    END_LOCAL;

    REPEAT i := 1 TO HIINDEX(children);
      IF relation.category :=: children[i] THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set(USEDIN(relation.category, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
    local_children := children + relation.category;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_product_category_relationship(x[i], local_children) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN (TRUE);
END_FUNCTION;

FUNCTION acyclic_product_definition_relationship
	(relation: product_definition_relationship; relatives: SET [1:?] OF product_definition; specific_relation: STRING) : BOOLEAN;
    LOCAL
      x : SET OF product_definition_relationship;
    END_LOCAL;

    IF relation.relating_product_definition IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(pd <* bag_to_set(USEDIN(relation.relating_product_definition, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')) | specific_relation IN TYPEOF(pd));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_definition_relationship(x[i], relatives + relation.relating_product_definition, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION;

FUNCTION acyclic_representation_relationship
	(relation: representation_relationship; relatives: SET [1:?] OF representation; specific_relation: STRING) : BOOLEAN;
    LOCAL
      x : SET OF representation_relationship;
    END_LOCAL;

    IF relation.rep_1 IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(r <* bag_to_set(USEDIN(relation.rep_1, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.' + 'REP_2')) | specific_relation IN TYPEOF(r));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_representation_relationship(x[i], relatives + relation.rep_1, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION;

FUNCTION acyclic_solid_replica
	(rep: solid_replica; parent: solid_model) : BOOLEAN;
IF NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type solid_replica. *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same solid_replica, otherwise,
   call function again with the parents own parent_solid.     *)
    ELSE RETURN(acyclic_solid_replica(rep,
                      parent\solid_replica.parent_solid));
    END_IF;
END_FUNCTION;

FUNCTION acyclic_surface_replica
	(rep: surface_replica; parent: surface) : BOOLEAN;
IF NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type surface_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same surface_replica, otherwise,
   call function again with the parents own parent_surface.     *)
    ELSE RETURN(acyclic_surface_replica(rep,
                   parent\surface_replica.parent_surface));
    END_IF;
END_FUNCTION;

FUNCTION advanced_face_properties
	(testface: face) : BOOLEAN;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF(testface) THEN
    RETURN (TRUE);
END_IF;
(* if testface is a subface recursively test the parent_face,
return FALSE for all other types of face *)
IF  ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SUBFACE' IN TYPEOF(testface)) THEN
     RETURN(advanced_face_properties(testface\subface.parent_face));
   ELSE RETURN (FALSE);
END_IF;
END_FUNCTION;

FUNCTION all_members_of_es
	(sv: SET [0:?] OF maths_value; es: elementary_space_enumerators) : LOGICAL;
CONSTANT
    base_types : SET OF STRING := ['NUMBER','COMPLEX_NUMBER_LITERAL','REAL',
      'INTEGER','LOGICAL','BOOLEAN','STRING','BINARY','MATHS_SPACE',
      'MATHS_FUNCTION','LIST','ELEMENTARY_SPACE_ENUMERATORS','ORDERING_TYPE',
      'LOWER_UPPER','SYMMETRY_TYPE','ELEMENTARY_FUNCTION_ENUMERATORS',
      'OPEN_CLOSED','SPACE_CONSTRAINT_TYPE','REPACKAGE_OPTIONS',
      'EXTENSION_OPTIONS'];
  END_CONSTANT;
  LOCAL
    v : maths_value;
    key_type : STRING := '';
    types : SET OF STRING;
    ge : generic_expression;
    cum : LOGICAL := TRUE;
    vspc : maths_space;
  END_LOCAL;
  IF NOT EXISTS (sv) OR NOT EXISTS (es) THEN  RETURN (FALSE);  END_IF;
  CASE es OF
  es_numbers :         key_type := 'NUMBER';
  es_complex_numbers : key_type := 'COMPLEX_NUMBER_LITERAL';
  es_reals :           key_type := 'REAL';
  es_integers :        key_type := 'INTEGER';
  es_logicals :        key_type := 'LOGICAL';
  es_booleans :        key_type := 'BOOLEAN';
  es_strings :         key_type := 'STRING';
  es_binarys :         key_type := 'BINARY';
  es_maths_spaces :    key_type := 'MATHS_SPACE';
  es_maths_functions : key_type := 'MATHS_FUNCTION';
  es_generics :        RETURN (TRUE);
  END_CASE;
  REPEAT i := 1 TO SIZEOF (sv);
    IF NOT EXISTS (sv[i]) THEN  RETURN (FALSE);  END_IF;
    v := simplify_maths_value(sv[i]);
    types := stripped_typeof(v);
    IF key_type IN types THEN  SKIP;  END_IF;
    IF (es = es_numbers) AND ('COMPLEX_NUMBER_LITERAL' IN types) THEN  SKIP;  END_IF;
    IF SIZEOF (base_types * types) > 0 THEN  RETURN (FALSE);  END_IF;
    -- Must be a generic_expression which doesn't simplify and which is not a
    ge := v;
    IF has_values_space(ge) THEN
      vspc := values_space_of(ge);
      IF NOT subspace_of_es(vspc,es) THEN
        IF NOT compatible_spaces(vspc,make_elementary_space(es)) THEN
          RETURN (FALSE);
        END_IF;
        cum := UNKNOWN;
      END_IF;
    ELSE
      cum := UNKNOWN;
    END_IF;
    IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
  END_REPEAT;
  RETURN (cum);
END_FUNCTION;

FUNCTION all_mesh_vertices
	(arg: array_based_unstructured_mesh_and_vertices) : BOOLEAN;
LOCAL
  vertex_set : SET OF vertex := [];
  cell : vertex_defined_cell;
END_LOCAL;
  REPEAT i := 1 TO arg.cell_count;
    cell := arg.cells[i];
    REPEAT j := 1 TO cell.vn_count;
      vertex_set := vertex_set + cell.vertices[j];
    END_REPEAT;
  END_REPEAT;
  IF (SIZEOF(vertex_set) <> arg.index_count) THEN
    RETURN(FALSE);
  END_IF;
  REPEAT i := 1 TO arg.index_count;
    IF (NOT (arg.vertices[i] IN vertex_set) ) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION any_space_satisfies
	(sc: space_constraint_type; spc: maths_space) : BOOLEAN;
  LOCAL
    spc_id : elementary_space_enumerators;
  END_LOCAL;
  IF (sc = sc_equal) OR NOT ('ELEMENTARY_SPACE' IN stripped_typeof(spc)) THEN
    RETURN (FALSE);
  END_IF;
  spc_id := spc\elementary_space.space_id;
  IF sc = sc_subspace THEN
    RETURN (bool(spc_id = es_generics));
  END_IF;
  IF sc = sc_member THEN
    RETURN (bool((spc_id = es_generics) OR (spc_id = es_maths_spaces)));
  END_IF;
  -- Should be unreachable.
  RETURN (?);
END_FUNCTION;

FUNCTION appropriate_list_value_existence
	(values: LIST [1:?] OF GENERIC; type_self: SET [1:?] OF STRING) : BOOLEAN;
    LOCAL
     i                      : INTEGER;
    END_LOCAL;

    REPEAT i := 1 TO HIINDEX (values);
       IF NOT (appropriate_value_existence (values[i], type_self)) THEN
          RETURN (FALSE);
       END_IF;
    END_REPEAT;

    RETURN (TRUE);
END_FUNCTION;

FUNCTION appropriate_set_value_existence
	(values_and_locations: SET [1:?] OF GENERIC; type_self: SET [1:?] OF STRING) : BOOLEAN;
    LOCAL
     i                      : INTEGER;
    END_LOCAL;

    REPEAT i := 1 TO HIINDEX (values_and_locations);
       IF NOT (appropriate_value_existence
                (values_and_locations[i].simple_value, type_self)) 
          THEN
          RETURN (FALSE);
       END_IF;
    END_REPEAT;

    RETURN (TRUE);
END_FUNCTION;

FUNCTION appropriate_value_existence
	(a_value_e: GENERIC; type_self: SET [1:?] OF STRING) : BOOLEAN;
    LOCAL
     feacr                  : STRING;
     value_typeof           : SET [1:?] OF STRING;
    END_LOCAL;
        
    feacr := 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.';
    value_typeof := TYPEOF(a_value_e);

    IF (((feacr + 'OUTPUT_REQUEST_STATE') IN type_self) AND
       NOT ((feacr + 'UNSPECIFIED_VALUE') IN value_typeof)) THEN
       RETURN (FALSE);
    END_IF;

    RETURN (TRUE);
END_FUNCTION;

FUNCTION aspect_ratio
	(p: planar_box) : positive_ratio_measure;
IF (p.size_in_x > 0.) AND (p.size_in_y > 0.) THEN
      RETURN (p.size_in_x / p.size_in_y);
    ELSE
      RETURN (?);
    END_IF;
END_FUNCTION;

FUNCTION assoc_product_space
	(ts1: tuple_space; ts2: tuple_space) : tuple_space;
  LOCAL
    types1 : SET OF STRING := stripped_typeof (ts1);
    types2 : SET OF STRING := stripped_typeof (ts2);
    up1, up2 : uniform_product_space := make_uniform_product_space(the_reals,1);
    lp1, lp2, lps : listed_product_space := the_zero_tuple_space;
    et1, et2, ets : extended_tuple_space := the_tuples;
    use_up1, use_up2, use_lp1, use_lp2 : BOOLEAN;
    factors : LIST OF maths_space := [];
    tspace : tuple_space;
  END_LOCAL;
  -- Identify type of first operand
  IF 'UNIFORM_PRODUCT_SPACE' IN types1 THEN
    up1 := ts1;  use_up1 := true;  use_lp1 := false;
  ELSE
    IF 'LISTED_PRODUCT_SPACE' IN types1 THEN
      lp1 := ts1;  use_up1 := false;  use_lp1 := true;
    ELSE
      IF NOT ('EXTENDED_TUPLE_SPACE' IN types1) THEN
        -- Unreachable when this function was written.
        RETURN (?);
      END_IF;
      et1 := ts1;  use_up1 := false;  use_lp1 := false;
    END_IF;
  END_IF;
  -- Identify type of second operand
  IF 'UNIFORM_PRODUCT_SPACE' IN types2 THEN
    up2 := ts2;  use_up2 := true;  use_lp2 := false;
  ELSE
    IF 'LISTED_PRODUCT_SPACE' IN types2 THEN
      lp2 := ts2;  use_up2 := false;  use_lp2 := true;
    ELSE
      IF NOT ('EXTENDED_TUPLE_SPACE' IN types2) THEN
        -- Unreachable when this function was written.
        RETURN (?);
      END_IF;
      et2 := ts2;  use_up2 := false;  use_lp2 := false;
    END_IF;
  END_IF;
  -- Construction for each combination of cases
  IF use_up1 THEN
    IF use_up2 THEN
      IF up1.base = up2.base THEN
        tspace := make_uniform_product_space(up1.base, up1.exponent + up2.exponent);
      ELSE
        factors := [up1.base : up1.exponent, up2.base : up2.exponent];
        tspace := make_listed_product_space(factors);
      END_IF;
    ELSE
      IF use_lp2 THEN
        -- Avoid compiler confusion by breaking into two lines.
        factors := [up1.base : up1.exponent];
        factors := factors + lp2.factors;
        tspace := make_listed_product_space(factors);
      ELSE
        tspace := assoc_product_space(up1, et2.base);
        tspace := make_extended_tuple_space(tspace, et2.extender);
      END_IF;
    END_IF;
  ELSE
    IF use_lp1 THEN
      IF use_up2 THEN
        -- Avoid compiler confusion by breaking into two lines.
        factors := [up2.base : up2.exponent];
        factors := lp1.factors + factors;
        tspace := make_listed_product_space(factors);
      ELSE
        IF use_lp2 THEN
          tspace := make_listed_product_space(lp1.factors + lp2.factors);
        ELSE
          tspace := assoc_product_space(lp1, et2.base);
          tspace := make_extended_tuple_space(tspace, et2.extender);
        END_IF;
      END_IF;
    ELSE
      IF use_up2 THEN
        IF et1.extender = up2.base THEN
          tspace := assoc_product_space(et1.base, up2);
          tspace := make_extended_tuple_space(tspace, et1.extender);
        ELSE
          -- No subtype is available to represent this cartesian product.
          RETURN (?);
        END_IF;
      ELSE
        IF use_lp2 THEN
          factors := lp2.factors;
          REPEAT i := 1 TO SIZEOF (factors);
            IF et1.extender <> factors[i] THEN
              -- No subtype available to represent this cartesian product.
              RETURN (?);
            END_IF;
          END_REPEAT;
          tspace := assoc_product_space(et1.base, lp2);
          tspace := make_extended_tuple_space(tspace, et1.extender);
        ELSE
          IF et1.extender = et2.extender THEN
            -- Next line may assign indeterminate (?) to tspace.
            tspace := assoc_product_space(et1, et2.base);
          ELSE
            -- No subtype available to represent this cartesian product.
            RETURN (?);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (tspace);
END_FUNCTION;

FUNCTION associated_surface
	(arg: pcurve_or_surface) : surface;
   LOCAL
     surf : surface;
   END_LOCAL;
   
   IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN TYPEOF(arg) THEN
     surf := arg\pcurve.basis_surface;
   ELSE
     surf := arg;
   END_IF;
   RETURN(surf);
END_FUNCTION;

FUNCTION atan2
	(y: REAL; x: REAL) : REAL;
  LOCAL
    r : REAL;
  END_LOCAL;
  IF (y = 0.0) AND (x = 0.0) THEN  RETURN (?);  END_IF;
  r := atan(y,x);
  IF x < 0.0 THEN
    IF y < 0.0 THEN  r := r - PI;
    ELSE             r := r + PI;  END_IF;
  END_IF;
  RETURN (r);
END_FUNCTION;

FUNCTION bag_to_set
	(the_bag: BAG [0:?] OF GENERIC: intype) : SET [0:?] OF GENERIC: intype;
    LOCAL
      the_set : SET OF GENERIC:intype := [];
    END_LOCAL;

    IF SIZEOF(the_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag);
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN (the_set);
END_FUNCTION;

FUNCTION base_axis
	(dim: INTEGER; axis1: direction; axis2: direction; axis3: direction) : LIST [2:3] OF direction;
  LOCAL
    u      : LIST [2:3] OF direction;
    factor : REAL;
    d1, d2 : direction;
  END_LOCAL;
  
  IF (dim = 3) THEN
    d1 := NVL(normalise(axis3),  dummy_gri || direction([0.0,0.0,1.0]));
    d2 := first_proj_axis(d1,axis1);
    u := [d2, second_proj_axis(d1,d2,axis2), d1];
  ELSE
     IF EXISTS(axis1) THEN
      d1 := normalise(axis1);
      u := [d1, orthogonal_complement(d1)];
      IF EXISTS(axis2) THEN
        factor := dot_product(axis2,u[2]);
        IF (factor < 0.0) THEN
          u[2].direction_ratios[1] := -u[2].direction_ratios[1];
          u[2].direction_ratios[2] := -u[2].direction_ratios[2];
        END_IF;
      END_IF;
    ELSE
      IF EXISTS(axis2) THEN
        d1 := normalise(axis2);
        u := [orthogonal_complement(d1), d1]; 
        u[1].direction_ratios[1] := -u[1].direction_ratios[1];
        u[1].direction_ratios[2] := -u[1].direction_ratios[2];
      ELSE
        u := [dummy_gri || direction([1.0, 0.0]), dummy_gri ||
                                                direction([0.0, 1.0])];
      END_IF;
    END_IF;
  END_IF;
  RETURN(u);
END_FUNCTION;

FUNCTION bool
	(lgcl: LOGICAL) : BOOLEAN;
IF NOT EXISTS (lgcl) THEN  RETURN (FALSE);  END_IF;
  IF lgcl <> TRUE      THEN  RETURN (FALSE);  END_IF;
  RETURN (TRUE);
END_FUNCTION;

FUNCTION boolean_choose
	(b: BOOLEAN; choice1: GENERIC: item; choice2: GENERIC: item) : GENERIC: item;
IF b THEN
       RETURN (choice1);
     ELSE
       RETURN (choice2);
     END_IF;
END_FUNCTION;

FUNCTION build_2axes
	(ref_direction: direction) : LIST [2:2] OF direction;
   LOCAL
     d : direction := NVL(normalise(ref_direction),
                          dummy_gri || direction([1.0,0.0]));
   END_LOCAL;

   RETURN([d, orthogonal_complement(d)]);
END_FUNCTION;

FUNCTION build_axes
	(axis: direction; ref_direction: direction) : LIST [3:3] OF direction;
     LOCAL
       d1, d2 : direction;
     END_LOCAL;
    d1 := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
    d2 := first_proj_axis(d1, ref_direction);
    RETURN([d2, normalise(cross_product(d1,d2))\vector.orientation, d1]);
END_FUNCTION;

FUNCTION build_direction_node
	(node_1: node_representation; node_2: node_representation) : LIST [2:3] OF REAL;
LOCAL
  nodal_direction_ratios    : LIST [2:3] OF REAL;
  u                         : direction;
  i                         : INTEGER;
  ndim                      : INTEGER;
  rep_items                 : SET [1:?] of representation_item;
  node_1_point              : cartesian_point;
  node_2_point              : cartesian_point;
END_LOCAL;

rep_items := node_1.items;
REPEAT i := 1 TO SIZEOF(rep_items);
  IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT' IN TYPEOF(rep_items[i])) THEN
    node_1_point := rep_items[i];
    ESCAPE;
  END_IF; 
END_REPEAT;

rep_items := node_2.items;
REPEAT i := 1 TO SIZEOF(rep_items);
  IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT' IN TYPEOF(rep_items[i])) THEN
    node_2_point := rep_items[i];
    ESCAPE;
  END_IF; 
END_REPEAT;

ndim := HIINDEX(node_2_point.coordinates);
REPEAT i := 1 TO ndim;
  u.direction_ratios[i] := node_2_point.coordinates[i] - 
                           node_1_point.coordinates[i];
END_REPEAT;

u := normalise (u);
REPEAT i := 1 TO ndim;
  nodal_direction_ratios[i] := u.direction_ratios[i];
END_REPEAT;

RETURN (nodal_direction_ratios);
END_FUNCTION;

FUNCTION categories_of_product
	(obj: product) : SET [0:?] OF STRING;
  LOCAL
    category_assignments: BAG OF product_category;
    categories: SET OF STRING:=[];
  END_LOCAL;
    category_assignments := USEDIN(obj, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS');
    REPEAT i := LOINDEX(category_assignments) TO HIINDEX(category_assignments) BY 1;
      categories := categories + category_assignments[i].name;
    END_REPEAT;
    RETURN(categories);
END_FUNCTION;

FUNCTION cc_design_person_and_organization_correlation
	(e: cc_design_person_and_organization_assignment) : BOOLEAN;
    LOCAL
      po_role : STRING;
    END_LOCAL;
      po_role := e\person_and_organization_assignment.role.name;
    CASE po_role OF
      'request_recipient'      : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                 'CHANGE_REQUEST',
                                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                 'START_REQUEST'] *
                                 TYPEOF (x)) = 1))
                                 THEN RETURN(FALSE);
                               END_IF;
      'initiator'              : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                 'CHANGE_REQUEST',
                                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                 'START_REQUEST',
                                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                 'START_WORK',
                                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                 'CHANGE'] *
                                 TYPEOF (x)) = 1))
                                 THEN RETURN(FALSE);
                               END_IF;
      'creator'                : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                 'PRODUCT_DEFINITION_FORMATION',
                                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                 'PRODUCT_DEFINITION'] *
                                 TYPEOF (x)) = 1))
                                 THEN RETURN (FALSE);
                               END_IF;
      'part_supplier'          : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                 'PRODUCT_DEFINITION_FORMATION'
                                 IN TYPEOF (x)))
                                 THEN RETURN(FALSE);
                               END_IF;
      'design_supplier'        : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                 'PRODUCT_DEFINITION_FORMATION'
                                 IN TYPEOF (x)))
                                 THEN RETURN(FALSE);
                               END_IF;
      'design_owner'           : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT'
                                 IN TYPEOF (x)))
                                 THEN RETURN(FALSE);
                               END_IF;
      'configuration_manager'  : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                 'CONFIGURATION_ITEM'
                                 IN TYPEOF (x)))
                                 THEN RETURN(FALSE);
                               END_IF;
      'contractor'             : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONTRACT'
                                 IN TYPEOF (x)))
                                 THEN RETURN(FALSE);
                               END_IF;
      'classification_officer' : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                 'SECURITY_CLASSIFICATION'
                                 IN TYPEOF (x))) THEN
                                 RETURN(FALSE);
                               END_IF;
    OTHERWISE : RETURN(TRUE);
  END_CASE;
  RETURN (TRUE);
END_FUNCTION;

FUNCTION cell_counts
	(arg: vertex_defined_cell) : ARRAY [1:3] OF INTEGER;
LOCAL
  om1    : INTEGER := 0;      -- (order - 1)
  om1sq  : INTEGER := om1**2; -- (order - 1) squared
  vts    : INTEGER;           -- number of bounding vertices
  eds    : INTEGER;           -- number of edges
  qf     : INTEGER := 0;      -- number of quadrilateral faces
  tf     : INTEGER := 0;      -- number of triangular faces
  result : ARRAY [1:3] OF INTEGER := [0,0,0];
END_LOCAL;
  CASE arg.order OF
    linear    : om1 := 0;
    quadratic : om1 := 1;
    cubic     : om1 := 2;
    OTHERWISE : RETURN(result);
  END_CASE;
  om1sq := om1**2;
  CASE arg.shape OF
    arg.shape.single : 
        BEGIN
          vts := 1; eds := 0; qf := 0; tf := 0;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 0, 0
          result[3] := 0;                         -- 0, 0, 0
        END;
    arg.shape.line :
        BEGIN
          vts := 2; eds := 1; qf := 0; tf := 0;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 1, 2
          result[3] := 0;                         -- 0, 0, 0
        END;
    arg.shape.quadrilateral : 
        BEGIN
          vts := 4; eds := 4; qf := 1; tf := 0;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 4, 8
          result[3] := om1sq*qf;                  -- 0, 1, 4
        END;
    arg.shape.triangle : 
        BEGIN
          vts := 3; eds := 3; qf := 0; tf := 1;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 3, 6
          result[3] := (om1-1)*tf;                --    0, 1
          CASE arg.order OF
            linear : result[3] := 0;              -- 0
          END_CASE;
        END;
    arg.shape.polygon :
        BEGIN
          vts := arg.vn_count; eds := arg.vn_count; 
          result[1] := vts;
          result[2] := 0;
          result[3] := 0;
        END;
    arg.shape.hexahedron :
        BEGIN
          vts := 8; eds := 12; qf := 6; tf := 0;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 12, 24
          result[3] := om1sq*(qf+om1);            -- 0, 7, 32
        END;
    arg.shape.wedge :
        BEGIN
          vts := 6; eds := 9; qf := 3; tf := 2;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 9,  18
          result[3] := om1sq*qf + om1*tf;         -- 0, 3, 16
        END;
    arg.shape.tetrahedron : 
        BEGIN
          vts := 4; eds := 6; qf := 0; tf := 4;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 6, 12
          result[3] := (om1-1)*tf;                --    0, 4
          CASE arg.order OF
            linear : result[3] := 0;              -- 0
          END_CASE;
        END;
    arg.shape.pyramid : 
        BEGIN
          vts := 5; eds := 8; qf := 1; tf := 4;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 8, 16
          result[3] := om1sq*qf + (om1-1)*tf;     --    1, 9
          CASE arg.order OF
            linear : result[3] := 0;              -- 0
          END_CASE;
        END;
  END_CASE;
RETURN(result);
END_FUNCTION;

FUNCTION check_continuous_edges
	(edges: LIST [0:?] OF  UNIQUE edge_curve) : BOOLEAN;
  LOCAL
    i           : INTEGER;
    next_vertex : vertex;
  END_LOCAL;

  -- first check whether there is only one edge in the list: in this
  -- case there is no connectivity to be checked.

  IF (SIZEOF(edges) = 1)
  THEN RETURN(TRUE);
  END_IF;

  -- otherwise, establish the matching vertices of edges 1 and 2 in 
  -- the list, and determine the vertex of edge 2 to which edge 3, 
  -- must be connected, if there are more than two edges in the list.

  IF ((edges[2].edge_start :=: edges[1].edge_end)
    XOR (edges[2].edge_start :=: edges[1].edge_start))
  THEN next_vertex := edges[2].edge_end;
  ELSE 
    IF ((edges[2].edge_end :=: edges[1].edge_end)
      XOR (edges[2].edge_end :=: edges[1].edge_start))
    THEN next_vertex := edges[2].edge_start;
    ELSE RETURN(FALSE); -- no match between any vertices of edges 1 and 2 
    END_IF;
  END_IF;

  -- exit if there are only two edges and they are connected

  IF (SIZEOF(edges) = 2)
  THEN RETURN(TRUE);
  END_IF;

  -- otherwise, check that any remaining edges are connected in list order.

  REPEAT i := 3 TO HIINDEX(edges);
    IF (edges[i].edge_start :=: next_vertex)
    THEN next_vertex := edges[i].edge_end;
    ELSE
      IF (edges[i].edge_end :=: next_vertex)
      THEN next_vertex := edges[i].edge_start;
      ELSE RETURN(FALSE); -- no match is found.
      END_IF;
    END_IF; 
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION check_sparse_index_domain
	(idxdom: tuple_space; base: zero_or_one; shape: LIST [1:?] OF positive_integer; order: ordering_type) : BOOLEAN;
  LOCAL
    mthspc : maths_space;
    interval : finite_integer_interval;
    i : INTEGER;
  END_LOCAL;
  mthspc := factor1(idxdom);
  -- A consequence of WR1 of basic_sparse_matrix is that here we need only
  -- consider the case that mthspc is a finite integer interval and is the only
  -- factor space of idxdom.
  interval := mthspc;
  IF order = by_rows THEN  i := 1;  ELSE  i := 2;  END_IF;
  RETURN (bool((interval.min <= base) AND (interval.max >= base + shape[i])));
END_FUNCTION;

FUNCTION check_sparse_index_to_loc
	(index_range: tuple_space; loc_domain: tuple_space) : BOOLEAN;
  LOCAL
    temp : maths_space;
    idx_rng_itvl, loc_dmn_itvl : finite_integer_interval;
  END_LOCAL;
  temp := factor1 (index_range);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF (temp) THEN
    temp := factor1 (temp);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
    RETURN (FALSE);
  END_IF;
  idx_rng_itvl := temp;
  temp := factor1 (loc_domain);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF (temp) THEN
    temp := factor1 (temp);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
    RETURN (FALSE);
  END_IF;
  loc_dmn_itvl := temp;
  RETURN (bool((loc_dmn_itvl.min <= idx_rng_itvl.min) AND
    (idx_rng_itvl.max <= loc_dmn_itvl.max+1)));
END_FUNCTION;

FUNCTION check_sparse_loc_range
	(locrng: tuple_space; base: zero_or_one; shape: LIST [1:?] OF positive_integer; order: ordering_type) : BOOLEAN;
  LOCAL
    mthspc : maths_space;
    interval : finite_integer_interval;
    i : INTEGER;
  END_LOCAL;
  IF space_dimension(locrng) <> 1 THEN  RETURN (FALSE);  END_IF;
  mthspc := factor1(locrng);
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (mthspc)) THEN
    RETURN (FALSE);
  END_IF;
  interval := mthspc;
  IF order = by_rows THEN  i := 2;  ELSE  i := 1;  END_IF;
  RETURN (bool((interval.min >= base) AND (interval.max <= base + shape[i] - 1)));
END_FUNCTION;

FUNCTION check_text_alignment
	(ct: composite_text) : BOOLEAN;
  LOCAL
    a : SET OF text_alignment := [];
  END_LOCAL;

  -- create a set of all the alignments
  REPEAT i := 1 TO HIINDEX (ct.collected_text);
    a := a + [ct.collected_text[i]\text_literal.alignment];
  END_REPEAT;

  -- if there is more than one element in the set
  -- then not all alignments were the same
  RETURN (SIZEOF(a) = 1);
END_FUNCTION;

FUNCTION check_text_font
	(ct: composite_text) : BOOLEAN;
  LOCAL
    f : SET OF font_select := [];
  END_LOCAL;

  -- build a set of all the fonts
  REPEAT i := 1 TO HIINDEX (ct.collected_text);
    f := f + [ct.collected_text[i]\text_literal.font];
  END_REPEAT;

  -- if there is more than one element in the set
  -- then not all fonts were the same
  RETURN (SIZEOF(f) <= 1);
END_FUNCTION;

FUNCTION class_assignment_is_valid
	(aia: applied_classification_assignment) : BOOLEAN;
LOCAL
  item: classification_item;
  role: classification_role;
END_LOCAL;

role:= aia\classification_assignment.role;
IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +'CLASS_SYSTEM' IN TYPEOF(aia\classification_assignment.assigned_class)) THEN
  IF(role\classification_role.name <> 'class system membership') THEN
    RETURN(FALSE);
  END_IF;
  REPEAT i:=LOINDEX(aia\applied_classification_assignment.items) TO HIINDEX(aia\applied_classification_assignment.items);
    item:= aia\applied_classification_assignment.items[i];

    IF (SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CLASS_SYSTEM_ITEM'] * TYPEOF(item))=0) THEN
-- item invalid if item does not belong to the types that may have a class_system
	RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_IF;

IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +'CHARACTERIZED_CLASS' IN TYPEOF(aia\classification_assignment.assigned_class)) THEN
  IF	NOT(role\classification_role.name IN ['definitional','non-definitional','']) THEN
    RETURN(FALSE); 
  END_IF;


  REPEAT i:=LOINDEX(aia\applied_classification_assignment.items) TO HIINDEX(aia\applied_classification_assignment.items);
    item:= aia\applied_classification_assignment.items[i];

    IF (SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CLASSIFIED_ITEM'] * TYPEOF(item))=0) THEN
-- item invalid if item does not belong to the types that may have a characterized_class
	RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_IF;

  IF
   (role\classification_role.name = 'definitional')
   THEN
     IF NOT
      (SIZEOF(QUERY(it <* aia\applied_classification_assignment.items | NOT
             (SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION_FORMATION', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION'] * TYPEOF(it)) = 1)
      )) = 0 )
      THEN
      RETURN(FALSE); 
     END_IF;
  END_IF;

RETURN(TRUE);
END_FUNCTION;

FUNCTION closed_shell_reversed
	(a_shell: closed_shell) : oriented_closed_shell;
  LOCAL
    the_reverse : oriented_closed_shell;
  END_LOCAL;
   IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_CLOSED_SHELL' IN TYPEOF (a_shell) ) THEN
      the_reverse := dummy_tri ||
                    connected_face_set (
                       a_shell\connected_face_set.cfs_faces) ||
                    closed_shell () || oriented_closed_shell(
                     a_shell\oriented_closed_shell.closed_shell_element,
                       NOT(a_shell\oriented_closed_shell.orientation));
   ELSE
      the_reverse := dummy_tri ||
               connected_face_set (
                 a_shell\connected_face_set.cfs_faces) ||
               closed_shell () || oriented_closed_shell (a_shell, FALSE);
   END_IF;
   RETURN (the_reverse);
END_FUNCTION;

FUNCTION compare_basis_and_coef
	(basis: LIST [1:?] OF b_spline_basis; coef: maths_function) : BOOLEAN;
  LOCAL
    shape : LIST OF positive_integer;
  END_LOCAL;
  IF NOT EXISTS (basis) OR NOT EXISTS (coef) THEN  RETURN (FALSE);  END_IF;
  shape := shape_of_array(coef);
  IF NOT EXISTS (shape) THEN  RETURN (FALSE);  END_IF;
  IF SIZEOF (shape) < SIZEOF (basis) THEN  RETURN (FALSE);  END_IF;
  REPEAT i := 1 TO SIZEOF (basis);
    IF (basis[i].num_basis = shape[i]) <> TRUE THEN  RETURN (FALSE);  END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;

FUNCTION compatible_complex_number_regions
	(sp1: maths_space; sp2: maths_space) : BOOLEAN;
  LOCAL
    typenames : SET OF string := stripped_typeof (sp1);
    crgn1, crgn2 : cartesian_complex_number_region;
    prgn1, prgn2, prgn1c2, prgn2c1 : polar_complex_number_region;
    sp1_is_crgn, sp2_is_crgn : BOOLEAN;
  END_LOCAL;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN typenames THEN
    sp1_is_crgn := TRUE;
    crgn1 := sp1;
  ELSE
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN typenames THEN
      sp1_is_crgn := FALSE;
      prgn1 := sp1;
    ELSE
      -- Improper usage: Default response is to assume compatibility.
      RETURN (TRUE);
    END_IF;
  END_IF;
  typenames := stripped_typeof (sp2);
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN typenames THEN
    sp2_is_crgn := TRUE;
    crgn2 := sp2;
  ELSE
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN typenames THEN
      sp2_is_crgn := FALSE;
      prgn2 := sp2;
    ELSE
      -- Improper usage: Default response is to assume compatibility.
      RETURN (TRUE);
    END_IF;
  END_IF;
  IF sp1_is_crgn AND sp2_is_crgn THEN
    -- two cartesian regions
    RETURN (compatible_intervals(crgn1.real_constraint, crgn2.real_constraint)
      AND compatible_intervals(crgn1.imag_constraint, crgn2.imag_constraint));
  END_IF;
  IF NOT sp1_is_crgn AND NOT sp2_is_crgn AND
    (prgn1.centre.real_part = prgn2.centre.real_part) AND
    (prgn1.centre.imag_part = prgn2.centre.imag_part) THEN
    -- two polar regions with common centre
    IF NOT compatible_intervals(prgn1.distance_constraint,
      prgn2.distance_constraint) THEN
      RETURN (FALSE);
    END_IF;
    IF compatible_intervals(prgn1.direction_constraint,
      prgn2.direction_constraint) THEN
      RETURN (TRUE);
    END_IF;
    -- Deal with direction ambiguity by 2 pi.
    IF (prgn1.direction_constraint.max > PI) AND (prgn2.direction_constraint.max < PI)
      THEN
      RETURN (compatible_intervals(prgn2.direction_constraint,
        make_finite_real_interval(-PI,open,prgn1.direction_constraint.max-2.0*PI,
        prgn1.direction_constraint.max_closure)));
    END_IF;
    IF (prgn2.direction_constraint.max > PI) AND (prgn1.direction_constraint.max < PI)
      THEN
      RETURN (compatible_intervals(prgn1.direction_constraint,
        make_finite_real_interval(-PI,open,prgn2.direction_constraint.max-2.0*PI,
        prgn2.direction_constraint.max_closure)));
    END_IF;
    RETURN (FALSE);
  END_IF;
  -- Make do with imperfect tests for remaining cases.
  IF sp1_is_crgn AND NOT sp2_is_crgn THEN
    crgn2 := enclose_pregion_in_cregion(prgn2);
    prgn1 := enclose_cregion_in_pregion(crgn1,prgn2.centre);
    RETURN (compatible_complex_number_regions(crgn1,crgn2)
      AND compatible_complex_number_regions(prgn1,prgn2));
  END_IF;
  IF NOT sp1_is_crgn AND sp2_is_crgn THEN
    crgn1 := enclose_pregion_in_cregion(prgn1);
    prgn2 := enclose_cregion_in_pregion(crgn2,prgn1.centre);
    RETURN (compatible_complex_number_regions(crgn1,crgn2)
      AND compatible_complex_number_regions(prgn1,prgn2));
  END_IF;
  -- Two polar regions with different centres
  prgn1c2 := enclose_pregion_in_pregion(prgn1,prgn2.centre);
  prgn2c1 := enclose_pregion_in_pregion(prgn2,prgn1.centre);
  RETURN (compatible_complex_number_regions(prgn1,prgn2c1)
    AND compatible_complex_number_regions(prgn1c2,prgn2));
END_FUNCTION;

FUNCTION compatible_es_values
	(esval1: elementary_space_enumerators; esval2: elementary_space_enumerators) : BOOLEAN;
  LOCAL
    esval1_is_numeric, esval2_is_numeric : LOGICAL;
  END_LOCAL;
  IF (esval1 = esval2) OR (esval1 = es_generics) OR (esval2 = es_generics) THEN
    RETURN (TRUE);
  END_IF;
  esval1_is_numeric := (esval1 >= es_numbers) AND (esval1 <= es_integers);
  esval2_is_numeric := (esval2 >= es_numbers) AND (esval2 <= es_integers);
  IF (esval1_is_numeric AND (esval2 = es_numbers)) OR
    (esval2_is_numeric AND (esval1 = es_numbers)) THEN
    RETURN (TRUE);
  END_IF;
  IF esval1_is_numeric XOR esval2_is_numeric THEN
    RETURN (FALSE);
  END_IF;
  IF ((esval1 = es_logicals) AND (esval2 = es_booleans)) OR
    ((esval1 = es_booleans) AND (esval2 = es_logicals)) THEN
    RETURN (TRUE);
  END_IF;
  -- All other cases are incompatible
  RETURN (FALSE);
END_FUNCTION;

FUNCTION compatible_intervals
	(sp1: maths_space; sp2: maths_space) : BOOLEAN;
  LOCAL
    amin, amax : REAL;
  END_LOCAL;
  IF min_exists(sp1) AND max_exists(sp2) THEN
    amin := real_min(sp1);  amax := real_max(sp2);
    IF amin > amax THEN  RETURN (FALSE);  END_IF;
    IF amin = amax THEN
      RETURN (min_included(sp1) AND max_included(sp2));
    END_IF;
  END_IF;
  IF min_exists(sp2) AND max_exists(sp1) THEN
    amin := real_min(sp2);  amax := real_max(sp1);
    IF amin > amax THEN  RETURN (FALSE);  END_IF;
    IF amin = amax THEN
      RETURN (min_included(sp2) AND max_included(sp1));
    END_IF;
  END_IF;
  RETURN (TRUE);
END_FUNCTION;

FUNCTION compatible_spaces
	(sp1: maths_space; sp2: maths_space) : BOOLEAN;
  LOCAL
    types1 : SET OF STRING := stripped_typeof (sp1);
    types2 : SET OF STRING := stripped_typeof (sp2);
    lgcl : LOGICAL := UNKNOWN;
    m, n : INTEGER;
    s1, s2 : maths_space;
  END_LOCAL;
  IF 'FINITE_SPACE' IN types1 THEN
    REPEAT i := 1 TO SIZEOF (sp1\finite_space.members);
      lgcl := member_of(sp1\finite_space.members[i], sp2);
      IF lgcl <> FALSE THEN
        RETURN (TRUE);
      END_IF;
    END_REPEAT;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_SPACE' IN types2 THEN
    REPEAT i := 1 TO SIZEOF (sp2\finite_space.members);
      lgcl := member_of(sp2\finite_space.members[i], sp1);
      IF lgcl <> FALSE THEN
        RETURN (TRUE);
      END_IF;
    END_REPEAT;
    RETURN (FALSE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types1 THEN
    IF sp1\elementary_space.space_id = es_generics THEN
      RETURN (TRUE);
    END_IF;
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id,
        sp2\elementary_space.space_id));
    END_IF;
    IF ('FINITE_INTEGER_INTERVAL' IN types2) OR
      ('INTEGER_INTERVAL_FROM_MIN' IN types2) OR
      ('INTEGER_INTERVAL_TO_MAX' IN types2) THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id, es_integers));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types2) OR
      ('REAL_INTERVAL_FROM_MIN' IN types2) OR
      ('REAL_INTERVAL_TO_MAX' IN types2) THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id, es_reals));
    END_IF;
    IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types2) OR
      ('POLAR_COMPLEX_NUMBER_REGION' IN types2) THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id, es_complex_numbers));
    END_IF;
    IF 'TUPLE_SPACE' IN types2 THEN
      RETURN (FALSE);
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      RETURN (bool(sp1\elementary_space.space_id = es_maths_functions));
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types2 THEN
    IF sp2\elementary_space.space_id = es_generics THEN
      RETURN (TRUE);
    END_IF;
    IF ('FINITE_INTEGER_INTERVAL' IN types1) OR
      ('INTEGER_INTERVAL_FROM_MIN' IN types1) OR
      ('INTEGER_INTERVAL_TO_MAX' IN types1) THEN
      RETURN (compatible_es_values(sp2\elementary_space.space_id, es_integers));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types1) OR
      ('REAL_INTERVAL_FROM_MIN' IN types1) OR
      ('REAL_INTERVAL_TO_MAX' IN types1) THEN
      RETURN (compatible_es_values(sp2\elementary_space.space_id, es_reals));
    END_IF;
    IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types1) OR
      ('POLAR_COMPLEX_NUMBER_REGION' IN types1) THEN
      RETURN (compatible_es_values(sp2\elementary_space.space_id, es_complex_numbers));
    END_IF;
    IF 'TUPLE_SPACE' IN types1 THEN
      RETURN (FALSE);
    END_IF;
    IF 'FUNCTION_SPACE' IN types1 THEN
      RETURN (bool(sp2\elementary_space.space_id = es_maths_functions));
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF subspace_of_es(sp1,es_integers) THEN  -- Note that sp1 finite already handled.
    IF subspace_of_es(sp2,es_integers) THEN  -- Note that sp2 finite already handled.
      RETURN (compatible_intervals(sp1,sp2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp2,es_integers) THEN
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp1,es_reals) THEN  -- Note that sp1 finite already handled.
    IF subspace_of_es(sp2,es_reals) THEN  -- Note that sp2 finite already handled.
      RETURN (compatible_intervals(sp1,sp2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp2,es_reals) THEN
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp1,es_complex_numbers) THEN  -- Note sp1 finite already handled.
    IF subspace_of_es(sp2,es_complex_numbers) THEN  -- Note sp2 finite already handled.
      RETURN (compatible_complex_number_regions(sp1,sp2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp2,es_complex_numbers) THEN
    RETURN (FALSE);
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN types1 THEN
    IF 'UNIFORM_PRODUCT_SPACE' IN types2 THEN
      IF sp1\uniform_product_space.exponent <> sp2\uniform_product_space.exponent THEN
        RETURN (FALSE);
      END_IF;
      RETURN (compatible_spaces(sp1\uniform_product_space.base,
        sp2\uniform_product_space.base));
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN types2 THEN
      n := SIZEOF (sp2\listed_product_space.factors);
      IF sp1\uniform_product_space.exponent <> n THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp1\uniform_product_space.base,
          sp2\listed_product_space.factors[i]) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      m := sp1\uniform_product_space.exponent;
      n := space_dimension(sp2\extended_tuple_space.base);
      IF m < n THEN
        RETURN (FALSE);
      END_IF;
      IF m = n THEN
        RETURN (compatible_spaces(sp1, sp2\extended_tuple_space.base));
      END_IF;
      RETURN (compatible_spaces(sp1, assoc_product_space(
        sp2\extended_tuple_space.base, make_uniform_product_space(
        sp2\extended_tuple_space.extender, m - n))));
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      RETURN (FALSE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN types1 THEN
    n := SIZEOF (sp1\listed_product_space.factors);
    IF 'UNIFORM_PRODUCT_SPACE' IN types2 THEN
      IF n <> sp2\uniform_product_space.exponent THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp2\uniform_product_space.base,
          sp1\listed_product_space.factors[i]) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN types2 THEN
      IF n <> SIZEOF (sp2\listed_product_space.factors) THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp1\listed_product_space.factors[i],
          sp2\listed_product_space.factors[i]) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      m := space_dimension(sp2\extended_tuple_space.base);
      IF n < m THEN
        RETURN (FALSE);
      END_IF;
      IF n = m THEN
        RETURN (compatible_spaces(sp1, sp2\extended_tuple_space.base));
      END_IF;
      RETURN (compatible_spaces(sp1, assoc_product_space(
        sp2\extended_tuple_space.base, make_uniform_product_space(
        sp2\extended_tuple_space.extender, n - m))));
    END_IF;
    IF (schema_prefix + 'FUNCTION_SPACE') IN types2 THEN
      RETURN (FALSE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types1 THEN
    IF ('UNIFORM_PRODUCT_SPACE' IN types2) OR
      ('LISTED_PRODUCT_SPACE' IN types2) THEN
      RETURN (compatible_spaces(sp2, sp1));
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      IF NOT compatible_spaces(sp1\extended_tuple_space.extender,
        sp2\extended_tuple_space.extender) THEN
        RETURN (FALSE);
      END_IF;
      n := space_dimension(sp1\extended_tuple_space.base);
      m := space_dimension(sp2\extended_tuple_space.base);
      IF n < m THEN
        RETURN (compatible_spaces(assoc_product_space(sp1\extended_tuple_space.base,
          make_uniform_product_space(sp1\extended_tuple_space.extender, m - n)),
          sp2\extended_tuple_space.base));
      END_IF;
      IF n = m THEN
        RETURN (compatible_spaces(sp1\extended_tuple_space.base,
          sp2\extended_tuple_space.base));
      END_IF;
      IF n > m THEN
        RETURN (compatible_spaces(sp1\extended_tuple_space.base,
          assoc_product_space(sp2\extended_tuple_space.base,
          make_uniform_product_space(sp2\extended_tuple_space.extender, n - m))));
      END_IF;
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      RETURN (FALSE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'FUNCTION_SPACE' IN types1 THEN
    IF 'FUNCTION_SPACE' IN types2 THEN
      s1 := sp1\function_space.domain_argument;
      s2 := sp2\function_space.domain_argument;
      CASE sp1\function_space.domain_constraint OF
      sc_equal : BEGIN
        CASE sp2\function_space.domain_constraint OF
        sc_equal : lgcl := subspace_of(s1, s2) AND subspace_of(s2, s1);
        sc_subspace : lgcl := subspace_of(s1, s2);
        sc_member : lgcl := member_of(s1, s2);
        END_CASE;
        END;
      sc_subspace :BEGIN
        CASE sp2\function_space.domain_constraint OF
        sc_equal : lgcl := subspace_of(s2, s1);
        sc_subspace : lgcl := compatible_spaces(s1, s2);
        sc_member : lgcl := UNKNOWN;
        END_CASE;
        END;
      sc_member :BEGIN
        CASE sp2\function_space.domain_constraint OF
        sc_equal : lgcl := member_of(s2, s1);
        sc_subspace : lgcl := UNKNOWN;
        sc_member : lgcl := compatible_spaces(s1, s2);
        END_CASE;
        END;
      END_CASE;
      IF lgcl = FALSE THEN
        RETURN (FALSE);
      END_IF;
      s1 := sp1\function_space.range_argument;
      s2 := sp2\function_space.range_argument;
      CASE sp1\function_space.range_constraint OF
      sc_equal : BEGIN
        CASE sp2\function_space.range_constraint OF
        sc_equal : lgcl := subspace_of(s1, s2) AND subspace_of(s2, s1);
        sc_subspace : lgcl := subspace_of(s1, s2);
        sc_member : lgcl := member_of(s1, s2);
        END_CASE;
        END;
      sc_subspace :BEGIN
        CASE sp2\function_space.range_constraint OF
        sc_equal : lgcl := subspace_of(s2, s1);
        sc_subspace : lgcl := compatible_spaces(s1, s2);
        sc_member : lgcl := UNKNOWN;
        END_CASE;
        END;
      sc_member :BEGIN
        CASE sp2\function_space.range_constraint OF
        sc_equal : lgcl := member_of(s2, s1);
        sc_subspace : lgcl := UNKNOWN;
        sc_member : lgcl := compatible_spaces(s1, s2);
        END_CASE;
        END;
      END_CASE;
      IF lgcl = FALSE THEN
        RETURN (FALSE);
      END_IF;
      RETURN (TRUE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  -- Should be unreachable.
  RETURN (TRUE);
END_FUNCTION;

FUNCTION composable_sequence
	(operands: LIST [2:?] OF maths_function) : BOOLEAN;
REPEAT i := 1 TO SIZEOF (operands) - 1;
    IF NOT compatible_spaces (operands[i].range, operands[i+1].domain) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;

FUNCTION compute_total_depth
	(swsrh: solid_with_stepped_round_hole) : positive_length_measure;
LOCAL
i  : positive_integer;
n  : positive_integer := swsrh.segments;
td : positive_length_measure := swsrh.segment_depths[1];
END_LOCAL;

IF n = 1 
THEN RETURN(td);
ELSE
  REPEAT i := 2 TO n;
    td := td + swsrh.segment_depths[i];
  END_REPEAT;
END_IF;
RETURN(td);
END_FUNCTION;

FUNCTION conditional_reverse
	(p: BOOLEAN; an_item: reversible_topology) : reversible_topology;
IF p THEN
     RETURN (an_item);
   ELSE
     RETURN (topology_reversed (an_item));
   END_IF;
END_FUNCTION;

FUNCTION consistent_element_or_group_reference
	(aspect: GENERIC; element: GENERIC) : BOOLEAN;
LOCAL
  srrs                      : STRING;
  i                         : INTEGER;
END_LOCAL;

srrs := 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.';

IF ((srrs + 'ELEMENT_REPRESENTATION') IN TYPEOF(element)) THEN
  RETURN (consistent_element_reference (aspect, element));
END_IF;

IF ((srrs + 'ELEMENT_GROUP') IN TYPEOF(element)) THEN
  REPEAT i := 1 TO HIINDEX (element.elements);
    IF NOT (consistent_element_reference (aspect, element.elements[i])) 
     THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_IF;

RETURN (FALSE);
END_FUNCTION;

FUNCTION consistent_element_reference
	(aspect: GENERIC; element: element_representation) : BOOLEAN;
LOCAL
  srrs                      : STRING;
  feacr                     : STRING;
  aspect_type               : SET [1:?] OF STRING;
  element_type              : SET [1:?] OF STRING;
END_LOCAL;

srrs         := 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.';
feacr        := 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.';
aspect_type  := TYPEOF (aspect);
element_type := TYPEOF (element);

IF ((srrs + 'ELEMENT_REPRESENTATION')
    IN element_type) THEN
  IF ((srrs + 'ELEMENT_VOLUME') IN aspect_type) THEN
    RETURN (TRUE);
  END_IF;
END_IF;

IF ((srrs + 'VOLUME_3D_ELEMENT_REPRESENTATION')
    IN element_type) THEN
  IF (((feacr + 'VOLUME_3D_FACE') IN aspect_type) OR
      ((feacr + 'VOLUME_3D_EDGE') IN aspect_type)) THEN
    RETURN (TRUE);
  END_IF;
END_IF;

IF (((srrs + 'AXISYMMETRIC_VOLUME_2D_ELEMENT_REPRESENTATION')
     IN element_type) OR
    ((srrs + 'PLANE_VOLUME_2D_ELEMENT_REPRESENTATION') 
     IN element_type)) THEN
  IF (((feacr + 'VOLUME_2D_FACE') IN aspect_type) OR
      ((feacr + 'VOLUME_2D_EDGE') IN aspect_type)) THEN
    RETURN (TRUE);
  END_IF;
END_IF;

IF ((srrs + 'SURFACE_3D_ELEMENT_REPRESENTATION')
    IN element_type) THEN
  IF (((feacr + 'SURFACE_3D_FACE') IN aspect_type) OR
      ((feacr + 'SURFACE_3D_EDGE') IN aspect_type)) THEN
    RETURN (TRUE);
  END_IF;
END_IF;

IF (((srrs + 'AXISYMMETRIC_SURFACE_2D_ELEMENT_REPRESENTATION')
    IN element_type) OR
    ((srrs + 'PLANE_SURFACE_2D_ELEMENT_REPRESENTATION')
     IN element_type)) THEN
  IF (((feacr + 'SURFACE_2D_FACE') IN aspect_type) OR
      ((feacr + 'SURFACE_2D_EDGE') IN aspect_type)) THEN
  RETURN (TRUE);
  END_IF;
END_IF;

IF (((srrs + 'CURVE_3D_ELEMENT_REPRESENTATION') 
     IN element_type) OR
    ((srrs + 'AXISYMMETRIC_CURVE_2D_ELEMENT_REPRESENTATION') 
     IN element_type) OR
    ((srrs + 'PLANE_CURVE_2D_ELEMENT_REPRESENTATION') 
     IN element_type)) THEN
  IF ((srrs + 'CURVE_EDGE') IN aspect_type) THEN
    RETURN (TRUE);
  END_IF;
END_IF;

RETURN (FALSE);
END_FUNCTION;

FUNCTION consistent_geometric_reference
	(aspect: GENERIC; item: geometric_representation_item) : BOOLEAN;
LOCAL
  srrs                      : STRING;
  feacr                     : STRING;
  aspect_type               : SET [1:?] OF STRING;
  item_type                 : SET [1:?] OF STRING;
END_LOCAL;

srrs        := 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.';
feacr       := 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.';
aspect_type := TYPEOF (aspect);
item_type   := TYPEOF (item);

IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_MODEL' IN item_type) THEN
  IF ((srrs + 'ELEMENT_VOLUME') IN aspect_type) THEN
    RETURN (TRUE);
  END_IF;
END_IF;

IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE' IN item_type) OR
    ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_SURFACE' IN item_type)) THEN
  IF SIZEOF ([(feacr + 'VOLUME_3D_FACE'),
              (feacr + 'VOLUME_2D_FACE'),
              (feacr + 'SURFACE_3D_FACE'),
              (feacr + 'SURFACE_2D_FACE')] *
               aspect_type ) = 1 THEN
    RETURN (TRUE);
  END_IF;
END_IF;

IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE' IN item_type) OR
    ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_CURVE' IN item_type)) THEN
  IF SIZEOF ([(feacr + 'VOLUME_3D_EDGE'),
              (feacr + 'VOLUME_2D_EDGE'),
              (feacr + 'SURFACE_3D_EDGE'), 
              (feacr + 'SURFACE_2D_EDGE'),
              (srrs  + 'CURVE_EDGE')] *
               aspect_type ) = 1 THEN
    RETURN (TRUE);
  END_IF;
END_IF;

RETURN (FALSE);
END_FUNCTION;

FUNCTION consistent_list_values
	(values: LIST [1:?] OF field_value; variable: GENERIC) : BOOLEAN;
    LOCAL
     vv_type                : STRING;
     fv_type                : SET [1:?] OF STRING;
     i                      : INTEGER;
    END_LOCAL;

    vv_type := variable_value_type (variable);

    REPEAT i := 1 TO HIINDEX (values);

       fv_type := TYPEOF (values[i]);

       IF NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
           'UNSPECIFIED_VALUE') IN fv_type) THEN

          IF NOT (vv_type IN fv_type) THEN
             RETURN (FALSE);
          END_IF;

       END_IF;

    END_REPEAT;

    RETURN (TRUE);
END_FUNCTION;

FUNCTION consistent_set_values
	(values_and_locations: SET [1:?] OF GENERIC; variable: GENERIC) : BOOLEAN;
    LOCAL
     vv_type                : STRING;
     fv_type                : SET [1:?] OF STRING;
     i                      : INTEGER;
    END_LOCAL;

    vv_type := variable_value_type (variable);

    REPEAT i := 1 TO HIINDEX (values_and_locations);

       fv_type := TYPEOF (values_and_locations[i].simple_value);

       IF NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
           'UNSPECIFIED_VALUE') IN fv_type) THEN

          IF NOT (vv_type IN fv_type) THEN
             RETURN (FALSE);
          END_IF;

       END_IF;

    END_REPEAT;

    RETURN (TRUE);
END_FUNCTION;

FUNCTION consistent_topological_reference
	(aspect: GENERIC; item: topological_representation_item) : BOOLEAN;
    LOCAL
      status : BOOLEAN;
      srrs   : STRING;
    END_LOCAL;

    status := FALSE;
    srrs := 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.';

    IF (srrs + 'ELEMENT_VOLUME') IN TYPEOF(aspect) THEN
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CLOSED_SHELL' IN TYPEOF(item) THEN
        status := TRUE;
      END_IF;
    END_IF;

    IF (srrs + 'VOLUME_3D_FACE') IN TYPEOF(aspect) THEN
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE' IN TYPEOF(item) THEN
        status := TRUE;
      END_IF;
    END_IF;

    IF (srrs + 'VOLUME_2D_FACE') IN TYPEOF(aspect) THEN
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE' IN TYPEOF(item) THEN
        status := TRUE;
      END_IF;
    END_IF;

    IF (srrs + 'SURFACE_3D_FACE') IN TYPEOF(aspect) THEN
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE' IN TYPEOF(item) THEN
        status := TRUE;
      END_IF;
    END_IF;

    IF (srrs + 'SURFACE_2D_FACE') IN TYPEOF(aspect) THEN
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE' IN TYPEOF(item) THEN
        status := TRUE;
      END_IF;
    END_IF;

    IF (srrs + 'VOLUME_3D_EDGE') IN TYPEOF(aspect) THEN
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE' IN TYPEOF(item) THEN
        status := TRUE;
      END_IF;
    END_IF;

    IF (srrs + 'VOLUME_2D_EDGE') IN TYPEOF(aspect) THEN
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX' IN TYPEOF(item) THEN
        status := TRUE;
      END_IF;
    END_IF;

    IF (srrs + 'SURFACE_3D_EDGE') IN TYPEOF(aspect) THEN
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE' IN TYPEOF(item) THEN
        status := TRUE;
      END_IF;
    END_IF;



    IF (srrs + 'SURFACE_2D_EDGE') IN TYPEOF(aspect) THEN
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX' IN TYPEOF(item) THEN
        status := TRUE;
      END_IF;
    END_IF;

    IF (srrs + 'CURVE_EDGE') IN TYPEOF(aspect) THEN
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE' IN TYPEOF(item) THEN
        status := TRUE;

      END_IF;
    END_IF;

    IF 'TOPOLOGICAL_DEFINITION_AND_MESH_SCHEMA.TOPOLOGICAL_REGION' IN TYPEOF(item) THEN
      status := TRUE;
    END_IF;

  RETURN(status);
END_FUNCTION;

FUNCTION consistent_value
	(c_value: field_value; variable: GENERIC) : BOOLEAN;
    LOCAL
     vv_type                : STRING;
     fv_type                : SET [1:?] OF STRING;
    END_LOCAL;

    vv_type := variable_value_type (variable);

    fv_type := TYPEOF (c_value);

    IF NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
       'UNSPECIFIED_VALUE') IN fv_type) THEN

       IF NOT (vv_type IN fv_type) THEN
          RETURN (FALSE);
       END_IF;

    END_IF;

    RETURN (TRUE);
END_FUNCTION;

FUNCTION constraints_composite_curve_on_surface
	(c: composite_curve_on_surface) : BOOLEAN;
   LOCAL
     n_segments : INTEGER := SIZEOF(c.segments);
   END_LOCAL;
        
   REPEAT k := 1 TO n_segments;
     IF (NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_CURVE_ON_SURFACE' IN
           TYPEOF(c\composite_curve.segments[k].parent_curve)))  THEN
       RETURN (FALSE);
     END_IF;
   END_REPEAT;
   RETURN(TRUE);
END_FUNCTION;

FUNCTION constraints_geometry_shell_based_surface_model
	(m: shell_based_surface_model) : BOOLEAN;
   LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;
   
   REPEAT j := 1 TO SIZEOF(m.sbsm_boundary);
     IF (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OPEN_SHELL' IN
                     TYPEOF(m.sbsm_boundary[j])) AND
        (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CLOSED_SHELL' IN
           TYPEOF(m.sbsm_boundary[j]))))
     THEN
       result := FALSE;
       RETURN(result);
       (* A surface model is composed of OPEN_ and CLOSED_SHELLs. *)
     END_IF;
   END_REPEAT;
   RETURN(result);
END_FUNCTION;

FUNCTION constraints_geometry_shell_based_wireframe_model
	(m: shell_based_wireframe_model) : BOOLEAN;
   LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;

   REPEAT j := 1 TO SIZEOF(m.sbwm_boundary);
     IF (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.WIRE_SHELL' IN
                    TYPEOF(m.sbwm_boundary[j])) AND
        (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_SHELL' IN
                      TYPEOF(m.sbwm_boundary[j]))))
     THEN
       result := FALSE;
       RETURN(result);
       (* A wireframe model is composed of WIRE_ and VERTEX_SHELLs *)
     END_IF;
   END_REPEAT;
   RETURN(result);
END_FUNCTION;

FUNCTION constraints_param_b_spline
	(degree: INTEGER; up_knots: INTEGER; up_cp: INTEGER; knot_mult: LIST [0:?] OF INTEGER; knots: LIST [0:?] OF parameter_value) : BOOLEAN;
   LOCAL
     result  : BOOLEAN := TRUE;
     k, sum  : INTEGER;
   END_LOCAL;
   
   (* Find sum of knot multiplicities. *)
   sum := knot_mult[1];
   
   REPEAT i := 2 TO up_knots;
     sum := sum + knot_mult[i];
   END_REPEAT;
   
   (* Check limits holding for all B-spline parametrisations *)
   IF (degree < 1) OR (up_knots < 2) OR (up_cp < degree) OR
         (sum <> (degree + up_cp + 2)) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
   
   k := knot_mult[1];
   
   IF (k < 1) OR (k > degree + 1) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
      
   REPEAT i := 2 TO up_knots;
     IF (knot_mult[i] < 1) OR (knots[i] <= knots[i-1]) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     k := knot_mult[i];
     
     IF (i < up_knots) AND (k > degree) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     IF (i = up_knots) AND (k > degree + 1) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);
END_FUNCTION;

FUNCTION constraints_rectangular_composite_surface
	(s: rectangular_composite_surface) : BOOLEAN;
REPEAT i := 1 TO s.n_u;
       REPEAT j := 1 TO s.n_v;
         IF NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_SURFACE' IN TYPEOF
                    (s.segments[i][j].parent_surface)) OR
                 ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF
                    (s.segments[i][j].parent_surface))) THEN
           RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;

   (* Check the transition codes, omitting the last row or column *)
   REPEAT i := 1 TO s.n_u-1;
     REPEAT j := 1 TO s.n_v;
       IF s.segments[i][j].u_transition = discontinuous THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   
   REPEAT i := 1 TO s.n_u;
     REPEAT j := 1 TO s.n_v-1;
       IF s.segments[i][j].v_transition = discontinuous THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(TRUE);
END_FUNCTION;

FUNCTION control_characters_free
	(s: STRING) : BOOLEAN;
    LOCAL
      ch : STRING;
    END_LOCAL;

    REPEAT i:=1 TO LENGTH(s);
      ch := s[i];
      IF (ch = '\x9') OR (ch = '\xA') OR (ch = '\xD') THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION;

FUNCTION convert_to_literal
	(val: maths_atom) : generic_literal;
  LOCAL
    types : SET OF STRING := TYPEOF (val);
  END_LOCAL;
  IF 'INTEGER' IN types THEN  RETURN (make_int_literal (val));      END_IF;
  IF 'REAL'    IN types THEN  RETURN (make_real_literal (val));     END_IF;
  IF 'BOOLEAN' IN types THEN  RETURN (make_boolean_literal (val));  END_IF;
  IF 'STRING'  IN types THEN  RETURN (make_string_literal (val));   END_IF;
  IF 'LOGICAL' IN types THEN  RETURN (make_logical_literal (val));  END_IF;
  IF 'BINARY'  IN types THEN  RETURN (make_binary_literal (val));   END_IF;
  IF (schema_prefix + 'MATHS_ENUM_ATOM') IN types THEN
    RETURN (make_maths_enum_literal (val));
  END_IF;
  -- Should be unreachable
  RETURN (?);
END_FUNCTION;

FUNCTION convert_to_maths_function
	(func: maths_function_select) : maths_function;
  LOCAL
    efenum : elementary_function_enumerators;
    mthfun : maths_function;
  END_LOCAL;
  IF (schema_prefix + 'MATHS_FUNCTION') IN TYPEOF (func) THEN
    mthfun := func;
  ELSE
    efenum := func;
    mthfun := make_elementary_function (efenum);
  END_IF;
  RETURN (mthfun);
END_FUNCTION;

FUNCTION convert_to_maths_value
	(val: GENERIC: G) : maths_value;
  LOCAL
    types : SET OF STRING := TYPEOF (val);
    ival  : maths_integer;
    rval  : maths_real;
    nval  : maths_number;
    tfval : maths_boolean;
    lval  : maths_logical;
    sval  : maths_string;
    bval  : maths_binary;
    tval  : maths_tuple := the_empty_maths_tuple;
    mval  : maths_value;
  END_LOCAL;
  IF (schema_prefix + 'MATHS_VALUE') IN types THEN  RETURN (val);  END_IF;
  IF 'INTEGER' IN types THEN  ival := val;   RETURN (ival);   END_IF;
  IF 'REAL'    IN types THEN  rval := val;   RETURN (rval);   END_IF;
  IF 'NUMBER'  IN types THEN  nval := val;   RETURN (nval);   END_IF;
  IF 'BOOLEAN' IN types THEN  tfval := val;  RETURN (tfval);  END_IF;
  IF 'LOGICAL' IN types THEN  lval := val;   RETURN (lval);   END_IF;
  IF 'STRING'  IN types THEN  sval := val;   RETURN (sval);   END_IF;
  IF 'BINARY'  IN types THEN  bval := val;   RETURN (bval);   END_IF;
  IF 'LIST' IN types THEN
    REPEAT i := 1 TO SIZEOF (val);
      mval := convert_to_maths_value (val[i]);
      IF NOT EXISTS (mval) THEN  RETURN (?);  END_IF;
      INSERT (tval, mval, i-1);
    END_REPEAT;
    RETURN (tval);
  END_IF;
  RETURN (?);
END_FUNCTION;

FUNCTION convert_to_operand
	(val: maths_value) : generic_expression;
  LOCAL
    types  : SET OF STRING := stripped_typeof (val);
  END_LOCAL;
  -- Use intermediate variables of appropriate declared types to help the compilers.
  IF 'GENERIC_EXPRESSION' IN types THEN  RETURN (val);  END_IF;
  IF 'MATHS_ATOM' IN types THEN  RETURN (convert_to_literal (val));  END_IF;
  IF 'ATOM_BASED_VALUE' IN types THEN  RETURN (make_atom_based_literal(val));  END_IF;
  IF 'MATHS_TUPLE' IN types THEN  RETURN (make_maths_tuple_literal(val));  END_IF;
  -- Should be unreachable
  RETURN (?);
END_FUNCTION;

FUNCTION convert_to_operands
	(values: AGGREGATE OF maths_value) : LIST [0:?] OF generic_expression;
  LOCAL
    operands : LIST OF generic_expression := [];
    loc : INTEGER := 0;
  END_LOCAL;
  IF NOT EXISTS (values) THEN  RETURN (?);  END_IF;
  REPEAT i := LOINDEX (values) TO HIINDEX (values);
    INSERT (operands, convert_to_operand (values[i]), loc);
    loc := loc + 1;
  END_REPEAT;
  RETURN (operands);
END_FUNCTION;

FUNCTION convert_to_operands_prcmfn
	(srcdom: maths_space_or_function; prepfun: LIST [0:?] OF maths_function; finfun: maths_function_select) : LIST [2:?] OF generic_expression;
  LOCAL
    operands : LIST OF generic_expression := [];
  END_LOCAL;
  INSERT (operands, srcdom, 0);
  REPEAT i := 1 TO SIZEOF (prepfun);
    INSERT (operands, prepfun[i], i);
  END_REPEAT;
  INSERT (operands, convert_to_maths_function (finfun), SIZEOF (prepfun)+1);
  RETURN (operands);
END_FUNCTION;

FUNCTION cross_product
	(arg1: direction; arg2: direction) : vector;
  LOCAL
    mag    : REAL;
    res    : direction;
    v1,v2  : LIST[3:3] OF REAL;
    result : vector;
  END_LOCAL;
  
  IF ( NOT EXISTS (arg1) OR (arg1.dim = 2)) OR
     ( NOT EXISTS (arg2) OR (arg2.dim = 2)) THEN
    RETURN(?);
  ELSE
    BEGIN
      v1  := normalise(arg1).direction_ratios;
      v2  := normalise(arg2).direction_ratios;
      res := dummy_gri || direction([(v1[2]*v2[3] - v1[3]*v2[2]),
            (v1[3]*v2[1] - v1[1]*v2[3]), (v1[1]*v2[2] - v1[2]*v2[1])]);
      mag := 0.0;
      REPEAT i := 1 TO 3;
        mag := mag + res.direction_ratios[i]*res.direction_ratios[i];
      END_REPEAT;
      IF (mag > 0.0) THEN
        result := dummy_gri || vector(res, SQRT(mag));
      ELSE
        result := dummy_gri || vector(arg1, 0.0);
      END_IF;
      RETURN(result);
    END;
  END_IF;
END_FUNCTION;

FUNCTION curve_weights_positive
	(b: rational_b_spline_curve) : BOOLEAN;
   LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;

   REPEAT i := 0 TO b.upper_index_on_control_points;
     IF b.weights[i] <= 0.0  THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);
END_FUNCTION;

FUNCTION default_tolerance_table_cell_wr2
	(agg: compound_item_definition) : BOOLEAN;
BEGIN 
IF SIZEOF(agg) <= 5 THEN 
  RETURN(TRUE); 
ELSE 
  RETURN(FALSE); 
END_IF; 
END;
END_FUNCTION;

FUNCTION default_tolerance_table_cell_wr3
	(agg: compound_item_definition) : BOOLEAN;
BEGIN 
IF (SIZEOF(QUERY ( i <* agg | (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) 
  AND (i\representation_item.name = 'significant number of digits')) )) = 1) OR 
((SIZEOF(QUERY ( i <* agg | (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  (i\representation_item.name = 'lower limit')) )) = 1) AND 
(SIZEOF( QUERY ( i <* agg | (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  (i\representation_item.name = 'upper limit')) )) = 1)) THEN 
  RETURN(TRUE); 
ELSE 
  RETURN(FALSE); 
END_IF; 
END;
END_FUNCTION;

FUNCTION default_tolerance_table_cell_wr4
	(agg: compound_item_definition) : BOOLEAN;
BEGIN 
IF (SIZEOF(QUERY ( i <* agg | (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  (i\representation_item.name = 'plus minus tolerance value')) )) = 1) OR 
((SIZEOF(QUERY ( i <* agg | (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND (
  i\representation_item.name = 'lower tolerance value')) )) = 1) AND 
(SIZEOF( QUERY ( i <* agg | (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND (
  i\representation_item.name = 'upper tolerance value')) )) = 1)) THEN 
  RETURN(TRUE); 
ELSE 
  RETURN(FALSE); 
END_IF; 
END;
END_FUNCTION;

FUNCTION default_tolerance_table_cell_wr5
	(agg: compound_item_definition) : BOOLEAN;
BEGIN 
IF (SIZEOF(QUERY ( i <* agg | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i)) )) <= 1) AND 
(SIZEOF(QUERY ( i <* agg | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i)) )) = 
  SIZEOF(QUERY ( i <* agg | (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  (i\representation_item.name = 'cell description'))) )) 
THEN 
  RETURN(TRUE); 
ELSE 
  RETURN(FALSE); 
END_IF; 
END;
END_FUNCTION;

FUNCTION definite_integral_check
	(domain: tuple_space; vrblint: input_selector; lowerinf: BOOLEAN; upperinf: BOOLEAN) : BOOLEAN;
  LOCAL
    domn : tuple_space := domain;
    fspc : maths_space;
    dim : nonnegative_integer;
    k : positive_integer;
  END_LOCAL;
  IF (space_dimension (domain) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (domain))) THEN
    domn := factor1 (domain);
  END_IF;
  dim := space_dimension (domn);
  k := vrblint;
  IF k > dim THEN  RETURN (FALSE);  END_IF;
  fspc := factor_space (domn, k);
  IF NOT ((schema_prefix + 'REAL_INTERVAL') IN TYPEOF (fspc)) THEN
    RETURN (FALSE);
  END_IF;
  IF lowerinf AND min_exists (fspc) THEN  RETURN (FALSE);  END_IF;
  IF upperinf AND max_exists (fspc) THEN  RETURN (FALSE);  END_IF;
  RETURN (TRUE);
END_FUNCTION;

FUNCTION definite_integral_expr_check
	(operands: LIST [2:?] OF generic_expression; lowerinf: BOOLEAN; upperinf: BOOLEAN) : BOOLEAN;
  LOCAL
    nops : INTEGER := 2;
    vspc : maths_space;
    dim : nonnegative_integer;
    k : positive_integer;
    bspc : maths_space;
  END_LOCAL;
  IF NOT lowerinf THEN  nops := nops + 1;  END_IF;
  IF NOT upperinf THEN  nops := nops + 1;  END_IF;
  IF SIZEOF (operands) <> nops THEN  RETURN (FALSE);  END_IF;
  IF NOT ('GENERIC_VARIABLE' IN stripped_typeof(operands[2])) THEN
    RETURN (FALSE);
  END_IF;
  IF NOT has_values_space (operands[2]) THEN  RETURN (FALSE);  END_IF;
  vspc := values_space_of (operands[2]);
  IF NOT ('REAL_INTERVAL' IN stripped_typeof(vspc)) THEN  RETURN (FALSE);  END_IF;
  IF lowerinf THEN
    IF min_exists (vspc) THEN  RETURN (FALSE);  END_IF;
    k := 3;
  ELSE
    IF NOT has_values_space (operands[3]) THEN  RETURN (FALSE);  END_IF;
    bspc := values_space_of (operands[3]);
    IF NOT compatible_spaces (bspc, vspc) THEN  RETURN (FALSE);  END_IF;
    k := 4;
  END_IF;
  IF upperinf THEN
    IF max_exists (vspc) THEN  RETURN (FALSE);  END_IF;
  ELSE
    IF NOT has_values_space (operands[k]) THEN  RETURN (FALSE);  END_IF;
    bspc := values_space_of (operands[k]);
    IF NOT compatible_spaces (bspc, vspc) THEN  RETURN (FALSE);  END_IF;
  END_IF;
  RETURN (TRUE);
END_FUNCTION;

FUNCTION definition_for_temporal_spatial_domain
	(domain: temporal_spatial_domain) : BOOLEAN;
    LOCAL
      spatial_set : SET OF spatial_decomposition_of_temporal_spatial_domain;
      behavioural_set : SET OF behavioural_decomposition_of_temporal_spatial_domain;
      domains : SET OF temporal_spatial_domain := [];
      idealising : BAG OF idealisation_relationship;
      spatial_bag : BAG OF spatial_decomposition_of_temporal_spatial_domain;
      behavioural_bag : BAG OF behavioural_decomposition_of_temporal_spatial_domain;
    END_LOCAL;

    idealising := USEDIN(domain, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.IDEALISATION_RELATIONSHIP.IDEALISATION');
    IF SIZEOF(idealising) > 0 THEN
      RETURN (TRUE);
    END_IF;
    spatial_bag := USEDIN(domain, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SPATIAL_DECOMPOSITION_OF_TEMPORAL_SPATIAL_DOMAIN.PARTS');
    IF SIZEOF(spatial_bag) > 0 THEN
      spatial_set := bag_to_set(spatial_bag);
      REPEAT i := 1 TO HIINDEX(spatial_set);
        domains := domains + spatial_set[i].whole;
      END_REPEAT;
    END_IF;
    behavioural_bag := USEDIN(domain, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BEHAVIOURAL_DECOMPOSITION_OF_TEMPORAL_SPATIAL_DOMAIN.PARTS');
    IF SIZEOF(behavioural_bag) > 0 THEN
      behavioural_set := bag_to_set(behavioural_bag);
      REPEAT i := 1 TO HIINDEX(behavioural_set);
        domains := domains + behavioural_set[i].whole;
      END_REPEAT;
    END_IF;
    IF SIZEOF(domains) > 0 THEN
      REPEAT i := 1 TO HIINDEX(domains);
        IF definition_for_temporal_spatial_domain(domains[i]) THEN
          RETURN (TRUE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN (FALSE);
END_FUNCTION;

FUNCTION dependently_instantiated
	(set_of_input_instances: SET [0:?] OF GENERIC: igen; set_of_input_types: SET [0:?] OF STRING; previous_in_chain: LIST [0:?] OF GENERIC: cgen) : BOOLEAN;
LOCAL
  number_of_input_instances     : INTEGER;
  number_of_referring_instances : INTEGER;
  bag_of_referring_instances    : BAG OF GENERIC:igen := [];
  dependently_instantiated_flag : BOOLEAN;
  previous_in_chain_plus        : LIST OF GENERIC:cgen := [];
  result                        : BOOLEAN := true;
  set_of_types                  : SET OF STRING := [];
END_LOCAL;

IF EXISTS(set_of_input_instances) THEN
  number_of_input_instances := SIZEOF(set_of_input_instances);
  (* Add the declared type of bag_of_referring_instances to the set of
     types of the REFERENCEd instances for the subset comparison later.
   *)
  set_of_input_types := set_of_input_types + 'GENERIC';
  REPEAT i:=1 TO number_of_input_instances;
    (* Determine all references to the current input instance. *)
    bag_of_referring_instances := USEDIN (set_of_input_instances[i] , '');
    IF EXISTS(bag_of_referring_instances) THEN
      number_of_referring_instances := SIZEOF(bag_of_referring_instances);
      dependently_instantiated_flag := false;
      REPEAT j:=1 TO number_of_referring_instances;
        (* Determine the type strings of the current referencing instance.
         *)
        set_of_types := TYPEOF(bag_of_referring_instances[j]);
        (* If the referencing instance is of one of the types of the
           only dependently instantiable select items, the current input
           instance may still be invalidly instantiated.
           Otherwise it is OK, and the next input instance is tested.
         *)
        IF set_of_types <= set_of_input_types THEN -- subset operator
          (* The referring instance is of one of the restricted types.
             However, it may itself be referred to by a valid instance;
             then also the current instance would be valid.
             Thus, call this function recursively with the referring
             instance as input.
             To avoid an infinite loop in case a set of instances
             reference each other in a closed loop, test first whether
             the current referencing instance is in the list of
             previously processed chain members.
           *)
          IF NOT (bag_of_referring_instances[j] IN previous_in_chain) THEN
            previous_in_chain_plus := previous_in_chain +
            set_of_input_instances[i];
            IF dependently_instantiated([bag_of_referring_instances[j]],
              set_of_input_types,
              previous_in_chain_plus) THEN
              dependently_instantiated_flag := true;
              ESCAPE; -- dependently instantiated; next input instance
            ELSE
              (* Not dependently instantiated: go to next referring
              instance. *)
              SKIP;
            END_IF;
          END_IF;
        ELSE
          dependently_instantiated_flag := true;
          ESCAPE; -- dependently instantiated; take next input instance
        END_IF;
      END_REPEAT;
      IF NOT dependently_instantiated_flag THEN
        RETURN(false);
      END_IF;
    ELSE
      RETURN(false); -- not referenced at all => invalidly instantiated
    END_IF;
  END_REPEAT;
ELSE
  RETURN(false); -- no input
END_IF;

RETURN(true);
END_FUNCTION;

FUNCTION derive_angle
	(placement_1: axis2_placement_3d; placement_2: axis2_placement_3d) : plane_angle_measure;
    LOCAL
      v1     : direction;
      v2     : direction;
      mag_v1 : REAL;
      mag_v2 : REAL;
      theta  : plane_angle_measure;
    END_LOCAL;
    v1 := placement_1.p[1];
    v2 := placement_2.p[1];
    mag_v1 := SQRT (v1.direction_ratios[1]*v1.direction_ratios[1] +
                    v1.direction_ratios[2]*v1.direction_ratios[2]);
    mag_v2 := SQRT (v2.direction_ratios[1]*v2.direction_ratios[1] +
                    v2.direction_ratios[2]*v2.direction_ratios[2]);
    IF ((mag_v1 = 0.0) OR (mag_v2 = 0.0)) THEN
      theta := 0.0;
      RETURN (theta);
    END_IF;
    theta := ACOS ((v1.direction_ratios[1]*v2.direction_ratios[1] +
                    v1.direction_ratios[2]*v2.direction_ratios[2]) /
                   (mag_v1*mag_v2));
    RETURN (theta);
END_FUNCTION;

FUNCTION derive_definite_integral_domain
	(igrl: definite_integral_function) : tuple_space;
FUNCTION process_product_space(spc         : product_space;
                                 idx, prefix : INTEGER;
                                 vdomn       : maths_space) : product_space;
    LOCAL
      uspc : uniform_product_space;
      expnt : INTEGER;
      factors : LIST OF maths_space;
    END_LOCAL;
    IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN TYPEOF (spc) THEN
      uspc := spc;
      expnt := uspc.exponent + prefix;
      IF idx <= uspc.exponent THEN  expnt := expnt - 1;  END_IF;
      IF expnt = 0 THEN
        RETURN (make_listed_product_space([]));
      ELSE
        RETURN (make_uniform_product_space(uspc.base,expnt));
      END_IF;
    ELSE
      factors := spc\listed_product_space.factors;
      IF idx <= SIZEOF (factors) THEN  REMOVE (factors, idx);  END_IF;
      IF prefix > 0 THEN
        INSERT (factors, vdomn, 0);
        IF prefix > 1 THEN  INSERT (factors, vdomn, 0);  END_IF;
      END_IF;
      RETURN (make_listed_product_space(factors));
    END_IF;
  END_FUNCTION;  -- process_product_space

  -- Resume body of derive_definite_integral_domain function
  LOCAL
    idomn : tuple_space := igrl.integrand.domain;
    types : SET OF STRING := TYPEOF (idomn);
    idx : INTEGER := igrl.variable_of_integration;
    tupled : BOOLEAN := bool(((space_dimension(idomn) = 1) AND
                             ((schema_prefix + 'TUPLE_SPACE') IN types)));
    prefix : INTEGER := 0;
    espc : extended_tuple_space;
    vdomn : maths_space;
  END_LOCAL;
  IF tupled THEN
    idomn := factor1(idomn);
    types := TYPEOF (idomn);
  END_IF;
  IF igrl.lower_limit_neg_infinity THEN  prefix := prefix + 1;  END_IF;
  IF igrl.upper_limit_pos_infinity THEN  prefix := prefix + 1;  END_IF;
  vdomn := factor_space(idomn,idx);
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types THEN
    espc := idomn;
    idomn := make_extended_tuple_space(process_product_space(espc.base,idx,
      prefix,vdomn),espc.extender);
  ELSE
    idomn := process_product_space(idomn,idx,prefix,vdomn);
  END_IF;
  IF tupled THEN  RETURN (one_tuples_of(idomn));
  ELSE            RETURN (idomn);                 END_IF;
END_FUNCTION;

FUNCTION derive_dimensional_exponents
	(x: unit) : dimensional_exponents;
    LOCAL
      result : dimensional_exponents := dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    END_LOCAL;

    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DERIVED_UNIT' IN TYPEOF(x) THEN
      REPEAT i := LOINDEX(x\derived_unit.elements) TO HIINDEX(x\derived_unit.elements);
        result.length_exponent := result.length_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.length_exponent);
        result.mass_exponent := result.mass_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.mass_exponent);
        result.time_exponent := result.time_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.time_exponent);
        result.electric_current_exponent := result.electric_current_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.electric_current_exponent);
        result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.thermodynamic_temperature_exponent);
        result.amount_of_substance_exponent := result.amount_of_substance_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.amount_of_substance_exponent);
        result.luminous_intensity_exponent := result.luminous_intensity_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.luminous_intensity_exponent);
      END_REPEAT;
    ELSE
      result := x\named_unit.dimensions;
    END_IF;
    RETURN (result);
END_FUNCTION;

FUNCTION derive_elementary_function_domain
	(ef_val: elementary_function_enumerators) : tuple_space;
IF NOT EXISTS (ef_val) THEN  RETURN (?);  END_IF;
  CASE ef_val OF
  ef_and : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_logicals));
  ef_or : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_logicals));
  ef_not : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_xor : RETURN (make_uniform_product_space (the_logicals, 2));
  ef_negate_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_add_i : RETURN (the_integer_tuples);
  ef_subtract_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_multiply_i : RETURN (the_integer_tuples);
  ef_divide_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_mod_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_exponentiate_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_eq_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_ne_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_gt_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_lt_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_ge_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_le_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_abs_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_if_i : RETURN (make_listed_product_space ([the_logicals, the_integers,
    the_integers]));
  ef_negate_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_reciprocal_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_add_r : RETURN (the_real_tuples);
  ef_subtract_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_multiply_r : RETURN (the_real_tuples);
  ef_divide_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_mod_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_exponentiate_r : RETURN (make_listed_product_space ([the_nonnegative_reals,
    the_reals]));
  ef_exponentiate_ri : RETURN (make_listed_product_space ([the_reals, the_integers]));
  ef_eq_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_ne_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_gt_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_lt_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_ge_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_le_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_abs_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_acos_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_asin_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_atan2_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_cos_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_exp_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_ln_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_log2_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_log10_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_sin_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_sqrt_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_tan_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_if_r : RETURN (make_listed_product_space ([the_logicals, the_reals, the_reals]));
  ef_negate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_reciprocal_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_add_c : RETURN (the_complex_tuples);
  ef_subtract_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_multiply_c : RETURN (the_complex_tuples);
  ef_divide_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_exponentiate_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_exponentiate_ci : RETURN (make_listed_product_space ([the_complex_numbers,
    the_integers]));
  ef_eq_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_ne_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_conjugate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_abs_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_arg_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_cos_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exp_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_ln_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sin_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sqrt_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_tan_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_if_c : RETURN (make_listed_product_space ([the_logicals, the_complex_numbers,
    the_complex_numbers]));
  ef_subscript_s : RETURN (make_listed_product_space ([the_strings, the_integers]));
  ef_eq_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_ne_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_gt_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_lt_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_ge_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_le_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_subsequence_s : RETURN (make_listed_product_space ([the_strings, the_integers,
    the_integers]));
  ef_concat_s : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_strings));
  ef_size_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_format : RETURN (make_listed_product_space ([the_numbers, the_strings]));
  ef_value : RETURN (make_uniform_product_space (the_strings, 1));
  ef_like : RETURN (make_uniform_product_space (the_strings, 2));
  ef_if_s : RETURN (make_listed_product_space ([the_logicals, the_strings,
    the_strings]));
  ef_subscript_b : RETURN (make_listed_product_space ([the_binarys, the_integers]));
  ef_eq_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_ne_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_gt_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_lt_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_ge_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_le_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_subsequence_b : RETURN (make_listed_product_space ([the_binarys, the_integers,
    the_integers]));
  ef_concat_b : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_binarys));
  ef_size_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_if_b : RETURN (make_listed_product_space ([the_logicals, the_binarys,
    the_binarys]));
  ef_subscript_t : RETURN (make_listed_product_space ([the_tuples, the_integers]));
  ef_eq_t : RETURN (make_uniform_product_space (the_tuples, 2));
  ef_ne_t : RETURN (make_uniform_product_space (the_tuples, 2));
  ef_concat_t : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_tuples));
  ef_size_t : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_entuple : RETURN (the_tuples);
  ef_detuple : RETURN (make_uniform_product_space (the_generics, 1));
  ef_insert : RETURN (make_listed_product_space ([the_tuples, the_generics,
    the_integers]));
  ef_remove : RETURN (make_listed_product_space ([the_tuples, the_integers]));
  ef_if_t : RETURN (make_listed_product_space ([the_logicals, the_tuples,
    the_tuples]));
  ef_sum_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_product_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_add_it : RETURN (make_extended_tuple_space (the_integer_tuples,
    the_integer_tuples));
  ef_subtract_it : RETURN (make_uniform_product_space (the_integer_tuples, 2));
  ef_scalar_mult_it : RETURN (make_listed_product_space ([the_integers,
    the_integer_tuples]));
  ef_dot_prod_it : RETURN (make_uniform_product_space (the_integer_tuples, 2));
  ef_sum_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_product_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_add_rt : RETURN (make_extended_tuple_space (the_real_tuples, the_real_tuples));
  ef_subtract_rt : RETURN (make_uniform_product_space (the_real_tuples, 2));
  ef_scalar_mult_rt : RETURN (make_listed_product_space ([the_reals,
    the_real_tuples]));
  ef_dot_prod_rt : RETURN (make_uniform_product_space (the_real_tuples, 2));
  ef_norm_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_sum_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_product_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_add_ct : RETURN (make_extended_tuple_space (the_complex_tuples,
    the_complex_tuples));
  ef_subtract_ct : RETURN (make_uniform_product_space (the_complex_tuples, 2));
  ef_scalar_mult_ct : RETURN (make_listed_product_space ([the_complex_numbers,
    the_complex_tuples]));
  ef_dot_prod_ct : RETURN (make_uniform_product_space (the_complex_tuples, 2));
  ef_norm_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_if : RETURN (make_listed_product_space ([the_logicals, the_generics,
    the_generics]));
  ef_ensemble : RETURN (the_tuples);
  ef_member_of : RETURN (make_listed_product_space ([the_generics, the_maths_spaces]));
  OTHERWISE : RETURN (?);
  END_CASE;
END_FUNCTION;

FUNCTION derive_elementary_function_range
	(ef_val: elementary_function_enumerators) : tuple_space;
IF NOT EXISTS (ef_val) THEN  RETURN (?);  END_IF;
  CASE ef_val OF
  ef_and : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_or : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_not : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_xor : RETURN (make_uniform_product_space (the_logicals, 2));
  ef_negate_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_add_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_subtract_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_multiply_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_divide_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_mod_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_exponentiate_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_eq_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_abs_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_if_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_negate_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_reciprocal_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_add_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_subtract_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_multiply_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_divide_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_mod_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_exponentiate_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_exponentiate_ri : RETURN (make_uniform_product_space (the_reals, 1));
  ef_eq_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_abs_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_acos_r : RETURN (make_uniform_product_space (the_zero_pi_interval, 1));
  ef_asin_r : RETURN (make_uniform_product_space (the_neghalfpi_halfpi_interval, 1));
  ef_atan2_r : RETURN (make_uniform_product_space (the_negpi_pi_interval, 1));
  ef_cos_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_exp_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_ln_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_log2_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_log10_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_sin_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_sqrt_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_tan_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_if_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_negate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_reciprocal_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_add_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_subtract_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_multiply_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_divide_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exponentiate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exponentiate_ci : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_eq_c : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_c : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_conjugate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_abs_c : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_arg_c : RETURN (make_uniform_product_space (the_negpi_pi_interval, 1));
  ef_cos_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exp_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_ln_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sin_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sqrt_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_tan_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_if_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_subscript_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_eq_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_subsequence_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_concat_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_size_s : RETURN (make_uniform_product_space (the_integers, 1));
  ef_format : RETURN (make_uniform_product_space (the_strings, 1));
  ef_value : RETURN (make_uniform_product_space (the_reals, 1));
  ef_like : RETURN (make_uniform_product_space (the_booleans, 1));
  ef_if_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_subscript_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_eq_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_subsequence_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_concat_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_size_b : RETURN (make_uniform_product_space (the_integers, 1));
  ef_if_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_subscript_t : RETURN (make_uniform_product_space (the_generics, 1));
  ef_eq_t : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_t : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_concat_t : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_size_t : RETURN (make_uniform_product_space (the_integers, 1));
  ef_entuple : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_detuple : RETURN (the_tuples);
  ef_insert : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_remove : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_if_t : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_sum_it : RETURN (make_uniform_product_space (the_integers, 1));
  ef_product_it : RETURN (make_uniform_product_space (the_integers, 1));
  ef_add_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_subtract_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_scalar_mult_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_dot_prod_it : RETURN (make_uniform_product_space (the_integers, 1));
  ef_sum_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_product_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_add_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_subtract_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_scalar_mult_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_dot_prod_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_norm_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_sum_ct : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_product_ct : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_add_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_subtract_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_scalar_mult_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_dot_prod_ct : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_norm_ct : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_if : RETURN (make_uniform_product_space (the_generics, 1));
  ef_ensemble : RETURN (make_uniform_product_space (the_maths_spaces, 1));
  ef_member_of : RETURN (make_uniform_product_space (the_logicals, 1));
  OTHERWISE : RETURN (?);
  END_CASE;
END_FUNCTION;

FUNCTION derive_finite_function_domain
	(pairs: SET [1:?] OF LIST [2:2] OF maths_value) : tuple_space;
  LOCAL
    result : SET OF maths_value := [];
  END_LOCAL;
-- An ambiguity in ISO 10303-11:1994 pages 99-101 leaves the result of the following
-- three lines ambiguous in those cases where an operand is simultaneously a member
-- of the base type and the aggregate type.
-- REPEAT i := 1 TO SIZEOF (pairs);
--   result := result + pairs[i][1];
-- END_REPEAT;
-- The next line unions an empty set and the desired list to get the desired set.
  result := result + list_selected_components (pairs, 1);
  RETURN (one_tuples_of (make_finite_space (result)));
END_FUNCTION;

FUNCTION derive_finite_function_range
	(pairs: SET [1:?] OF LIST [2:2] OF maths_value) : tuple_space;
  LOCAL
    result : SET OF maths_value := [];
  END_LOCAL;
-- An ambiguity in ISO 10303-11:1994 pages 99-101 leaves the result of the following
-- three lines ambiguous in those cases where an operand is simultaneously a member
-- of the base type and the aggregate type.
-- REPEAT i := 1 TO SIZEOF (pairs);
--   result := result + pairs[i][2];
-- END_REPEAT;
-- The next line unions an empty set and the desired list to get the desired set.
  result := result + list_selected_components (pairs, 2);
  RETURN (one_tuples_of (make_finite_space (result)));
END_FUNCTION;

FUNCTION derive_function_domain
	(func: maths_function) : tuple_space;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(func);
    tspace : tuple_space := make_listed_product_space ([]);
    shape : LIST OF positive_integer;
    sidxs  : LIST OF INTEGER := [0];
    itvl   : finite_integer_interval;
    factors : LIST OF finite_integer_interval := [];
    is_uniform : BOOLEAN := TRUE;
  END_LOCAL;
  IF 'FINITE_FUNCTION' IN typenames THEN
    RETURN (derive_finite_function_domain (func\finite_function.pairs));
  END_IF;
  IF 'CONSTANT_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\constant_function.source_of_domain));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\selector_function.source_of_domain));
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN typenames THEN
    RETURN (derive_elementary_function_domain (func\elementary_function.func_id));
  END_IF;
  IF 'RESTRICTION_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (func\restriction_function.operand));
  END_IF;
  IF 'REPACKAGING_FUNCTION' IN typenames THEN
    IF func\repackaging_function.input_repack = ro_nochange THEN
      RETURN (func\repackaging_function.operand.domain);
    END_IF;
    IF func\repackaging_function.input_repack = ro_wrap_as_tuple THEN
      RETURN (factor1 (func\repackaging_function.operand.domain));
    END_IF;
    IF func\repackaging_function.input_repack = ro_unwrap_tuple THEN
      RETURN (one_tuples_of (func\repackaging_function.operand.domain));
    END_IF;
    -- Unreachable, as there is no other possible value for input_repack.
    RETURN (?);
  END_IF;
  IF 'REINDEXED_ARRAY_FUNCTION' IN typenames THEN
    shape := shape_of_array(func\unary_generic_expression.operand);
    sidxs := func\reindexed_array_function.starting_indices;
    REPEAT i := 1 TO SIZEOF (shape);
      itvl := make_finite_integer_interval (sidxs[i], sidxs[i]+shape[i]-1);
      INSERT (factors, itvl, i-1);
      IF shape[i] <> shape[1] THEN  is_uniform := FALSE;  END_IF;
    END_REPEAT;
    IF is_uniform THEN
      RETURN (make_uniform_product_space (factors[1], SIZEOF (shape)));
    END_IF;
    RETURN (make_listed_product_space (factors));
  END_IF;
  IF 'SERIES_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (func\series_composed_function.operands[1].domain);
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\parallel_composed_function.source_of_domain));
  END_IF;
  IF 'EXPLICIT_TABLE_FUNCTION' IN typenames THEN
    shape := func\explicit_table_function.shape;
    sidxs[1] := func\explicit_table_function.index_base;
    REPEAT i := 1 TO SIZEOF (shape);
      itvl := make_finite_integer_interval (sidxs[1], sidxs[1]+shape[i]-1);
      INSERT (factors, itvl, i-1);
      IF shape[i] <> shape[1] THEN  is_uniform := FALSE;  END_IF;
    END_REPEAT;
    IF is_uniform THEN
      RETURN (make_uniform_product_space (factors[1], SIZEOF (shape)));
    END_IF;
    RETURN (make_listed_product_space (factors));
  END_IF;
  IF 'HOMOGENEOUS_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\homogeneous_linear_function.mat.range),
      func\homogeneous_linear_function.mat\explicit_table_function.shape
      [func\homogeneous_linear_function.sum_index])));
  END_IF;
  IF 'GENERAL_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\general_linear_function.mat.range),
      func\general_linear_function.mat\explicit_table_function.shape
      [func\general_linear_function.sum_index] - 1)));
  END_IF;
  IF 'B_SPLINE_BASIS' IN typenames THEN
    RETURN (one_tuples_of (make_finite_real_interval
      (func\b_spline_basis.repeated_knots[func\b_spline_basis.order], closed,
      func\b_spline_basis.repeated_knots[func\b_spline_basis.num_basis+1], closed)));
  END_IF;
  IF 'B_SPLINE_FUNCTION' IN typenames THEN
    REPEAT i := 1 TO SIZEOF (func\b_spline_function.basis);
      tspace := assoc_product_space (tspace, func\b_spline_function.basis[i].domain);
    END_REPEAT;
    RETURN (one_tuples_of (tspace));
  END_IF;
  IF 'RATIONALIZE_FUNCTION' IN typenames THEN
    RETURN (func\rationalize_function.fun.domain);
  END_IF;
  IF 'PARTIAL_DERIVATIVE_FUNCTION' IN typenames THEN
    RETURN (func\partial_derivative_function.derivand.domain);
  END_IF;
  IF 'DEFINITE_INTEGRAL_FUNCTION' IN typenames THEN
    RETURN (derive_definite_integral_domain(func));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN typenames THEN
    REPEAT i := 1 TO SIZEOF (func\abstracted_expression_function.variables);
      tspace := assoc_product_space (tspace, one_tuples_of (values_space_of
        (func\abstracted_expression_function.variables[i])));
    END_REPEAT;
    RETURN (tspace);
  END_IF;
  IF 'EXPRESSION_DENOTED_FUNCTION' IN typenames THEN
    RETURN (values_space_of (func\expression_denoted_function.expr)\function_space.
      domain_argument);
  END_IF;
  IF 'IMPORTED_POINT_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_listed_product_space ([])));
  END_IF;
  IF 'IMPORTED_CURVE_FUNCTION' IN typenames THEN
    RETURN (func\imported_curve_function.parametric_domain);
  END_IF;
  IF 'IMPORTED_SURFACE_FUNCTION' IN typenames THEN
    RETURN (func\imported_surface_function.parametric_domain);
  END_IF;
  IF 'IMPORTED_VOLUME_FUNCTION' IN typenames THEN
    RETURN (func\imported_volume_function.parametric_domain);
  END_IF;
  IF 'APPLICATION_DEFINED_FUNCTION' IN typenames THEN
    RETURN (func\application_defined_function.explicit_domain);
  END_IF;
  -- Unreachable, as no other subtypes of maths_function are permissible without
  -- first modifying this function to account for them.
  RETURN (?);
END_FUNCTION;

FUNCTION derive_function_range
	(func: maths_function) : tuple_space;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(func);
    tspace : tuple_space := make_listed_product_space ([]);
    m, n : nonnegative_integer := 0;
    temp : INTEGER := 0;
  END_LOCAL;
  IF 'FINITE_FUNCTION' IN typenames THEN
    RETURN (derive_finite_function_range (func\finite_function.pairs));
  END_IF;
  IF 'CONSTANT_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_finite_space ([func\constant_function.sole_output])));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames THEN
    tspace := func.domain;
    IF (space_dimension(tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
      TYPEOF (tspace)) THEN
      tspace := factor1 (tspace);
    END_IF;
    RETURN (one_tuples_of (factor_space (tspace, func\selector_function.selector)));
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN typenames THEN
    RETURN (derive_elementary_function_range (func\elementary_function.func_id));
  END_IF;
  IF 'RESTRICTION_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (func\restriction_function.operand));
  END_IF;
  IF 'REPACKAGING_FUNCTION' IN typenames THEN
    tspace := func\repackaging_function.operand.range;
    IF func\repackaging_function.output_repack = ro_wrap_as_tuple THEN
      tspace := one_tuples_of (tspace);
    END_IF;
    IF func\repackaging_function.output_repack = ro_unwrap_tuple THEN
      tspace := factor1 (tspace);
    END_IF;
    IF func\repackaging_function.selected_output > 0 THEN
      tspace := one_tuples_of (factor_space (tspace,
        func\repackaging_function.selected_output));
    END_IF;
    RETURN (tspace);
  END_IF;
  IF 'REINDEXED_ARRAY_FUNCTION' IN typenames THEN
    RETURN (func\unary_generic_expression.operand\maths_function.range);
  END_IF;
  IF 'SERIES_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (func\series_composed_function.operands[SIZEOF
      (func\series_composed_function.operands)].range);
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (func\parallel_composed_function.final_function.range);
  END_IF;
  IF 'EXPLICIT_TABLE_FUNCTION' IN typenames THEN
    IF 'LISTED_REAL_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_reals));
    END_IF;
    IF 'LISTED_INTEGER_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_integers));
    END_IF;
    IF 'LISTED_LOGICAL_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_logicals));
    END_IF;
    IF 'LISTED_STRING_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_strings));
    END_IF;
    IF 'LISTED_COMPLEX_NUMBER_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_complex_numbers));
    END_IF;
    IF 'LISTED_DATA' IN typenames THEN
      RETURN (one_tuples_of (func\listed_data.value_range));
    END_IF;
    IF 'EXTERNALLY_LISTED_DATA' IN typenames THEN
      RETURN (one_tuples_of (func\externally_listed_data.value_range));
    END_IF;
    IF 'LINEARIZED_TABLE_FUNCTION' IN typenames THEN
      RETURN (func\linearized_table_function.source.range);
    END_IF;
    IF 'BASIC_SPARSE_MATRIX' IN typenames THEN
      RETURN (func\basic_sparse_matrix.val.range);
    END_IF;
    -- Unreachable, as no other subtypes of explicit_table_function are permissible
    -- without first modifying this function to account for them.
    RETURN (?);
  END_IF;
  IF 'HOMOGENEOUS_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\homogeneous_linear_function.mat.range),
      func\homogeneous_linear_function.mat\explicit_table_function.shape
      [3 - func\homogeneous_linear_function.sum_index])));
  END_IF;
  IF 'GENERAL_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\general_linear_function.mat.range),
      func\general_linear_function.mat\explicit_table_function.shape
      [3 - func\general_linear_function.sum_index])));
  END_IF;
  IF 'B_SPLINE_BASIS' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space (the_reals,
      func\b_spline_basis.num_basis)));
  END_IF;
  IF 'B_SPLINE_FUNCTION' IN typenames THEN
    tspace := factor1 (func\b_spline_function.coef.domain);
    m := SIZEOF (func\b_spline_function.basis);
    n := space_dimension (tspace);
    IF m = n THEN
      RETURN (one_tuples_of (the_reals));
    END_IF;
    IF m = n - 1 THEN
      RETURN (one_tuples_of (make_uniform_product_space (the_reals,
        factor_space (tspace, n)\finite_integer_interval.size)));
    END_IF;
    tspace := extract_factors (tspace, m+1, n);
    RETURN (one_tuples_of (make_function_space (sc_equal, tspace, sc_subspace,
      number_superspace_of (func\b_spline_function.coef.range))));
  END_IF;
  IF 'RATIONALIZE_FUNCTION' IN typenames THEN
    tspace := factor1 (func\rationalize_function.fun.range);
    n := space_dimension (tspace);
    RETURN (one_tuples_of (make_uniform_product_space (number_superspace_of (
      factor1 (tspace)), n-1)));
  END_IF;
  IF 'PARTIAL_DERIVATIVE_FUNCTION' IN typenames THEN
    RETURN (drop_numeric_constraints (
      func\partial_derivative_function.derivand.range));
  END_IF;
  IF 'DEFINITE_INTEGRAL_FUNCTION' IN typenames THEN
    RETURN (drop_numeric_constraints (
      func\definite_integral_function.integrand.range));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of(values_space_of(func\abstracted_expression_function.expr)));
  END_IF;
  IF 'EXPRESSION_DENOTED_FUNCTION' IN typenames THEN
    RETURN (values_space_of (func\expression_denoted_function.expr)\function_space.
      range_argument);
  END_IF;
  IF 'IMPORTED_POINT_FUNCTION' IN typenames THEN
      temp := dimension_of (func\imported_point_function.geometry);
    RETURN (one_tuples_of (make_uniform_product_space (the_reals, temp)));
  END_IF;
  IF 'IMPORTED_CURVE_FUNCTION' IN typenames THEN
      temp := dimension_of (func\imported_curve_function.geometry);
    RETURN (one_tuples_of (make_uniform_product_space (the_reals, temp)));
  END_IF;
  IF 'IMPORTED_SURFACE_FUNCTION' IN typenames THEN
      temp := dimension_of (func\imported_surface_function.geometry);
    RETURN (one_tuples_of (make_uniform_product_space (the_reals, temp)));
  END_IF;
  IF 'IMPORTED_VOLUME_FUNCTION' IN typenames THEN
      temp := dimension_of (func\imported_volume_function.geometry);
    RETURN (one_tuples_of (make_uniform_product_space (the_reals, temp)));
  END_IF;
  IF 'APPLICATION_DEFINED_FUNCTION' IN typenames THEN
    RETURN (func\application_defined_function.explicit_range);
  END_IF;
  -- Unreachable, as no other subtypes of maths_function are permissible without
  -- first modifying this function to account for them.
  RETURN (?);
END_FUNCTION;

FUNCTION dimension_of
	(item: geometric_representation_item) : dimension_count;
  LOCAL
    x   : SET OF representation;
    y   : representation_context;
    dim : dimension_count;
  END_LOCAL;
  -- For cartesian_point, direction, or vector dimension is determined by
  -- counting components.
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT' IN TYPEOF(item) THEN
       dim := SIZEOF(item\cartesian_point.coordinates);
       RETURN(dim);
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIRECTION' IN TYPEOF(item) THEN
       dim := SIZEOF(item\direction.direction_ratios);
       RETURN(dim);
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VECTOR' IN TYPEOF(item) THEN
       dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
       RETURN(dim);
    END_IF;
  -- For all other types of geometric_representation_item dim is obtained
  -- via context.
  -- Find the set of representation in which the item is used. 

  x := using_representations(item);

  -- Determines the dimension_count of the 
  -- geometric_representation_context. Note that the 
  -- RULE compatible_dimension ensures that the context_of_items
  -- is of type geometric_representation_context and has
  -- the same dimension_count for all values of x.
  -- The SET x is non-empty since this is required by WR1 of
  -- representation_item.
    y := x[1].context_of_items;
    dim := y\geometric_representation_context.coordinate_space_dimension;
    RETURN (dim);
END_FUNCTION;

FUNCTION dimensions_for_si_unit
	(n: si_unit_name) : dimensional_exponents;
CASE n OF 
      metre:
        RETURN (dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      gram:
        RETURN (dimensional_exponents(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      second:
        RETURN (dimensional_exponents(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
      ampere:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
      kelvin:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
      mole:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
      candela:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
      radian:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      steradian:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      hertz:
        RETURN (dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
      newton:
        RETURN (dimensional_exponents(1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      pascal:
        RETURN (dimensional_exponents(-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      joule:
        RETURN (dimensional_exponents(2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      watt:
        RETURN (dimensional_exponents(2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));
      coulomb:
        RETURN (dimensional_exponents(0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
      volt:
        RETURN (dimensional_exponents(2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));
      farad:
        RETURN (dimensional_exponents(-2.0, -1.0, 4.0, 1.0, 0.0, 0.0, 0.0));
      ohm:
        RETURN (dimensional_exponents(2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));
      siemens:
        RETURN (dimensional_exponents(-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
      weber:
        RETURN (dimensional_exponents(2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
      tesla:
        RETURN (dimensional_exponents(0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
      henry:
        RETURN (dimensional_exponents(2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));
      degree_Celsius:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
      lumen:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
      lux:
        RETURN (dimensional_exponents(-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
      becquerel:
        RETURN (dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
      gray:
        RETURN (dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      sievert:
        RETURN (dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      OTHERWISE:
        RETURN (?);
    END_CASE;
END_FUNCTION;

FUNCTION domain_from
	(ref: maths_space_or_function) : tuple_space;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(ref);
    func      : maths_function;
  END_LOCAL;
  IF NOT EXISTS (ref) THEN  RETURN (?);  END_IF;
  IF 'TUPLE_SPACE' IN typenames THEN  RETURN (ref);                  END_IF;
  IF 'MATHS_SPACE' IN typenames THEN  RETURN (one_tuples_of (ref));  END_IF;
  func := ref;
  IF 'CONSTANT_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\constant_function.source_of_domain));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\selector_function.source_of_domain));
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\parallel_composed_function.source_of_domain));
  END_IF;
  RETURN (func.domain);
END_FUNCTION;

FUNCTION dot_count
	(str: STRING) : INTEGER;
  LOCAL
    n : INTEGER := 0;
  END_LOCAL;
  REPEAT i := 1 TO LENGTH (str);
    IF str[i] = '.' THEN  n := n + 1;  END_IF;
  END_REPEAT;
  RETURN (n);
END_FUNCTION;

FUNCTION dot_product
	(arg1: direction; arg2: direction) : REAL;
   LOCAL
     scalar : REAL;
     vec1, vec2: direction;
     ndim : INTEGER;
   END_LOCAL;
   
   IF NOT EXISTS (arg1) OR NOT EXISTS (arg2) THEN
     scalar := ?;
     (* When function is called with invalid data an indeterminate result
     is returned *)
   ELSE
     IF (arg1.dim <> arg2.dim) THEN
       scalar := ?;
     (* When function is called with invalid data an indeterminate result
     is returned *)
     ELSE
       BEGIN
         vec1   := normalise(arg1);
         vec2   := normalise(arg2);
         ndim   := arg1.dim;
         scalar := 0.0;
         REPEAT  i := 1 TO ndim;
           scalar := scalar +
                       vec1.direction_ratios[i]*vec2.direction_ratios[i];
         END_REPEAT;
       END;
     END_IF;
   END_IF;
   RETURN (scalar);
END_FUNCTION;

FUNCTION dotted_identifiers_syntax
	(str: STRING) : BOOLEAN;
  LOCAL
    k : positive_integer;
    m : positive_integer;
  END_LOCAL;
  IF NOT EXISTS (str) THEN  RETURN (FALSE);  END_IF;
  k := parse_express_identifier (str, 1);
  IF k = 1 THEN  RETURN (FALSE);  END_IF;
  REPEAT WHILE k <= LENGTH (str);
    IF (str[k] <> '.') OR (k = LENGTH (str)) THEN  RETURN (FALSE);  END_IF;
    m := parse_express_identifier (str, k+1);
    IF m = k + 1 THEN  RETURN (FALSE);  END_IF;
    k := m;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;

FUNCTION drop_numeric_constraints
	(spc: maths_space) : maths_space;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(spc);
    tspc : listed_product_space;
    factors : LIST OF maths_space := [];
    xspc : extended_tuple_space;
  END_LOCAL;
  IF 'UNIFORM_PRODUCT_SPACE' IN typenames THEN
    RETURN (make_uniform_product_space (drop_numeric_constraints (
      spc\uniform_product_space.base), spc\uniform_product_space.exponent));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN typenames THEN
    tspc := spc;
    REPEAT i := 1 TO SIZEOF (tspc.factors);
      INSERT (factors, drop_numeric_constraints (tspc.factors[i]), i-1);
    END_REPEAT;
    RETURN (make_listed_product_space (factors));
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN typenames THEN
    xspc := spc;
    RETURN (make_extended_tuple_space (drop_numeric_constraints (xspc.base),
      drop_numeric_constraints (xspc.extender)));
  END_IF;
  IF subspace_of_es (spc, es_numbers) THEN
    RETURN (number_superspace_of (spc));
  END_IF;
  RETURN (spc);
END_FUNCTION;

FUNCTION edge_reversed
	(an_edge: edge) : oriented_edge;
   LOCAL
     the_reverse : oriented_edge;
   END_LOCAL;

   IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_EDGE' IN TYPEOF (an_edge) ) THEN
     the_reverse  := dummy_tri ||
             edge(an_edge.edge_end, an_edge.edge_start) ||
             oriented_edge(an_edge\oriented_edge.edge_element,
                        NOT (an_edge\oriented_edge.orientation)) ;
   ELSE
     the_reverse := dummy_tri ||
             edge(an_edge.edge_end, an_edge.edge_start) ||
             oriented_edge(an_edge, FALSE);
   END_IF;
   RETURN (the_reverse);
END_FUNCTION;

FUNCTION enclose_cregion_in_pregion
	(crgn: cartesian_complex_number_region; centre: complex_number_literal) : polar_complex_number_region;
FUNCTION angle(a : REAL) : REAL;
    REPEAT WHILE a > PI;    a := a - 2.0*PI;  END_REPEAT;
    REPEAT WHILE a <= -PI;  a := a + 2.0*PI;  END_REPEAT;
    RETURN (a);
  END_FUNCTION;
  -- Determine whether a real is strictly within a real interval
  FUNCTION strictly_in(z    : REAL;
                       zitv : real_interval) : LOGICAL;
    RETURN ((NOT min_exists(zitv) OR (z > real_min(zitv))) AND
      (NOT max_exists(zitv) OR (z < real_max(zitv))));
  END_FUNCTION;
  -- Include direction in minmax collection
  PROCEDURE angle_minmax(    ab, a            : REAL;
                             a_in             : BOOLEAN;
                         VAR amin, amax       : REAL;
                         VAR amin_in, amax_in : BOOLEAN);
    a := angle(a - ab);
    IF amin = a THEN  amin_in := amin_in OR a_in;  END_IF;
    IF amin > a THEN  amin := a;  amin_in := a_in;  END_IF;
    IF amax = a THEN  amax_in := amax_in OR a_in;  END_IF;
    IF amax < a THEN  amax := a;  amax_in := a_in;  END_IF;
  END_PROCEDURE;
  -- Include distance in max collection
  PROCEDURE range_max(    r       : REAL;
                          incl    : BOOLEAN;
                      VAR rmax    : REAL;
                      VAR rmax_in : BOOLEAN);
    IF rmax = r THEN  rmax_in := rmax_in OR incl;   END_IF;
    IF rmax < r THEN  rmax := r;  rmax_in := incl;  END_IF;
  END_PROCEDURE;
  -- Include distance in min collection
  PROCEDURE range_min(    r       : REAL;
                          incl    : BOOLEAN;
                      VAR rmin    : REAL;
                      VAR rmin_in : BOOLEAN);
    IF rmin = r THEN  rmin_in := rmin_in OR incl;  END_IF;
    IF (rmin < 0.0) OR (rmin > r) THEN  rmin := r;  rmin_in := incl;  END_IF;
  END_PROCEDURE;
  LOCAL
    xitv, yitv : real_interval;
    is_xmin, is_xmax, is_ymin, is_ymax : BOOLEAN;
    xmin, xmax, ymin, ymax, xc, yc : REAL := 0.0;
    xmin_in, xmax_in, ymin_in, ymax_in : BOOLEAN := FALSE;
    rmin, rmax : REAL := -1.0;
    amin : REAL := 4.0;
    amax : REAL := -4.0;
    rmax_exists, outside : BOOLEAN := TRUE;
    rmin_in, rmax_in, amin_in, amax_in : BOOLEAN := FALSE;
    ab, a, r : REAL := 0.0;
    incl : BOOLEAN;
    ritv : real_interval;
    aitv : finite_real_interval;
    minclo, maxclo : open_closed := open;
  END_LOCAL;
  IF NOT EXISTS (crgn) OR NOT EXISTS (centre) THEN  RETURN (?);  END_IF;
  -- Extract elementary input information
  xitv := crgn.real_constraint;
  yitv := crgn.imag_constraint;
  xc := centre.real_part;
  yc := centre.imag_part;
  is_xmin := min_exists(xitv);
  is_xmax := max_exists(xitv);
  is_ymin := min_exists(yitv);
  is_ymax := max_exists(yitv);
  IF is_xmin THEN  xmin := real_min(xitv);  xmin_in := min_included(xitv);  END_IF;
  IF is_xmax THEN  xmax := real_max(xitv);  xmax_in := max_included(xitv);  END_IF;
  IF is_ymin THEN  ymin := real_min(yitv);  ymin_in := min_included(yitv);  END_IF;
  IF is_ymax THEN  ymax := real_max(yitv);  ymax_in := max_included(yitv);  END_IF;
  rmax_exists := is_xmin AND is_xmax AND is_ymin AND is_ymax;
  -- Identify base direction with respect to which all relevant directions lie
  -- within +/- 0.5*PI, or that the centre lies properly inside crgn.
  IF       is_xmin AND (xc <= xmin)  THEN  ab := 0.0;
  ELSE IF  is_ymin AND (yc <= ymin)  THEN  ab := 0.5*PI;
  ELSE IF  is_ymax AND (yc >= ymax)  THEN  ab := -0.5*PI;
  ELSE IF  is_xmax AND (xc >= xmax)  THEN  ab := PI;
  ELSE                                     outside := FALSE;
  END_IF;  END_IF;  END_IF;  END_IF;
  IF NOT outside AND NOT rmax_exists THEN
    RETURN (?);  -- No enclosing polar region exists (requires whole plane)
  END_IF;
  -- Identify any closest point on a side but not a corner.
  IF       is_xmin AND (xc <= xmin) AND strictly_in(yc,yitv) THEN
    rmin := xmin - xc;  rmin_in := xmin_in;
  ELSE IF  is_ymin AND (yc <= ymin) AND strictly_in(xc,xitv) THEN
    rmin := ymin - yc;  rmin_in := ymin_in;
  ELSE IF  is_ymax AND (yc >= ymax) AND strictly_in(xc,xitv) THEN
    rmin := yc - ymax;  rmin_in := ymax_in;
  ELSE IF  is_xmax AND (xc >= xmax) AND strictly_in(yc,yitv) THEN
    rmin := xc - xmax;  rmin_in := xmax_in;
  END_IF;  END_IF;  END_IF;  END_IF;
  IF is_xmin THEN
    IF is_ymin THEN  -- Consider lower left corner
      r := SQRT((xmin-xc)**2 + (ymin-yc)**2);
      incl := xmin_in AND ymin_in;
      IF rmax_exists THEN  range_max(r,incl,rmax,rmax_in);  END_IF;
      IF outside THEN
        IF r > 0.0 THEN
          range_min(r,incl,rmin,rmin_in);
          a := angle(atan2(ymin-yc,xmin-xc) - ab);
          IF xc = xmin THEN  incl := xmin_in;  END_IF;
          IF yc = ymin THEN  incl := ymin_in;  END_IF;
          angle_minmax(ab,a,incl,amin,amax,amin_in,amax_in);
        ELSE  -- Centre at lower left corner
          rmin := 0.0;                rmin_in := xmin_in AND ymin_in;
          amin := angle(0.0-ab);      amin_in := ymin_in;
          amax := angle(0.5*PI-ab);   amax_in := xmin_in;
        END_IF;
      END_IF;
    ELSE IF xc <= xmin THEN  -- Consider points near (xmin, -infinity)
      angle_minmax(ab,-0.5*PI,(xc=xmin) AND xmin_in,amin,amax,amin_in,amax_in);
    END_IF;  END_IF;
    IF NOT is_ymax AND (xc <= xmin) THEN  -- Consider points near (xmin, +infinity)
      angle_minmax(ab,0.5*PI,(xc=xmin) AND xmin_in,amin,amax,amin_in,amax_in);
    END_IF;
  END_IF;
  IF is_ymin THEN
    IF is_xmax THEN  -- Consider lower right corner
      r := SQRT((xmax-xc)**2 + (ymin-yc)**2);
      incl := xmax_in AND ymin_in;
      IF rmax_exists THEN  range_max(r,incl,rmax,rmax_in);  END_IF;
      IF outside THEN
        IF r > 0.0 THEN
          range_min(r,incl,rmin,rmin_in);
          a := angle(atan2(ymin-yc,xmax-xc) - ab);
          IF xc = xmax THEN  incl := xmax_in;  END_IF;
          IF yc = ymin THEN  incl := ymin_in;  END_IF;
          angle_minmax(ab,a,incl,amin,amax,amin_in,amax_in);
        ELSE  -- Centre at lower right corner
          rmin := 0.0;                rmin_in := xmax_in AND ymin_in;
          amin := angle(0.5*PI-ab);   amin_in := ymin_in;
          amax := angle(PI-ab);       amax_in := xmax_in;
        END_IF;
      END_IF;
    ELSE IF yc <= ymin THEN  -- Consider points near (+infinity, ymin)
      angle_minmax(ab,0.0,(yc=ymin) AND ymin_in,amin,amax,amin_in,amax_in);
    END_IF;  END_IF;
    IF NOT is_xmin AND (yc <= ymin) THEN  -- Consider points near (-infinity, ymin)
      angle_minmax(ab,PI,(yc=ymin) AND ymin_in,amin,amax,amin_in,amax_in);
    END_IF;
  END_IF;
  IF is_xmax THEN
    IF is_ymax THEN  -- Consider upper right corner
      r := SQRT((xmax-xc)**2 + (ymax-yc)**2);
      incl := xmax_in AND ymax_in;
      IF rmax_exists THEN  range_max(r,incl,rmax,rmax_in);  END_IF;
      IF outside THEN
        IF r > 0.0 THEN
          range_min(r,incl,rmin,rmin_in);
          a := angle(atan2(ymax-yc,xmax-xc) - ab);
          IF xc = xmax THEN  incl := xmax_in;  END_IF;
          IF yc = ymax THEN  incl := ymax_in;  END_IF;
          angle_minmax(ab,a,incl,amin,amax,amin_in,amax_in);
        ELSE  -- Centre at lower left corner
          rmin := 0.0;                rmin_in := xmax_in AND ymax_in;
          amin := angle(-PI-ab);      amin_in := ymax_in;
          amax := angle(-0.5*PI-ab);  amax_in := xmax_in;
        END_IF;
      END_IF;
    ELSE IF xc >= xmax THEN  -- Consider points near (xmax, +infinity)
      angle_minmax(ab,0.5*PI,(xc=xmax) AND xmax_in,amin,amax,amin_in,amax_in);
    END_IF;  END_IF;
    IF NOT is_ymin AND (xc >= xmax) THEN  -- Consider points near (xmax, -infinity)
      angle_minmax(ab,-0.5*PI,(xc=xmax) AND xmax_in,amin,amax,amin_in,amax_in);
    END_IF;
  END_IF;
  IF is_ymax THEN
    IF is_xmin THEN  -- Consider upper left corner
      r := SQRT((xmin-xc)**2 + (ymax-yc)**2);
      incl := xmin_in AND ymax_in;
      IF rmax_exists THEN  range_max(r,incl,rmax,rmax_in);  END_IF;
      IF outside THEN
        IF r > 0.0 THEN
          range_min(r,incl,rmin,rmin_in);
          a := angle(atan2(ymax-yc,xmin-xc) - ab);
          IF xc = xmin THEN  incl := xmin_in;  END_IF;
          IF yc = ymax THEN  incl := ymax_in;  END_IF;
          angle_minmax(ab,a,incl,amin,amax,amin_in,amax_in);
        ELSE  -- Centre at lower right corner
          rmin := 0.0;                rmin_in := xmin_in AND ymax_in;
          amin := angle(0.5*PI-ab);   amin_in := ymax_in;
          amax := angle(PI-ab);       amax_in := xmin_in;
        END_IF;
      END_IF;
    ELSE IF yc >= ymax THEN  -- Consider points near (-infinity, ymax)
      angle_minmax(ab,PI,(yc=ymax) AND ymax_in,amin,amax,amin_in,amax_in);
    END_IF;  END_IF;
    IF NOT is_xmax AND (yc >= ymax) THEN  -- Consider points near (+infinity, ymax)
      angle_minmax(ab,0.0,(yc=ymax) AND ymax_in,amin,amax,amin_in,amax_in);
    END_IF;
  END_IF;
  IF outside THEN  -- Change direction origin from ab back to zero
    amin := angle(amin+ab);
    IF amin = PI THEN  amin := -PI;  END_IF;
    amax := angle(amax+ab);
    IF amax <= amin THEN  amax := amax + 2.0*PI;  END_IF;
  ELSE
    amin := -PI;  amin_in := FALSE;
    amax := PI;   amax_in := FALSE;
  END_IF;
  IF amin_in THEN  minclo := closed;  END_IF;
  IF amax_in THEN  maxclo := closed;  END_IF;
  aitv := make_finite_real_interval(amin,minclo,amax,maxclo);
  minclo := open;
  IF rmin_in THEN  minclo := closed;  END_IF;
  IF rmax_exists THEN
    maxclo := open;
    IF rmax_in THEN  maxclo := closed;  END_IF;
    ritv := make_finite_real_interval(rmin,minclo,rmax,maxclo);
  ELSE
    ritv := make_real_interval_from_min(rmin,minclo);
  END_IF;
  RETURN (make_polar_complex_number_region(centre,ritv,aitv));
END_FUNCTION;

FUNCTION enclose_pregion_in_cregion
	(prgn: polar_complex_number_region) : cartesian_complex_number_region;
PROCEDURE nearest_good_direction(acart    : REAL;
                                   aitv     : finite_real_interval;
                                   VAR a    : REAL;
                                   VAR a_in : BOOLEAN);
    a := acart;                    a_in := TRUE;
    IF      a < aitv.min THEN
      -- a+2.0*PI > aitv.min automatically!
      IF a+2.0*PI < aitv.max THEN                               RETURN;  END_IF;
      IF a+2.0*PI = aitv.max THEN  a_in := max_included(aitv);  RETURN;  END_IF;
    ELSE IF a = aitv.min THEN      a_in := min_included(aitv);  RETURN;
    ELSE IF a < aitv.max THEN                                   RETURN;
    ELSE IF a = aitv.max THEN      a_in := max_included(aitv);  RETURN;
    END_IF;  END_IF;  END_IF;  END_IF;
    IF COS(acart - aitv.max) >= COS(acart - aitv.min) THEN
      a := aitv.max;               a_in := max_included(aitv);
    ELSE
      a := aitv.min;               a_in := min_included(aitv);
    END_IF;
  END_PROCEDURE;
  LOCAL
    xc, yc, xmin, xmax, ymin, ymax : REAL := 0.0;
    ritv, xitv, yitv : real_interval;
    aitv : finite_real_interval;
    xmin_exists, xmax_exists, ymin_exists, ymax_exists : BOOLEAN;
    xmin_in, xmax_in, ymin_in, ymax_in : BOOLEAN := FALSE;
    a, r : REAL := 0.0;
    a_in : BOOLEAN := FALSE;
    min_clo, max_clo : open_closed := open;
  END_LOCAL;
  IF NOT EXISTS (prgn) THEN  RETURN (?);  END_IF;
  -- Extract elementary input data
  xc := prgn.centre.real_part;
  yc := prgn.centre.imag_part;
  ritv := prgn.distance_constraint;
  aitv := prgn.direction_constraint;
  -- Determine xmin data
  nearest_good_direction(PI,aitv,a,a_in);
  IF COS(a) >= 0.0 THEN
    xmin_exists := TRUE;
    xmin := xc + real_min(ritv)*COS(a);
    xmin_in := a_in AND (min_included(ritv) OR (COS(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      xmin_exists := TRUE;
      xmin := xc + real_max(ritv)*COS(a);
      xmin_in := a_in AND max_included(ritv);
    ELSE
      xmin_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine xmax data
  nearest_good_direction(0.0,aitv,a,a_in);
  IF COS(a) <= 0.0 THEN
    xmax_exists := TRUE;
    xmax := xc + real_min(ritv)*COS(a);
    xmax_in := a_in AND (min_included(ritv) OR (COS(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      xmax_exists := TRUE;
      xmax := xc + real_max(ritv)*COS(a);
      xmax_in := a_in AND max_included(ritv);
    ELSE
      xmax_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine ymin data
  nearest_good_direction(-0.5*PI,aitv,a,a_in);
  IF SIN(a) >= 0.0 THEN
    ymin_exists := TRUE;
    ymin := yc + real_min(ritv)*SIN(a);
    ymin_in := a_in AND (min_included(ritv) OR (SIN(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      ymin_exists := TRUE;
      ymin := yc + real_max(ritv)*SIN(a);
      ymin_in := a_in AND max_included(ritv);
    ELSE
      ymin_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine ymax data
  nearest_good_direction(0.5*PI,aitv,a,a_in);
  IF SIN(a) <= 0.0 THEN
    ymax_exists := TRUE;
    ymax := yc + real_min(ritv)*SIN(a);
    ymax_in := a_in AND (min_included(ritv) OR (SIN(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      ymax_exists := TRUE;
      ymax := yc + real_max(ritv)*SIN(a);
      ymax_in := a_in AND max_included(ritv);
    ELSE
      ymax_exists := FALSE;
    END_IF;
  END_IF;
  -- Construct result
  IF NOT (xmin_exists OR xmax_exists OR ymin_exists OR ymax_exists) THEN
    RETURN (?);  -- No finite boundaries exist
  END_IF;
  -- Construct real_constraint
  IF xmin_exists THEN
    IF xmin_in THEN  min_clo := closed;  ELSE  min_clo := open;  END_IF;
    IF xmax_exists THEN
      IF xmax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      xitv := make_finite_real_interval(xmin,min_clo,xmax,max_clo);
    ELSE
      xitv := make_real_interval_from_min(xmin,min_clo);
    END_IF;
  ELSE
    IF xmax_exists THEN
      IF xmax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      xitv := make_real_interval_to_max(xmax,max_clo);
    ELSE
      xitv := the_reals;
    END_IF;
  END_IF;
  -- Construct imag_constraint
  IF ymin_exists THEN
    IF ymin_in THEN  min_clo := closed;  ELSE  min_clo := open;  END_IF;
    IF ymax_exists THEN
      IF ymax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      yitv := make_finite_real_interval(ymin,min_clo,ymax,max_clo);
    ELSE
      yitv := make_real_interval_from_min(ymin,min_clo);
    END_IF;
  ELSE
    IF ymax_exists THEN
      IF ymax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      yitv := make_real_interval_to_max(ymax,max_clo);
    ELSE
      yitv := the_reals;
    END_IF;
  END_IF;
  -- Construct cartesian region
  RETURN (make_cartesian_complex_number_region(xitv,yitv));
END_FUNCTION;

FUNCTION enclose_pregion_in_pregion
	(prgn: polar_complex_number_region; centre: complex_number_literal) : polar_complex_number_region;
FUNCTION angle(a : REAL) : REAL;
    REPEAT WHILE a > PI;    a := a - 2.0*PI;  END_REPEAT;
    REPEAT WHILE a <= -PI;  a := a + 2.0*PI;  END_REPEAT;
    RETURN (a);
  END_FUNCTION;
  -- Find proper limits for direction interval
  PROCEDURE angle_range(VAR amin, amax : REAL);
    amin := angle(amin);
    IF amin = PI THEN  amin := -PI;  END_IF;
    amax := angle(amax);
    IF amax <= amin THEN  amax := amax + 2.0*PI;  END_IF;
  END_PROCEDURE;
  -- Determine whether a direction is strictly within a direction interval
  FUNCTION strictly_in(a    : REAL;
                       aitv : finite_real_interval) : LOGICAL;
    a := angle(a);
    RETURN ({aitv.min < a < aitv.max} OR {aitv.min < a+2.0*PI < aitv.max});
  END_FUNCTION;
  -- Find min and max and related inclusion booleans among four candidates,
  -- using a base direction chosen to ensure the algebraic comparisons are valid.
  PROCEDURE find_aminmax(    ab,a0,a1,a2,a3  : REAL;
                             in0,in1,in2,in3 : BOOLEAN;
                         VAR amin,amax       : REAL;
                         VAR amin_in,amax_in : BOOLEAN);
    LOCAL
      a : REAL;
    END_LOCAL;
    amin := angle(a0-ab);                  amin_in := in0;
    amax := amin;                          amax_in := in0;
    a := angle(a1-ab);
    IF a = amin THEN                       amin_in := amin_in OR in1;  END_IF;
    IF a < amin THEN  amin := a;           amin_in := in1;             END_IF;
    IF a = amax THEN                       amax_in := amax_in OR in1;  END_IF;
    IF a > amax THEN  amax := a;           amax_in := in1;             END_IF;
    a := angle(a2-ab);
    IF a = amin THEN                       amin_in := amin_in OR in2;  END_IF;
    IF a < amin THEN  amin := a;           amin_in := in2;             END_IF;
    IF a = amax THEN                       amax_in := amax_in OR in2;  END_IF;
    IF a > amax THEN  amax := a;           amax_in := in2;             END_IF;
    a := angle(a3-ab);
    IF a = amin THEN                       amin_in := amin_in OR in3;  END_IF;
    IF a < amin THEN  amin := a;           amin_in := in3;             END_IF;
    IF a = amax THEN                       amax_in := amax_in OR in3;  END_IF;
    IF a > amax THEN  amax := a;           amax_in := in3;             END_IF;
    amin := amin+ab;
    amax := amax+ab;
    angle_range(amin,amax);
  END_PROCEDURE;

  LOCAL
    ritp, ritv : real_interval;
    aitp, aitv : finite_real_interval;
    xp, yp, xc, yc, rmax, rmin, amin, amax, rc, acp, apc : REAL := 0.0;
    rmax_in, rmin_in, amin_in, amax_in : BOOLEAN := FALSE;
    rmxp, rmnp, x, y, r, a, ab, r0, a0, r1, a1, r2, a2, r3, a3 : REAL := 0.0;
    in0, in1, in2, in3, inn : BOOLEAN := FALSE;
    minclo, maxclo : open_closed := open;
  END_LOCAL;
  -- Extract elementary input information
  IF NOT EXISTS (prgn) OR NOT EXISTS (centre) THEN  RETURN (?);  END_IF;
  xp := prgn.centre.real_part;
  yp := prgn.centre.imag_part;
  ritp := prgn.distance_constraint;
  aitp := prgn.direction_constraint;
  xc := centre.real_part;
  yc := centre.imag_part;
  IF (xc = xp) AND (yc = yp) THEN  RETURN (prgn);  END_IF;
  rc := SQRT((xp-xc)**2 + (yp-yc)**2);
  acp := atan2(yp-yc,xp-xc);
  apc := atan2(yc-yp,xc-xp);
  rmnp := real_min(ritp);
  -- Analyse cases by existence of max distance and direction limits
  IF max_exists(ritp) THEN
    rmxp := real_max(ritp);
    IF aitp.max - aitp.min = 2.0*PI THEN
      -- annulus or disk, with or without slot or puncture
      inn := NOT max_included(aitp);  -- slot exists;
      a := angle(aitp.min);  -- slot direction
      rmax := rc+rmxp;                    rmax_in := max_included(ritp);
      IF inn AND (acp = a) THEN  rmax_in := FALSE;  END_IF;
      IF rc > rmxp THEN
        a0 := ASIN(rmxp/rc);
        amin := angle(acp-a0);            amin_in := max_included(ritp);
        IF amin = PI THEN  amin := -PI;  END_IF;
        amax := angle(acp+a0);            amax_in := amin_in;
        IF amax < amin THEN  amax := amax + 2.0*PI;  END_IF;
        rmin := rc-rmxp;                  rmin_in := amin_in;
        IF inn THEN
          -- slotted case
          IF apc = a THEN  rmin_in := FALSE;  END_IF;
          IF angle(amin+0.5*PI) = a THEN  amin_in := FALSE;  END_IF;
          IF angle(amax-0.5*PI) = a THEN  amax_in := FALSE;  END_IF;
        END_IF;
      ELSE IF rc = rmxp THEN
        amin := angle(acp-0.5*PI);        amin_in := FALSE;
        IF amin = PI THEN  amin := -PI;  END_IF;
        amax := angle(acp+0.5*PI);        amax_in := FALSE;
        IF amax < amin THEN  amax := amax + 2.0*PI;  END_IF;
        rmin := 0.0;                      rmin_in := max_included(ritp);
        IF inn AND (apc = a) THEN  rmin_in := FALSE;  END_IF;
      ELSE IF rc > rmnp THEN
        IF inn AND (apc = a) THEN  -- in the slot
          rmin := 0.0;                    rmin_in := FALSE;
          amin := aitp.min;               amin_in := FALSE;
          amax := aitp.max;               amax_in := FALSE;
        ELSE
          rmin := 0.0;                    rmin_in := TRUE;
          amin := -PI;                    amin_in := FALSE;
          amax := PI;                     amax_in := TRUE;
        END_IF;
      ELSE
        rmin := rmnp-rc;                  rmin_in := min_included(ritp);
        amin := -PI;                      amin_in := FALSE;
        amax := PI;                       amax_in := TRUE;
        IF inn THEN  -- Special cases when aligned with slot
          IF apc = a THEN
                                          rmin_in := FALSE;
            amin := aitp.min;             amin_in := FALSE;
            amax := aitp.max;             amax_in := FALSE;
          ELSE IF acp = a THEN
            amin := aitp.min;             amin_in := FALSE;
            amax := aitp.max;             amax_in := FALSE;
          END_IF;  END_IF;
        END_IF;
      END_IF;  END_IF;  END_IF;
    ELSE  -- direction range < 2*PI
      -- Compute data for corners with respect to xc,yc
      x := xp + rmxp*cos(aitp.min) - xc;
      y := yp + rmxp*sin(aitp.min) - yc;
      r0 := SQRT(x**2 + y**2);
      in0 := max_included(ritp) AND min_included(aitp);
      IF r0 <> 0.0 THEN  a0 := atan2(y,x);  END_IF;
      x := xp + rmxp*cos(aitp.max) - xc;
      y := yp + rmxp*sin(aitp.max) - yc;
      r1 := SQRT(x**2 + y**2);
      in1 := max_included(ritp) AND max_included(aitp);
      IF r1 <> 0.0 THEN  a1 := atan2(y,x);  END_IF;
      x := xp + rmnp*cos(aitp.max) - xc;
      y := yp + rmnp*sin(aitp.max) - yc;
      r2 := SQRT(x**2 + y**2);
      in2 := min_included(ritp) AND max_included(aitp);
      IF r2 <> 0.0 THEN  a2 := atan2(y,x);  ELSE  a2 := a1;  in2 := in1;  END_IF;
      IF r1 = 0.0 THEN  a1 := a2;  in1 := in2;  END_IF;
      x := xp + rmnp*cos(aitp.min) - xc;
      y := yp + rmnp*sin(aitp.min) - yc;
      r3 := SQRT(x**2 + y**2);
      in3 := min_included(ritp) AND min_included(aitp);
      IF r3 <> 0.0 THEN  a3 := atan2(y,x);  ELSE  a3 := a0;  in3 := in0;  END_IF;
      IF r0 = 0.0 THEN  a0 := a3;  in0 := in3;  END_IF;
      IF rmnp = 0.0 THEN  in2 := min_included(ritp);  in3 := in2;  END_IF;
      IF (apc = angle(aitp.min)) OR (acp = angle(aitp.min)) THEN
        in0 := min_included(aitp);
        in3 := in0;
      ELSE IF (apc = angle(aitp.max)) OR (acp = angle(aitp.max)) THEN
        in1 := max_included(aitp);
        in2 := in1;
      END_IF;  END_IF;
      -- Find rmax
      IF strictly_in(acp,aitp) THEN
        rmax := rc+rmxp;                  rmax_in := max_included(ritp);
      ELSE
        rmax := r0;                       rmax_in := in0;
        IF rmax = r1 THEN                 rmax_in := rmax_in OR in1;  END_IF;
        IF rmax < r1 THEN  rmax := r1;    rmax_in := in1;             END_IF;
        IF rmax = r2 THEN                 rmax_in := rmax_in OR in2;  END_IF;
        IF rmax < r2 THEN  rmax := r2;    rmax_in := in2;             END_IF;
        IF rmax = r3 THEN                 rmax_in := rmax_in OR in3;  END_IF;
        IF rmax < r3 THEN  rmax := r3;    rmax_in := in3;             END_IF;
      END_IF;
      -- Find rmin
      IF strictly_in(apc,aitp) THEN
        IF rc >= rmxp THEN
          rmin := rc-rmxp;                rmin_in := max_included(ritp);
        ELSE IF rc <= rmnp THEN
          rmin := rmnp-rc;                rmin_in := min_included(ritp);
        ELSE
          rmin := 0.0;                    rmin_in := TRUE;
        END_IF;  END_IF;
      ELSE
        rmin := r0;                       rmin_in := in0;
        a := apc-aitp.min;
        r := rc*COS(a);
        IF {rmnp < r < rmxp} THEN  -- use nearest point on line segment
          rmin := rc*SIN(ABS(a));         rmin_in := min_included(aitp);
        END_IF;
        a := apc-aitp.max;
        r := rc*COS(a);
        IF {rmnp < r < rmxp} THEN  -- try nearest point on line segment
          r := rc*SIN(ABS(a));            inn := max_included(aitp);
          IF r = rmin THEN                rmin_in := rmin_in OR inn;  END_IF;
          IF r < rmin THEN  rmin := r;    rmin_in := inn;             END_IF;
        END_IF;
        IF r1 = rmin THEN                 rmin_in := rmin_in OR in1;  END_IF;
        IF r1 < rmin THEN  rmin := r1;    rmin_in := in1;             END_IF;
        IF r2 = rmin THEN                 rmin_in := rmin_in OR in2;  END_IF;
        IF r2 < rmin THEN  rmin := r2;    rmin_in := in2;             END_IF;
        IF r3 = rmin THEN                 rmin_in := rmin_in OR in3;  END_IF;
        IF r3 < rmin THEN  rmin := r3;    rmin_in := in3;             END_IF;
      END_IF;
      -- Find amin and amax, initially with respect to base direction ab.
      IF rc >= rmxp THEN  -- outside outer circle
        ab := acp;
        find_aminmax(ab,a0,a1,a2,a3,in0,in1,in2,in3,amin,amax,amin_in,amax_in);
        a := ACOS(rmxp/rc);
        IF strictly_in(apc-a,aitp) THEN
          amin := ab-ASIN(rmxp/rc);       amin_in := max_included(ritp);
        END_IF;
        IF strictly_in(apc+a,aitp) THEN
          amax := ab+ASIN(rmxp/rc);       amax_in := max_included(ritp);
        END_IF;
        angle_range(amin,amax);
      ELSE IF rc > rmnp THEN
        ab := angle(0.5*(aitp.min+aitp.max));  -- reference direction
        find_aminmax(ab,a0,a1,a2,a3,in0,in1,in2,in3,amin,amax,amin_in,amax_in);
      ELSE
        -- Using base direction midway in prgn, compute all directions using
        -- values which ensure a3 < a2 and a0 < a1 algebraically.
        ab := angle(0.5*(aitp.min+aitp.max));  -- reference direction
        a0 := angle(a0-ab);
        a1 := angle(a1-ab);
        a2 := angle(a2-ab);
        a3 := angle(a3-ab);
        IF a3 > a2 THEN  a2 := a2 + 2.0*PI;  END_IF;
        IF a0 > a1 THEN  a0 := a0 + 2.0*PI;  END_IF;
        IF a3 < a0 THEN  amin := a3;      amin_in := in3;
        ELSE             amin := a0;      amin_in := in0;  END_IF;
        IF a2 > a1 THEN  amax := a2;      amax_in := in2;
        ELSE             amax := a1;      amax_in := in1;  END_IF;
        IF (amax - amin > 2.0*PI) OR
          ((amax - amin = 2.0*PI) AND (amin_in OR amax_in)) THEN
          -- Cannot see out
          amin := -PI;                    amin_in := FALSE;
          amax := PI;                     amax_in := TRUE;
        ELSE
          amin := amin + ab;
          amax := amax + ab;
          angle_range(amin,amax);
        END_IF;
      END_IF;  END_IF;
    END_IF;
    IF rmin_in THEN  minclo := closed;  END_IF;
    IF rmax_in THEN  maxclo := closed;  END_IF;
    ritv := make_finite_real_interval(rmin,minclo,rmax,maxclo);
  ELSE  -- Not max_exists(ritp)
    IF (rc > rmnp) AND strictly_in(apc,aitp) THEN
      RETURN (?);  -- No pregion exists.  (Would require whole plane.)
    END_IF;
    IF aitp.max - aitp.min = 2.0*PI THEN
      -- complement of disk, with or without slot
      a := angle(aitp.min);  -- slot direction
      IF rc > rmnp THEN  -- already excluded if not aligned with slot
        IF max_included(aitp) THEN
          RETURN (?);  -- No pregion exists.  (Would require whole plane.)
        END_IF;
        rmin := 0.0;                      rmin_in := FALSE;
        amin := aitp.min;                 amin_in := FALSE;
        amax := aitp.max;                 amax_in := FALSE;
      ELSE
        rmin := rmnp-rc;                  rmin_in := min_included(ritp);
        amin := -PI;                      amin_in := FALSE;
        amax := PI;                       amax_in := TRUE;
        IF NOT max_included(aitp) THEN  -- Special cases when aligned with slot
          IF apc = a THEN
                                          rmin_in := FALSE;
            amin := aitp.min;             amin_in := FALSE;
            amax := aitp.max;             amax_in := FALSE;
          ELSE IF acp = a THEN
            amin := aitp.min;             amin_in := FALSE;
            amax := aitp.max;             amax_in := FALSE;
          END_IF;  END_IF;
        END_IF;
      END_IF;
    ELSE  -- direction range < 2*PI
      -- Compute data for corners with respect to xc,yc (two at infinity)
      a0 := angle(aitp.min);
      in0 := FALSE;
      a1 := angle(aitp.max);
      in1 := FALSE;
      x := xp + rmnp*cos(aitp.max) - xc;
      y := yp + rmnp*sin(aitp.max) - yc;
      r2 := SQRT(x**2 + y**2);
      in2 := min_included(ritp) AND max_included(aitp);
      IF r2 <> 0.0 THEN  a2 := atan2(y,x);  ELSE  a2 := a1;  in2 := in1;  END_IF;
      x := xp + rmnp*cos(aitp.min) - xc;
      y := yp + rmnp*sin(aitp.min) - yc;
      r3 := SQRT(x**2 + y**2);
      in3 := min_included(ritp) AND min_included(aitp);
      IF r3 <> 0.0 THEN  a3 := atan2(y,x);  ELSE  a3 := a0;  in3 := in0;  END_IF;
      IF rmnp = 0.0 THEN  in2 := min_included(ritp);  in3 := in2;  END_IF;
      IF (apc = angle(aitp.min)) OR (acp = angle(aitp.min)) THEN
        in0 := min_included(aitp);
        in3 := in0;
      ELSE IF (apc = angle(aitp.max)) OR (acp = angle(aitp.max)) THEN
        in1 := max_included(aitp);
        in2 := in1;
      END_IF;  END_IF;
      -- Find rmin
      IF strictly_in(apc,aitp) THEN
        rmin := rmnp-rc;                  rmin_in := min_included(ritp);
      ELSE
        rmin := r2;                       rmin_in := in2;
        a := apc-aitp.min;
        r := rc*COS(a);
        IF rmnp < r THEN  -- use nearest point on aitp.min ray
          rmin := rc*SIN(ABS(a));         rmin_in := min_included(aitp);
        END_IF;
        a := apc-aitp.max;
        r := rc*COS(a);
        IF rmnp < r THEN  -- try nearest point on aitp.max ray
          r := rc*SIN(ABS(a));            inn := max_included(aitp);
          IF r = rmin THEN                rmin_in := rmin_in OR inn;  END_IF;
          IF r < rmin THEN  rmin := r;    rmin_in := inn;             END_IF;
        END_IF;
        IF r3 = rmin THEN                 rmin_in := rmin_in OR in3;  END_IF;
        IF r3 < rmin THEN  rmin := r3;    rmin_in := in3;             END_IF;
      END_IF;
      -- Find amin and amax
      ab := angle(0.5*(aitp.min+aitp.max));  -- reference direction
      IF rc > rmnp THEN
        find_aminmax(ab,a0,a1,a2,a3,in0,in1,in2,in3,amin,amax,amin_in,amax_in);
      ELSE
        -- Using base direction midway in prgn, compute all directions using
        -- values which ensure a3 < a2 and a0 < a1 algebraically.
        a0 := angle(a0-ab);
        a1 := angle(a1-ab);
        a2 := angle(a2-ab);
        a3 := angle(a3-ab);
        IF a3 > a2 THEN  a2 := a2 + 2.0*PI;  END_IF;
        IF a0 > a1 THEN  a0 := a0 + 2.0*PI;  END_IF;
        IF a3 < a0 THEN  amin := a3;      amin_in := in3;
        ELSE             amin := a0;      amin_in := in0;  END_IF;
        IF a2 > a1 THEN  amax := a2;      amax_in := in2;
        ELSE             amax := a1;      amax_in := in1;  END_IF;
        IF (amax - amin > 2.0*PI) OR
          ((amax - amin = 2.0*PI) AND (amin_in OR amax_in)) THEN
          -- Cannot see out
          amin := -PI;                    amin_in := FALSE;
          amax := PI;                     amax_in := TRUE;
          IF (rmin = 0.0) AND rmin_in THEN
            RETURN (?);  -- No pregion exists.  (Would require whole plane.)
          END_IF;
        ELSE
          amin := amin + ab;
          amax := amax + ab;
          angle_range(amin,amax);
        END_IF;
      END_IF;
    END_IF;
    IF rmin_in THEN  minclo := closed;  END_IF;
    ritv := make_real_interval_from_min(rmin,minclo);
  END_IF;
  minclo := open;  maxclo := open;
  IF amin_in THEN  minclo := closed;  END_IF;
  IF amax_in THEN  maxclo := closed;  END_IF;
  aitv := make_finite_real_interval(amin,minclo,amax,maxclo);
  -- Construct polar region
  RETURN (make_polar_complex_number_region(centre,ritv,aitv));
END_FUNCTION;

FUNCTION equal_cregion_pregion
	(crgn: cartesian_complex_number_region; prgn: polar_complex_number_region) : LOGICAL;
  LOCAL
    arng, amin, xc, yc : REAL;
    aitv, xitv, yitv : real_interval;
    c_in : BOOLEAN;
  END_LOCAL;
  IF NOT EXISTS (crgn) OR NOT EXISTS (prgn) THEN  RETURN (FALSE);  END_IF;
  IF max_exists(prgn.distance_constraint) THEN  RETURN (FALSE);  END_IF;
  IF real_min(prgn.distance_constraint) <> 0.0 THEN  RETURN (FALSE);  END_IF;
  c_in := min_included(prgn.distance_constraint);
  aitv := prgn.direction_constraint;
  amin := aitv.min;
  arng := aitv.max - amin;
  xc := prgn.centre.real_part;
  yc := prgn.centre.imag_part;
  xitv := crgn.real_constraint;
  yitv := crgn.imag_constraint;
  IF arng = 0.5*PI THEN
    IF amin = 0.0 THEN  -- quadrant to upper right
      RETURN (NOT max_exists(xitv) AND NOT max_exists(yitv) AND min_exists(xitv)
        AND min_exists(yitv) AND (real_min(xitv) = xc) AND (real_min(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND NOT min_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND NOT min_included(yitv))));
    END_IF;
    IF amin = 0.5*PI THEN  -- quadrant to upper left
      RETURN (max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv)
        AND min_exists(yitv) AND (real_max(xitv) = xc) AND (real_min(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND NOT min_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND NOT min_included(yitv))));
    END_IF;
    IF amin = -PI THEN  -- quadrant to lower left
      RETURN (max_exists(xitv) AND max_exists(yitv) AND NOT min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_max(xitv) = xc) AND (real_max(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND NOT max_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND NOT max_included(yitv))));
    END_IF;
    IF amin = -0.5*PI THEN  -- quadrant to lower right
      RETURN (NOT max_exists(xitv) AND max_exists(yitv) AND min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_min(xitv) = xc) AND (real_max(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND NOT max_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND NOT max_included(yitv))));
    END_IF;
  END_IF;
  IF arng = PI THEN
    IF amin = 0.0 THEN  -- upper half space
      RETURN (NOT max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv)
        AND min_exists(yitv) AND (real_min(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(yitv))));
    END_IF;
    IF amin = 0.5*PI THEN  -- left half space
      RETURN (max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_max(xitv) = xc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(xitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv))));
    END_IF;
    IF amin = -PI THEN  -- lower half space
      RETURN (NOT max_exists(xitv) AND max_exists(yitv) AND NOT min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_max(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(yitv))));
    END_IF;
    IF amin = -0.5*PI THEN  -- right half space
      RETURN (NOT max_exists(xitv) AND NOT max_exists(yitv) AND min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_min(xitv) = xc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(xitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv))));
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

FUNCTION equal_maths_functions
	(fun1: maths_function; fun2: maths_function) : LOGICAL;
  LOCAL
    cum : LOGICAL;
  END_LOCAL;
  IF fun1 = fun2 THEN  RETURN (TRUE);   END_IF;
  cum := equal_maths_spaces(fun1.domain,fun2.domain);
  IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
  cum := cum AND equal_maths_spaces(fun1.range,fun2.range);
  IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
  -- A lot of further analysis is possible, but not required.
  RETURN (UNKNOWN);
END_FUNCTION;

FUNCTION equal_maths_spaces
	(spc1: maths_space; spc2: maths_space) : LOGICAL;
  LOCAL
    spc1types : SET OF STRING := stripped_typeof(spc1);
    spc2types : SET OF STRING := stripped_typeof(spc2);
    set1, set2 : SET OF maths_value;
    cum : LOGICAL := TRUE;
    base : maths_space;
    expnt : INTEGER;
    factors : LIST OF maths_space;
    factors2 : LIST OF maths_space;
    fs1, fs2 : function_space;
    cum2 : LOGICAL;
  END_LOCAL;
  IF spc1 = spc2 THEN  RETURN (TRUE);  END_IF;
  -- Consider cases where it is not yet certain that spc1 <> spc2.
  IF 'FINITE_SPACE' IN spc1types THEN
    set1 := spc1\finite_space.members;
    IF 'FINITE_SPACE' IN spc2types THEN
      -- Members may have different but equivalent representations and in
      -- different orders.  May also have disguised repeats in same set of members.
      set2 := spc2\finite_space.members;
      REPEAT i := 1 TO SIZEOF (set1);
        cum := cum AND member_of (set1[i], spc2);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      IF cum = TRUE THEN
        REPEAT i := 1 TO SIZEOF (set2);
          cum := cum AND member_of (set2[i], spc1);
          IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
        END_REPEAT;
      END_IF;
      RETURN (cum);
    END_IF;
    IF 'FINITE_INTEGER_INTERVAL' IN spc2types THEN
      set2 := [];
      REPEAT i := spc2\finite_integer_interval.min TO spc2\finite_integer_interval.max;
        set2 := set2 + [i];
      END_REPEAT;
      RETURN (equal_maths_spaces(spc1,make_finite_space(set2)));
    END_IF;
  END_IF;
  IF ('FINITE_INTEGER_INTERVAL' IN spc1types) AND ('FINITE_SPACE' IN spc2types) THEN
    set1 := [];
    REPEAT i := spc1\finite_integer_interval.min TO spc1\finite_integer_interval.max;
      set1 := set1 + [i];
    END_REPEAT;
    RETURN (equal_maths_spaces(make_finite_space(set1),spc2));
  END_IF;
  IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN spc1types) AND
    ('POLAR_COMPLEX_NUMBER_REGION' IN spc2types) THEN
    -- Quadrants and half spaces have two representations
    RETURN (equal_cregion_pregion(spc1,spc2));
  END_IF;
  IF ('POLAR_COMPLEX_NUMBER_REGION' IN spc1types) AND
    ('CARTESIAN_COMPLEX_NUMBER_REGION' IN spc2types) THEN
    -- Quadrants and half spaces have two representations
    RETURN (equal_cregion_pregion(spc2,spc1));
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN spc1types THEN
    base := spc1\uniform_product_space.base;
    expnt := spc1\uniform_product_space.exponent;
    IF 'UNIFORM_PRODUCT_SPACE' IN spc2types THEN
      IF expnt <> spc2\uniform_product_space.exponent THEN  RETURN (FALSE);  END_IF;
      RETURN (equal_maths_spaces(base,spc2\uniform_product_space.base));
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN spc2types THEN
      factors := spc2\listed_product_space.factors;
      IF expnt <> SIZEOF (factors) THEN  RETURN (FALSE);  END_IF;
      REPEAT i := 1 TO SIZEOF (factors);
        cum := cum AND equal_maths_spaces(base,factors[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN spc1types THEN
    factors := spc1\listed_product_space.factors;
    IF 'UNIFORM_PRODUCT_SPACE' IN spc2types THEN
      IF spc2\uniform_product_space.exponent <> SIZEOF (factors) THEN
        RETURN (FALSE);
      END_IF;
      base := spc2\uniform_product_space.base;
      REPEAT i := 1 TO SIZEOF (factors);
        cum := cum AND equal_maths_spaces(base,factors[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN spc2types THEN
      factors2 := spc2\listed_product_space.factors;
      IF SIZEOF (factors) <> SIZEOF (factors2) THEN  RETURN (FALSE);  END_IF;
      REPEAT i := 1 TO SIZEOF (factors);
        cum := cum AND equal_maths_spaces(factors[i],factors2[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
  END_IF;
  IF ('EXTENDED_TUPLE_SPACE' IN spc1types) AND
    ('EXTENDED_TUPLE_SPACE' IN spc2types) THEN
    RETURN (equal_maths_spaces(spc1\extended_tuple_space.extender,
      spc2\extended_tuple_space.extender) AND equal_maths_spaces(
      spc1\extended_tuple_space.base, spc2\extended_tuple_space.base));
  END_IF;
  IF ('FUNCTION_SPACE' IN spc1types) AND
    ('FUNCTION_SPACE' IN spc2types) THEN
    fs1 := spc1;
    fs2 := spc2;
    IF fs1.domain_constraint <> fs2.domain_constraint THEN
      IF (fs1.domain_constraint = sc_equal) OR (fs2.domain_constraint = sc_equal) THEN
        RETURN (FALSE);
      END_IF;
      IF (fs1.domain_constraint <> sc_subspace) THEN
        fs1 := spc2;
        fs2 := spc1;
      END_IF;
      IF (fs1.domain_constraint <> sc_subspace) OR
        (fs2.domain_constraint <> sc_member) THEN
        -- Safety check.  Should be unreachable.
        RETURN (UNKNOWN);
      END_IF;
      IF any_space_satisfies(fs1.domain_constraint,fs1.domain_argument) <>
        any_space_satisfies(fs2.domain_constraint,fs2.domain_argument) THEN
        RETURN (FALSE);
      END_IF;
      IF NOT ('FINITE_SPACE' IN stripped_typeof(fs2.domain_argument)) THEN
        RETURN (FALSE);
      END_IF;
      IF SIZEOF (['FINITE_SPACE','FINITE_INTEGER_INTERVAL'] *
        stripped_typeof(fs1.domain_argument)) = 0 THEN
        RETURN (FALSE);
      END_IF;
      -- Remaining cases too complex.
      RETURN (UNKNOWN);
    END_IF;
    cum := equal_maths_spaces(fs1.domain_argument,fs2.domain_argument);
    IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
    IF fs1.range_constraint <> fs2.range_constraint THEN
      IF (fs1.range_constraint = sc_equal) OR (fs2.range_constraint = sc_equal) THEN
        RETURN (FALSE);
      END_IF;
      IF (fs1.range_constraint <> sc_subspace) THEN
        fs1 := spc2;
        fs2 := spc1;
      END_IF;
      IF (fs1.range_constraint <> sc_subspace) OR
        (fs2.range_constraint <> sc_member) THEN
        -- Safety check.  Should be unreachable.
        RETURN (UNKNOWN);
      END_IF;
      IF any_space_satisfies(fs1.range_constraint,fs1.range_argument) <>
        any_space_satisfies(fs2.range_constraint,fs2.range_argument) THEN
        RETURN (FALSE);
      END_IF;
      IF NOT ('FINITE_SPACE' IN stripped_typeof(fs2.range_argument)) THEN
        RETURN (FALSE);
      END_IF;
      IF SIZEOF (['FINITE_SPACE','FINITE_INTEGER_INTERVAL'] *
        stripped_typeof(fs1.range_argument)) = 0 THEN
        RETURN (FALSE);
      END_IF;
      -- Remaining cases too complex.
      RETURN (UNKNOWN);
    END_IF;
    cum := cum AND equal_maths_spaces(fs1.range_argument,fs2.range_argument);
    RETURN (cum);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

FUNCTION equal_maths_values
	(val1: maths_value; val2: maths_value) : LOGICAL;
FUNCTION mem_of_vs(val1, val2 : maths_value) : LOGICAL;
    IF NOT has_values_space(val2) THEN RETURN (UNKNOWN);  END_IF;
    IF NOT member_of(val1,values_space_of(val2)) THEN  RETURN (FALSE);  END_IF;
    RETURN (UNKNOWN);
  END_FUNCTION;  -- mem_of_vs
  LOCAL
    types1, types2 : SET OF STRING;
    list1, list2 : LIST OF maths_value;
    cum : LOGICAL := TRUE;
  END_LOCAL;
  IF NOT EXISTS (val1) OR NOT EXISTS (val2) THEN  RETURN (FALSE);  END_IF;
  IF val1 = val2 THEN  RETURN (TRUE);  END_IF;
  types1 := stripped_typeof (val1);
  types2 := stripped_typeof (val2);
  IF ('MATHS_ATOM' IN types1) OR ('COMPLEX_NUMBER_LITERAL' IN types1) THEN
    IF 'MATHS_ATOM'             IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'COMPLEX_NUMBER_LITERAL' IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'LIST'                   IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'MATHS_SPACE'            IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'MATHS_FUNCTION'         IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'GENERIC_EXPRESSION' IN types2 THEN  RETURN (mem_of_vs(val1,val2)); END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF ('MATHS_ATOM' IN types2) OR ('COMPLEX_NUMBER_LITERAL' IN types2) THEN
    RETURN (equal_maths_values(val2,val1));
  END_IF;
  IF 'LIST' IN types1 THEN
    IF 'LIST' IN types2 THEN
      list1 := val1;
      list2 := val2;
      IF SIZEOF (list1) <> SIZEOF (list2) THEN  RETURN (FALSE);  END_IF;
      REPEAT i := 1 TO SIZEOF (list1);
        cum := cum AND equal_maths_values (list1[i], list2[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
    IF 'MATHS_SPACE'            IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'MATHS_FUNCTION'         IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'GENERIC_EXPRESSION' IN types2 THEN  RETURN (mem_of_vs(val1,val2)); END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF 'LIST' IN types2 THEN  RETURN (equal_maths_values(val2,val1));  END_IF;
  IF 'MATHS_SPACE' IN types1 THEN
    IF 'MATHS_SPACE' IN types2 THEN
      RETURN (equal_maths_spaces(val1,val2));
    END_IF;
    IF 'MATHS_FUNCTION'         IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'GENERIC_EXPRESSION' IN types2 THEN  RETURN (mem_of_vs(val1,val2)); END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF 'MATHS_SPACE' IN types2 THEN  RETURN (equal_maths_values(val2,val1));  END_IF;
  IF 'MATHS_FUNCTION' IN types1 THEN
    IF 'MATHS_FUNCTION' IN types2 THEN
      RETURN (equal_maths_functions(val1,val2));
    END_IF;
    IF 'GENERIC_EXPRESSION' IN types2 THEN  RETURN (mem_of_vs(val1,val2)); END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF 'MATHS_FUNCTION' IN types2 THEN  RETURN (equal_maths_values(val2,val1));  END_IF;
  IF ('GENERIC_EXPRESSION' IN types1) AND ('GENERIC_EXPRESSION' IN types2) THEN
    IF NOT has_values_space(val1) OR NOT has_values_space(val2) THEN
      RETURN (UNKNOWN);
    END_IF;
    IF NOT compatible_spaces(values_space_of(val1),values_space_of(val2)) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  RETURN (UNKNOWN);
END_FUNCTION;

FUNCTION es_subspace_of_es
	(es1: elementary_space_enumerators; es2: elementary_space_enumerators) : BOOLEAN;
IF NOT EXISTS (es1) OR NOT EXISTS (es2) THEN  RETURN (FALSE);  END_IF;
  IF es1 = es2 THEN  RETURN (TRUE);  END_IF;
  IF es2 = es_generics THEN  RETURN (TRUE);  END_IF;
  IF (es1 = es_booleans) AND (es2 = es_logicals) THEN  RETURN (TRUE);  END_IF;
  IF (es2 = es_numbers) AND ((es1 = es_complex_numbers) OR (es1 = es_reals) OR
    (es1 = es_integers)) THEN  RETURN (TRUE);  END_IF;
  RETURN (FALSE);
END_FUNCTION;

FUNCTION expression_is_constant
	(expr: generic_expression) : BOOLEAN;
RETURN (bool(SIZEOF (free_variables_of (expr)) = 0));
END_FUNCTION;

FUNCTION external_version_assignment_is_valid
	(aia: applied_external_identification_assignment) : BOOLEAN;
    LOCAL
      item: identification_item;
      role: identification_role;
    END_LOCAL;
      role:= aia.role;
      IF role.name='version' THEN
        REPEAT i:=LOINDEX(aia.items) TO HIINDEX(aia.items);
          item:= aia.items[i];
          IF (SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'EXTERNALLY_VERSIONED_ITEM']*TYPEOF(item))=0) THEN
            -- item invalid if item does not belong to versionable types
	        RETURN(FALSE);
          END_IF;
        END_REPEAT;
        RETURN(TRUE);
      ELSE		-- case where aia does not convey a version id
        RETURN(TRUE);
      END_IF;
END_FUNCTION;

FUNCTION extract_factors
	(tspace: tuple_space; m: INTEGER; n: INTEGER) : tuple_space;
  LOCAL
    tsp : tuple_space := the_zero_tuple_space;
  END_LOCAL;
  REPEAT i := m TO n;
    tsp := assoc_product_space (tsp, factor_space (tspace, i));
  END_REPEAT;
  RETURN (tsp);
END_FUNCTION;

FUNCTION extremal_position_check
	(fun: linearized_table_function) : BOOLEAN;
  LOCAL
    source_domain : maths_space;
    source_interval : finite_integer_interval;
    index : INTEGER := 1;
    base : INTEGER;
    shape : LIST OF positive_integer;
    ndim : positive_integer;
    slo, shi : INTEGER;
    sublo : LIST OF INTEGER := [];
    subhi : LIST OF INTEGER := [];
  END_LOCAL;
  IF NOT EXISTS (fun) THEN  RETURN (FALSE);  END_IF;
  source_domain := factor1 (fun.source.domain);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF (source_domain) THEN
    source_domain := factor1 (source_domain);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (source_domain)) THEN
    RETURN (FALSE);
  END_IF;
  source_interval := source_domain;
  base := fun\explicit_table_function.index_base;
  shape := fun\explicit_table_function.shape;
  IF (schema_prefix + 'STANDARD_TABLE_FUNCTION') IN TYPEOF (fun) THEN
    REPEAT j := 1 TO SIZEOF (shape);
      index := index * shape[j];
    END_REPEAT;
    index := fun.first + index - 1;
    RETURN (bool({source_interval.min <= index <= source_interval.max}));
  END_IF;
  IF (schema_prefix + 'REGULAR_TABLE_FUNCTION') IN TYPEOF (fun) THEN
    ndim := SIZEOF (fun\explicit_table_function.shape);
    REPEAT j:= 1 TO ndim;
      slo := base;
      shi := base + shape[j] - 1;
      IF fun\regular_table_function.increments[j] >= 0 THEN
        INSERT (sublo, slo, j-1);
        INSERT (subhi, shi, j-1);
      ELSE
        INSERT (sublo, shi, j-1);
        INSERT (subhi, slo, j-1);
      END_IF;
    END_REPEAT;
    index := regular_indexing (sublo, base, shape,
      fun\regular_table_function.increments, fun.first);
    IF NOT ({source_interval.min <= index <= source_interval.max}) THEN
      RETURN (FALSE);
    END_IF;
    index := regular_indexing (subhi, base, shape,
      fun\regular_table_function.increments, fun.first);
    IF NOT ({source_interval.min <= index <= source_interval.max}) THEN
      RETURN (FALSE);
    END_IF;
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

FUNCTION face_bound_reversed
	(a_face_bound: face_bound) : face_bound;
   LOCAL
     the_reverse : face_bound ;
   END_LOCAL;
   IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_OUTER_BOUND' IN TYPEOF (a_face_bound) ) THEN
     the_reverse := dummy_tri ||
                      face_bound(a_face_bound\face_bound.bound,
                           NOT (a_face_bound\face_bound.orientation))
                            || face_outer_bound() ;
   ELSE
     the_reverse := dummy_tri ||
         face_bound(a_face_bound.bound, NOT(a_face_bound.orientation));
   END_IF;
  RETURN (the_reverse);
END_FUNCTION;

FUNCTION face_reversed
	(a_face: face) : oriented_face;
   LOCAL
     the_reverse : oriented_face ;
   END_LOCAL;
   IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_FACE' IN TYPEOF (a_face) ) THEN
     the_reverse := dummy_tri ||
       face(set_of_topology_reversed(a_face.bounds)) ||
          oriented_face(a_face\oriented_face.face_element,
                           NOT (a_face\oriented_face.orientation)) ;
   ELSE
     the_reverse := dummy_tri ||
       face(set_of_topology_reversed(a_face.bounds)) ||
                               oriented_face(a_face, FALSE) ;
   END_IF;
      RETURN (the_reverse);
END_FUNCTION;

FUNCTION factor1
	(tspace: tuple_space) : maths_space;
  LOCAL
    typenames : SET OF STRING := TYPEOF (tspace);
  END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames THEN
    RETURN (tspace\uniform_product_space.base);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames THEN
    RETURN (tspace\listed_product_space.factors[1]);
    -- This path could return the indeterminate value if the list is empty.
    -- This is the correct result for this case.
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN typenames THEN
    RETURN (factor1 (tspace\extended_tuple_space.base));
  END_IF;
  -- Should not be reachable.
  RETURN (?);
END_FUNCTION;

FUNCTION factor_space
	(tspace: tuple_space; idx: positive_integer) : maths_space;
  LOCAL
    typenames : SET OF STRING := TYPEOF (tspace);
  END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames THEN
    IF idx <= tspace\uniform_product_space.exponent THEN
      RETURN (tspace\uniform_product_space.base);
    END_IF;
    RETURN (?);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames THEN
    IF idx <= SIZEOF (tspace\listed_product_space.factors) THEN
      RETURN (tspace\listed_product_space.factors[idx]);
    END_IF;
    RETURN (?);
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN typenames THEN
    IF idx <= space_dimension (tspace\extended_tuple_space.base) THEN
      RETURN (factor_space (tspace\extended_tuple_space.base, idx));
    END_IF;
    RETURN (tspace\extended_tuple_space.extender);
  END_IF;
  -- Should not be reachable.
  RETURN (?);
END_FUNCTION;

FUNCTION first_proj_axis
	(z_axis: direction; arg: direction) : direction;
  LOCAL
    x_axis : direction;
    v      : direction;
    z      : direction;
    x_vec  : vector;
  END_LOCAL;
  
  IF (NOT EXISTS(z_axis)) THEN
    RETURN (?) ;
  ELSE
    z := normalise(z_axis);
    IF NOT EXISTS(arg) THEN
      IF ((z.direction_ratios <> [1.0,0.0,0.0]) AND
          (z.direction_ratios <> [-1.0,0.0,0.0]))  THEN
        v :=  dummy_gri || direction([1.0,0.0,0.0]);
      ELSE
        v := dummy_gri || direction([0.0,1.0,0.0]);
      END_IF;
    ELSE
      IF  (arg.dim <> 3) THEN
        RETURN (?) ;
      END_IF;
      IF ((cross_product(arg,z).magnitude) = 0.0) THEN
        RETURN (?);
      ELSE
        v := normalise(arg);
      END_IF;
    END_IF;
    x_vec := scalar_times_vector(dot_product(v, z), z);
    x_axis := vector_difference(v, x_vec).orientation;
    x_axis := normalise(x_axis);
  END_IF;
  RETURN(x_axis);
END_FUNCTION;

FUNCTION free_variables_of
	(expr: generic_expression) : SET [0:?] OF generic_variable;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(expr);
    result : SET OF generic_variable := [];
    exprs : LIST OF generic_expression := [];
  END_LOCAL;
  IF 'GENERIC_LITERAL' IN typenames THEN
    RETURN (result);
  END_IF;
  IF 'GENERIC_VARIABLE' IN typenames THEN
    result := result + expr;
    RETURN (result);
  END_IF;
  IF 'QUANTIFIER_EXPRESSION' IN typenames THEN
    exprs := QUERY (ge <* expr\multiple_arity_generic_expression.operands |
      NOT (ge IN expr\quantifier_expression.variables));
    REPEAT i := 1 TO SIZEOF (exprs);
      result := result + free_variables_of (exprs[i]);
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF (expr\quantifier_expression.variables);
      result := result - expr\quantifier_expression.variables[i];
    END_REPEAT;
    RETURN (result);
  END_IF;
  IF 'UNARY_GENERIC_EXPRESSION' IN typenames THEN
    RETURN (free_variables_of (expr\unary_generic_expression.operand));
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN typenames THEN
    result := free_variables_of (expr\binary_generic_expression.operands[1]);
    RETURN (result + free_variables_of (expr\binary_generic_expression.operands[2]));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN typenames THEN
    REPEAT i := 1 TO SIZEOF (expr\multiple_arity_generic_expression.operands);
      result := result + free_variables_of (
        expr\multiple_arity_generic_expression.operands[i]);
    END_REPEAT;
    RETURN (result);
  END_IF;
  -- In this case the subtype shall not contain any variable (see IP1 in
  -- generic_expression).
  RETURN (result);
END_FUNCTION;

FUNCTION function_applicability
	(func: maths_function_select; arguments: LIST [1:?] OF maths_value) : BOOLEAN;
  LOCAL
    domain : tuple_space := convert_to_maths_function(func).domain;
    domain_types : SET OF STRING := TYPEOF (domain);
    narg : positive_integer := SIZEOF (arguments);
    arg : generic_expression;
  END_LOCAL;
  IF (schema_prefix + 'PRODUCT_SPACE') IN domain_types THEN
    IF space_dimension (domain) <> narg THEN  RETURN (FALSE);  END_IF;
  ELSE
    IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN domain_types THEN
      IF space_dimension (domain) > narg THEN  RETURN (FALSE);  END_IF;
    ELSE
      RETURN (FALSE);  -- Should be unreachable
    END_IF;
  END_IF;
  REPEAT i := 1 TO narg;
    arg := convert_to_operand (arguments[i]);
    IF NOT has_values_space (arg) THEN  RETURN (FALSE);  END_IF;
    IF NOT compatible_spaces (factor_space (domain, i), values_space_of (arg)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;

FUNCTION function_is_1d_array
	(func: maths_function) : BOOLEAN;
  LOCAL
    temp : maths_space;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  IF space_dimension (func.domain) <> 1 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (func.domain);
  IF (schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (temp) THEN
    IF space_dimension (temp) <> 1 THEN  RETURN (FALSE);  END_IF;
    temp := factor1 (temp);
  END_IF;
  IF (schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp) THEN
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

FUNCTION function_is_1d_table
	(func: maths_function) : BOOLEAN;
  LOCAL
    temp : maths_space;
    itvl : finite_integer_interval;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  IF space_dimension (func.domain) <> 1 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (func.domain);
  IF (schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (temp) THEN
    IF space_dimension (temp) <> 1 THEN  RETURN (FALSE);  END_IF;
    temp := factor1 (temp);
  END_IF;
  IF (schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp) THEN
    itvl := temp;
    RETURN (bool((itvl.min = 0) OR (itvl.min = 1)));
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

FUNCTION function_is_2d_table
	(func: maths_function) : BOOLEAN;
  LOCAL
    temp : maths_space;
    pspace : product_space;
    itvl1, itvl2 : finite_integer_interval;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  IF space_dimension (func.domain) <> 1 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (func.domain);
  IF NOT ('PRODUCT_SPACE' IN stripped_typeof(temp)) THEN  RETURN (FALSE);  END_IF;
  pspace := temp;
  IF space_dimension (pspace) <> 2 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (pspace);
  IF NOT ('FINITE_INTEGER_INTERVAL' IN stripped_typeof(temp)) THEN
    RETURN (FALSE);
  END_IF;
  itvl1 := temp;
  temp := factor_space (pspace, 2);
  IF NOT ('FINITE_INTEGER_INTERVAL' IN stripped_typeof(temp)) THEN
    RETURN (FALSE);
  END_IF;
  itvl2 := temp;
  RETURN (bool((itvl1.min = itvl2.min) AND ((itvl1.min = 0) OR (itvl1.min = 1))));
END_FUNCTION;

FUNCTION function_is_array
	(func: maths_function) : BOOLEAN;
  LOCAL
    tspace : tuple_space;
    temp : maths_space;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  tspace := func.domain;
  IF (space_dimension (tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (tspace))) THEN
    tspace := factor1 (tspace);
  END_IF;
  IF NOT ((schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (tspace)) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 1 TO space_dimension (tspace);
    temp := factor_space (tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;

FUNCTION function_is_table
	(func: maths_function) : BOOLEAN;
  LOCAL
    tspace : tuple_space;
    temp : maths_space;
    base : INTEGER;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  tspace := func.domain;
  IF (space_dimension (tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (tspace))) THEN
    tspace := factor1 (tspace);
  END_IF;
  IF NOT ((schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (tspace)) THEN
    RETURN (FALSE);
  END_IF;
  temp := factor1 (tspace);
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
    RETURN (FALSE);
  END_IF;
  base := temp\finite_integer_interval.min;
  IF (base <> 0) AND (base <> 1) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 2 TO space_dimension (tspace);
    temp := factor_space (tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
      RETURN (FALSE);
    END_IF;
    IF temp\finite_integer_interval.min <> base THEN  RETURN (FALSE);  END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;

FUNCTION gbsf_check_curve
	(cv: representation_item) : BOOLEAN;
IF SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BOUNDED_CURVE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONIC', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_REPLICA', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_CURVE_3D'] * TYPEOF(cv)) > 1 THEN
    RETURN (FALSE);
  END_IF;
  IF SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CIRCLE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELLIPSE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TRIMMED_CURVE'] * TYPEOF(cv)) = 1 THEN
    RETURN (TRUE);
  ELSE
    IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE' IN TYPEOF(cv)) AND (cv\b_spline_curve.self_intersect = FALSE) OR (cv\b_spline_curve.self_intersect = UNKNOWN)) THEN
      RETURN (TRUE);
    ELSE
      IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_CURVE' IN TYPEOF(cv)) AND (cv\composite_curve.self_intersect = FALSE) OR (cv\composite_curve.self_intersect = UNKNOWN)) THEN
        RETURN (SIZEOF(QUERY(seg <* cv\composite_curve.segments | NOT (gbsf_check_curve(seg.parent_curve)))) = 0);
      ELSE
        IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_REPLICA' IN TYPEOF(cv) THEN
          RETURN (gbsf_check_curve(cv\curve_replica.parent_curve));
        ELSE
          IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_CURVE_3D' IN TYPEOF(cv)) AND ((cv\offset_curve_3d.self_intersect = FALSE) OR (cv\offset_curve_3d.self_intersect = UNKNOWN)) AND (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN TYPEOF(cv\offset_curve_3d.basis_curve)))) THEN
            RETURN (gbsf_check_curve(cv\offset_curve_3d.basis_curve));
          ELSE
            IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN TYPEOF(cv) THEN
              RETURN ((gbsf_check_curve(cv\pcurve.reference_to_curve\representation.items[1])) AND (gbsf_check_surface(cv\pcurve.basis_surface)));
            ELSE
              IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN TYPEOF(cv) THEN
                IF (SIZEOF(cv\polyline.points) >= 3) THEN
                  RETURN (TRUE);
                END_IF;
              ELSE
                IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE' IN TYPEOF(cv) THEN
                  IF gbsf_check_curve(cv\surface_curve.curve_3d) THEN
                    REPEAT i := 1 TO SIZEOF(cv\surface_curve.associated_geometry);
                      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE' IN TYPEOF(cv\surface_curve.associated_geometry[i]) THEN
                        IF NOT gbsf_check_surface(cv\surface_curve.associated_geometry[i]) THEN
                          RETURN (FALSE);
                        END_IF;
                      ELSE
                        IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN TYPEOF(cv\surface_curve.associated_geometry[i]) THEN
                          IF NOT gbsf_check_curve(cv\surface_curve.associated_geometry[i]) THEN
                            RETURN (FALSE);
                          END_IF;
                        END_IF;
                      END_IF;
                    END_REPEAT;
                    RETURN (TRUE);
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

FUNCTION gbsf_check_point
	(pnt: point) : BOOLEAN;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
    RETURN (TRUE);
  ELSE
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_CURVE' IN TYPEOF(pnt) THEN
      RETURN (gbsf_check_curve(pnt\point_on_curve.basis_curve));
    ELSE
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_SURFACE' IN TYPEOF(pnt) THEN
        RETURN (gbsf_check_surface(pnt\point_on_surface.basis_surface));
      ELSE
        IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DEGENERATE_PCURVE' IN TYPEOF(pnt) THEN
          RETURN ((gbsf_check_curve(pnt\degenerate_pcurve.reference_to_curve\representation.items[1])) AND (gbsf_check_surface(pnt\degenerate_pcurve.basis_surface)));
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

FUNCTION gbsf_check_surface
	(sf: surface) : BOOLEAN;
IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_SURFACE' IN TYPEOF(sf)) AND (sf\b_spline_surface.self_intersect = FALSE) OR (sf\b_spline_surface.self_intersect = UNKNOWN)) THEN
    RETURN (TRUE);
  ELSE
    IF SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SPHERICAL_SURFACE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TOROIDAL_SURFACE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_BOUNDED_SURFACE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.RECTANGULAR_TRIMMED_SURFACE'] * TYPEOF(sf)) = 1 THEN
      RETURN (TRUE);
    ELSE
      IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_SURFACE' IN TYPEOF(sf)) AND (sf\offset_surface.self_intersect = FALSE) OR (sf\offset_surface.self_intersect = UNKNOWN)) THEN
        RETURN (gbsf_check_surface(sf\offset_surface.basis_surface));
      ELSE
        IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.RECTANGULAR_COMPOSITE_SURFACE' IN TYPEOF(sf) THEN
          REPEAT i := 1 TO SIZEOF(sf\rectangular_composite_surface.segments);
            REPEAT j := 1 TO SIZEOF(sf\rectangular_composite_surface.segments[i]);
              IF NOT (gbsf_check_surface(sf\rectangular_composite_surface.segments[i][j].parent_surface)) THEN
                RETURN (FALSE);
              END_IF;
            END_REPEAT;
          END_REPEAT;
          RETURN (TRUE);
        ELSE
          IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_REPLICA' IN TYPEOF(sf) THEN
            RETURN (gbsf_check_surface(sf\surface_replica.parent_surface));
          ELSE
            IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_OF_REVOLUTION' IN TYPEOF(sf) THEN
              RETURN (gbsf_check_curve(sf\swept_surface.swept_curve));
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

FUNCTION get_basis_surface
	(c: curve_on_surface) : SET [0:2] OF surface;
  LOCAL
    surfs  : SET[0:2] OF surface;
    n      : INTEGER;
  END_LOCAL;
  surfs := [];
  IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN TYPEOF (c) THEN
    surfs := [c\pcurve.basis_surface];
  ELSE
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE' IN TYPEOF (c) THEN
      n := SIZEOF(c\surface_curve.associated_geometry);
      REPEAT i := 1 TO n;
      surfs := surfs +
                associated_surface(c\surface_curve.associated_geometry[i]);
      END_REPEAT;
    END_IF;
  END_IF;
  IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF (c) THEN
   (* For a composite_curve_on_surface the basis_surface is the intersection
    of the basis_surfaces of all the segments. *)
     n := SIZEOF(c\composite_curve.segments);
     surfs := get_basis_surface(
                     c\composite_curve.segments[1].parent_curve);
     IF n > 1 THEN
       REPEAT i := 2 TO n;
         surfs := surfs * get_basis_surface(
                  c\composite_curve.segments[i].parent_curve);
       END_REPEAT;
     END_IF;

  END_IF;
  RETURN(surfs);
END_FUNCTION;

FUNCTION get_description_value
	(obj: description_attribute_select) : text;
    LOCAL
      description_bag : BAG OF description_attribute := (USEDIN(obj, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM'));
    END_LOCAL;

    IF SIZEOF(description_bag) = 1 THEN
      RETURN (description_bag[1].attribute_value);
    ELSE
      RETURN (?);
    END_IF;
END_FUNCTION;

FUNCTION get_directed_link
	(nodes: LIST [0:?] OF representation; undirected_link: LIST [0:?] OF chained_representation_link) : LIST [0:?] OF representation_relationship;
  LOCAL
   directed_link : LIST OF representation_relationship := [];
  END_LOCAL;

  REPEAT i := 1 to SIZEOF(undirected_link);
   CASE TRUE OF
    ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REPRESENTATION_CONTEXT' IN TYPEOF(undirected_link[i])) :
    BEGIN
     IF ((nodes[i]\representation.context_of_items   :=: undirected_link[i]) AND 
         (nodes[i+1]\representation.context_of_items :=: undirected_link[i])) THEN
       INSERT(directed_link, representation_relationship('','',nodes[i],nodes[i+1]), (i - 1));
     ELSE
       RETURN(?); 
     END_IF;
    END;

    ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REPRESENTATION_RELATIONSHIP' IN TYPEOF(undirected_link[i])) :
    BEGIN
     IF (((nodes[i]   :=: undirected_link[i]\representation_relationship.rep_1) AND
          (nodes[i+1] :=: undirected_link[i]\representation_relationship.rep_2)) OR
         ((nodes[i]   :=: undirected_link[i]\representation_relationship.rep_2) AND
          (nodes[i+1] :=: undirected_link[i]\representation_relationship.rep_1))) THEN
       INSERT(directed_link, representation_relationship('','',nodes[i],nodes[i+1]), (i - 1));
     ELSE
       RETURN(?); 
     END_IF;
    END;

    ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF(undirected_link[i])) :
    BEGIN
     IF ((nodes[i] IN using_representations(undirected_link[i])) AND 
         (nodes[i+1] :=: undirected_link[i]\mapped_item.mapping_source\representation_map.mapped_representation)) THEN
       INSERT(directed_link, representation_relationship('','',nodes[i],nodes[i+1]), (i - 1));
     ELSE
       RETURN(?); 
     END_IF;
    END;

    OTHERWISE : RETURN(?);
   END_CASE;
  END_REPEAT;
  RETURN(directed_link);
END_FUNCTION;

FUNCTION get_id_value
	(obj: id_attribute_select) : identifier;
    LOCAL
      id_bag : BAG OF id_attribute := (USEDIN(obj, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM'));
    END_LOCAL;

    IF SIZEOF(id_bag) = 1 THEN
      RETURN (id_bag[1].attribute_value);
    ELSE
      RETURN (?);
    END_IF;
END_FUNCTION;

FUNCTION get_name_value
	(obj: name_attribute_select) : label;
    LOCAL
      name_bag : BAG OF name_attribute := (USEDIN(obj, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'NAME_ATTRIBUTE.' + 'NAMED_ITEM'));
    END_LOCAL;

    IF SIZEOF(name_bag) = 1 THEN
      RETURN (name_bag[1].attribute_value);
    ELSE
      RETURN (?);
    END_IF;
END_FUNCTION;

FUNCTION get_role
	(obj: role_select) : object_role;
    LOCAL
      role_bag : BAG OF role_association := (USEDIN(obj, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ROLE_ASSOCIATION.' + 'ITEM_WITH_ROLE'));
    END_LOCAL;

    IF SIZEOF(role_bag) = 1 THEN
      RETURN (role_bag[1].role);
    ELSE
      RETURN (?);
    END_IF;
END_FUNCTION;

FUNCTION get_shape_aspect_property_definition_representations
	(s_a_instance: shape_aspect) : SET [0:?] OF property_definition_representation;
LOCAL
pd_set : SET OF property_definition := [];
pdr_set : SET OF property_definition_representation := [] ;
END_LOCAL;
pd_set := bag_to_set(USEDIN(s_a_instance, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROPERTY_DEFINITION.DEFINITION'));
IF (SIZEOF(pd_set) < 1) THEN
RETURN (pdr_set);
END_IF;
REPEAT i := 1 TO HIINDEX(pd_set);
pdr_set := pdr_set + (QUERY(pdr <* USEDIN(pd_set[i], 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.' + 'DEFINITION') |
'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHAPE_DEFINITION_REPRESENTATION' IN TYPEOF(pdr)));
END_REPEAT;
RETURN (pdr_set);
END_FUNCTION;

FUNCTION has_values_space
	(expr: generic_expression) : BOOLEAN;
  LOCAL
    typenames : SET OF STRING := stripped_typeof (expr);
  END_LOCAL;
  IF 'EXPRESSION' IN typenames THEN
    RETURN (bool(('NUMERIC_EXPRESSION' IN typenames) OR
      ('STRING_EXPRESSION' IN typenames) OR
      ('BOOLEAN_EXPRESSION' IN typenames)));
  END_IF;
  IF 'MATHS_FUNCTION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'FUNCTION_APPLICATION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_SPACE' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_VARIABLE' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'DEPENDENT_VARIABLE_DEFINITION' IN typenames THEN
    RETURN (has_values_space (expr\unary_generic_expression.operand));
  END_IF;
  IF 'COMPLEX_NUMBER_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'LOGICAL_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'BINARY_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_ENUM_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'REAL_TUPLE_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'INTEGER_TUPLE_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'ATOM_BASED_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_TUPLE_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'PARTIAL_DERIVATIVE_EXPRESSION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'DEFINITE_INTEGRAL_EXPRESSION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

FUNCTION is_acyclic
	(arg: generic_expression) : BOOLEAN;
RETURN (acyclic (arg, []));
END_FUNCTION;

FUNCTION is_coordinate_property
	(arg: specified_general_property) : BOOLEAN;
IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EXTERNALLY_DEFINED_ITEM' IN
      TYPEOF(arg) ) THEN
    RETURN(TRUE);
  END_IF;
  RETURN ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COORDINATE_DATA_NAME' IN TYPEOF(arg));
END_FUNCTION;

FUNCTION is_int_expr
	(arg: numeric_expression) : LOGICAL;
LOCAL
	i: INTEGER := 0;
END_LOCAL;

IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.INT_LITERAL' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REAL_LITERAL' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.INT_NUMERIC_VARIABLE' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REAL_NUMERIC_VARIABLE' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ABS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_int_expr(arg\unary_numeric_expression.operand));
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MINUS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_int_expr(arg\unary_numeric_expression.operand)); 
END_IF;
IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COS_FUNCTION' IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TAN_FUNCTION' IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ASIN_FUNCTION' IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ACOS_FUNCTION' IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ATAN_FUNCTION' IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EXP_FUNCTION' IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LOG_FUNCTION' IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LOG2_FUNCTION' IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LOG10_FUNCTION' IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SQUARE_ROOT_FUNCTION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE);
END_IF;
IF 	('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLUS_EXPRESSION' IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MULT_EXPRESSION' 
								IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAXIMUM_FUNCTION'
								IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MINIMUM_FUNCTION'
								IN TYPEOF(arg)) 
THEN 
	REPEAT i :=1 TO SIZEOF (
			arg\multiple_arity_numeric_expression.operands);
	IF NOT 
		is_int_expr(arg\multiple_arity_numeric_expression.operands[i]) 
	THEN 
		RETURN (FALSE);
	END_IF;
	END_REPEAT;
	RETURN (TRUE);
END_IF;
IF 	('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MINUS_EXPRESSION' IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POWER_EXPRESSION' 
								IN TYPEOF(arg))
THEN 
	RETURN (is_int_expr(arg\binary_numeric_expression.operands[1])
		AND is_int_expr(arg\binary_numeric_expression.operands[2]));
END_IF;
IF	('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIV_EXPRESSION' IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MOD_EXPRESSION' IN TYPEOF(arg))
THEN 
	RETURN(TRUE);	
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SLASH_EXPRESSION' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 	
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VALUE_FUNCTION' IN TYPEOF(arg) 
THEN 
	IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.INT_VALUE_FUNCTION' 
								IN TYPEOF(arg) 
	THEN 
		RETURN (TRUE); 
	ELSE 
		RETURN (FALSE); 
	END_IF;
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.INTEGER_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN(TRUE) ;
END_IF;
IF'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REAL_DEFINED_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN(FALSE) ;
END_IF ;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BOOLEAN_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN(FALSE) ;
END_IF ;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRING_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN (FALSE) ;
END_IF ;

RETURN (FALSE);
END_FUNCTION;

FUNCTION is_SQL_mappable
	(arg: expression) : LOGICAL;
LOCAL
	i: INTEGER;
END_LOCAL;

IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SIMPLE_NUMERIC_EXPRESSION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SQL_MAPPABLE_DEFINED_FUNCTION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MINUS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_SQL_mappable(arg\unary_numeric_expression.operand)); 
END_IF;
IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ABS_FUNCTION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COS_FUNCTION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TAN_FUNCTION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ASIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ACOS_FUNCTION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ATAN_FUNCTION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EXP_FUNCTION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LOG_FUNCTION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LOG2_FUNCTION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LOG10_FUNCTION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SQUARE_ROOT_FUNCTION' 
								IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VALUE_FUNCTION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_FUNCTION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE);
END_IF;
IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLUS_EXPRESSION' IN TYPEOF(arg)) 
		OR('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MULT_EXPRESSION' IN TYPEOF(arg)) 
		OR('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAXIMUM_FUNCTION' 
								IN TYPEOF(arg)) 
		OR('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MINIMUM_FUNCTION' 
								IN TYPEOF(arg)) 
THEN 
	REPEAT i :=1 TO SIZEOF (
			arg\multiple_arity_numeric_expression.operands);
		IF NOT is_SQL_mappable(
			arg\multiple_arity_numeric_expression.operands[i])
		THEN 
			RETURN (FALSE);
		END_IF;
	END_REPEAT;
RETURN (TRUE);
END_IF;
IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MINUS_EXPRESSION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SLASH_EXPRESSION' IN 
								TYPEOF(arg))
THEN
		RETURN (is_SQL_mappable(
			arg\binary_numeric_expression.operands[1])
		AND is_SQL_mappable(arg\binary_numeric_expression.operands[2]));
END_IF;
IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIV_EXPRESSION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MOD_EXPRESSION' IN TYPEOF(arg)) 
		OR('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POWER_EXPRESSION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE); 	
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SIMPLE_BOOLEAN_EXPRESSION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NOT_EXPRESSION' IN TYPEOF (arg) 
THEN 
	RETURN (is_SQL_mappable (arg\UNARY_GENERIC_EXPRESSION.OPERAND));
END_IF;
IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ODD_FUNCTION'IN TYPEOF (arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.XOR_EXPRESSION' 
								IN TYPEOF (arg)) 
THEN	
	RETURN (FALSE);
END_IF;
IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AND_EXPRESSION' IN TYPEOF (arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OR_EXPRESSION' IN TYPEOF (arg)) 
THEN
	REPEAT i:=1 TO SIZEOF (
			arg\MULTIPLE_ARITY_BOOLEAN_EXPRESSION.OPERANDS);
		IF NOT is_SQL_mappable (
			arg\MULTIPLE_ARITY_BOOLEAN_EXPRESSION.OPERANDS[i]) 
		THEN 
			RETURN (FALSE);
		END_IF;
	END_REPEAT;
	RETURN (TRUE);
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EQUALS_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN(is_SQL_mappable (
			arg\BINARY_GENERIC_EXPRESSION.OPERANDS [1])
		AND is_SQL_mappable(
			arg\BINARY_GENERIC_EXPRESSION.OPERANDS [2]));
END_IF;
IF	('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPARISON_EQUAL' IN TYPEOF (arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPARISON_GREATER' 
								IN TYPEOF (arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPARISON_GREATER_EQUAL'
								IN TYPEOF (arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPARISON_LESS' 
								IN TYPEOF (arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPARISON_LESS_EQUAL' 
								IN TYPEOF (arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPARISON_NOT_EQUAL' 
								IN TYPEOF (arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LIKE_EXPRESSION' 
								IN TYPEOF (arg)) 
THEN
	RETURN (is_SQL_mappable (arg\COMPARISON_EXPRESSION.OPERANDS[1])
		AND is_SQL_mappable (arg\COMPARISON_EXPRESSION.OPERANDS[2]));
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.INTERVAL_EXPRESSION' IN TYPEOF(arg) 
THEN 
	RETURN (is_SQL_mappable(arg\interval_expression.interval_low) 
		AND is_SQL_mappable(arg\interval_expression.interval_high)
		AND is_SQL_mappable(arg\interval_expression.interval_item));
END_IF;
IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NUMERIC_DEFINED_FUNCTION' 
								IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BOOLEAN_DEFINED_FUNCTION' 
								IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRING_DEFINED_FUNCTION' 
								IN TYPEOF(arg))  
THEN 
		RETURN (FALSE) ;
END_IF;

IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SIMPLE_STRING_EXPRESSION' 
								IN TYPEOF(ARG) 
THEN 
	RETURN (TRUE);
END_IF;
IF 	('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.INDEX_EXPRESSION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SUBSTRING_EXPRESSION' 
								IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONCAT_EXPRESSION' 
								IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FORMAT_FUNCTION' 
								IN TYPEOF(arg)) 
THEN 
	RETURN (FALSE);
END_IF;

	RETURN (FALSE);
END_FUNCTION;

FUNCTION item_in_context
	(item: representation_item; cntxt: representation_context) : BOOLEAN;
    LOCAL
      y : BAG OF representation_item;
    END_LOCAL;
    -- If there is one or more representation using both the item
    -- and cntxt return true.
    IF SIZEOF(USEDIN(item,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REPRESENTATION.ITEMS')
      * cntxt.representations_in_context) > 0 THEN
      RETURN (TRUE);
      -- Determine the bag of representation_items that reference
      -- item
      ELSE y := QUERY(z <* USEDIN (item , '') |
             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z));
        -- Ensure that the bag is not empty
        IF SIZEOF(y) > 0 THEN
        -- For each element in the bag
        REPEAT i := 1 TO HIINDEX(y);
          -- Check to see it is an item in the input cntxt.
          IF item_in_context(y[i], cntxt) THEN
            RETURN (TRUE);
          END_IF;
        END_REPEAT;
      END_IF;
    END_IF;
    -- Return false when all possible branches have been checked
    -- with no success.
    RETURN (FALSE);
END_FUNCTION;

FUNCTION leap_year
	(year: year_number) : BOOLEAN;
IF ((((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) = 0)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
END_FUNCTION;

FUNCTION list_face_loops
	(f: face) : LIST [0:?] OF loop;
   LOCAL
     loops : LIST[0:?] OF loop := [];
   END_LOCAL;
   
   REPEAT i := 1 TO SIZEOF(f.bounds);
     loops := loops +(f.bounds[i].bound);
   END_REPEAT;
      
   RETURN(loops);
END_FUNCTION;

FUNCTION list_of_topology_reversed
	(a_list: list_of_reversible_topology_item) : list_of_reversible_topology_item;
   LOCAL
     the_reverse : list_of_reversible_topology_item;
   END_LOCAL;
    
   the_reverse := [];
   REPEAT i := 1 TO SIZEOF (a_list);
     the_reverse := topology_reversed (a_list [i]) + the_reverse;
   END_REPEAT;
  
   RETURN (the_reverse);
END_FUNCTION;

FUNCTION list_selected_components
	(aggr: AGGREGATE OF LIST [0:?] OF maths_value; k: positive_integer) : LIST [0:?] OF maths_value;
  LOCAL
    result : LIST OF maths_value := [];
    j : INTEGER := 0;
  END_LOCAL;
  REPEAT i := LOINDEX (aggr) TO HIINDEX (aggr);
    IF k <= SIZEOF (aggr[i]) THEN
      INSERT (result, aggr[i][k], j);
      j := j + 1;
    END_IF;
  END_REPEAT;
  RETURN (result);
END_FUNCTION;

FUNCTION list_to_array
	(lis: LIST [0:?] OF GENERIC: T; low: INTEGER; u: INTEGER) : ARRAY [low:u] OF GENERIC: T;
   LOCAL
     n   : INTEGER;
     res : ARRAY [low:u] OF GENERIC : T;
   END_LOCAL;
      
   n := SIZEOF(lis);
   IF (n <> (u-low +1)) THEN
     RETURN(?);
   ELSE
     res := [lis[1] : n];
     REPEAT i := 2 TO n;
       res[low+i-1] := lis[i];
     END_REPEAT;
     RETURN(res);
   END_IF;
END_FUNCTION;

FUNCTION list_to_set
	(l: LIST [0:?] OF GENERIC: T) : SET [0:?] OF GENERIC: T;
   LOCAL
     s : SET OF GENERIC:T := [];
   END_LOCAL;
      
   REPEAT i := 1 TO SIZEOF(l);
     s := s + l[i];
   END_REPEAT;
   
   RETURN(s);
END_FUNCTION;

FUNCTION make_array_of_array
	(lis: LIST [1:?] OF LIST [1:?] OF GENERIC: T; low1: INTEGER; u1: INTEGER; low2: INTEGER; u2: INTEGER) : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC: T;
   LOCAL
     res   : ARRAY[low1:u1] OF ARRAY [low2:u2] OF GENERIC : T;
   END_LOCAL;

(* Check input dimensions for consistency *)
   IF (u1-low1+1) <> SIZEOF(lis) THEN
     RETURN (?);
   END_IF;
   IF (u2 - low2 + 1 ) <> SIZEOF(lis[1]) THEN
     RETURN (?) ;
   END_IF;
(* Initialise res with values from lis[1] *)
   res := [list_to_array(lis[1], low2, u2) : (u1-low1 + 1)];
   REPEAT i := 2 TO HIINDEX(lis);
     IF (u2-low2+1) <> SIZEOF(lis[i]) THEN
       RETURN (?);
     END_IF;     
     res[low1+i-1] := list_to_array(lis[i], low2, u2);
   END_REPEAT; 
   
   RETURN (res);
END_FUNCTION;

FUNCTION make_atom_based_literal
	(lit_value: atom_based_value) : atom_based_literal;
RETURN (atom_based_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;

FUNCTION make_binary_literal
	(lit_value: BINARY) : binary_literal;
RETURN (binary_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;

FUNCTION make_boolean_literal
	(lit_value: BOOLEAN) : boolean_literal;
RETURN (boolean_literal (lit_value)
    || simple_boolean_expression()
      || boolean_expression()
        || expression()
          || generic_expression()
      || simple_generic_expression()
    || generic_literal() );
END_FUNCTION;

FUNCTION make_cartesian_complex_number_region
	(real_constraint: real_interval; imag_constraint: real_interval) : cartesian_complex_number_region;
RETURN (cartesian_complex_number_region (real_constraint, imag_constraint)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;

FUNCTION make_complex_number_literal
	(rpart: REAL; ipart: REAL) : complex_number_literal;
RETURN (complex_number_literal (rpart, ipart)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;

FUNCTION make_elementary_function
	(func_id: elementary_function_enumerators) : elementary_function;
RETURN (elementary_function (func_id)
    || maths_function()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;

FUNCTION make_elementary_space
	(space_id: elementary_space_enumerators) : elementary_space;
RETURN (elementary_space (space_id)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;

FUNCTION make_extended_tuple_space
	(base: product_space; extender: maths_space) : extended_tuple_space;
RETURN (extended_tuple_space (base, extender)
    || maths_space ()
      || generic_expression()
    || generic_literal ()
      || simple_generic_expression() );
END_FUNCTION;

FUNCTION make_finite_integer_interval
	(min: INTEGER; max: INTEGER) : finite_integer_interval;
RETURN (finite_integer_interval (min, max)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;

FUNCTION make_finite_real_interval
	(min: REAL; minclo: open_closed; max: REAL; maxclo: open_closed) : finite_real_interval;
RETURN (finite_real_interval (min, minclo, max, maxclo)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;

FUNCTION make_finite_space
	(members: SET [0:?] OF maths_value) : finite_space;
RETURN (finite_space (members)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;

FUNCTION make_function_application
	(afunction: maths_function_select; arguments: LIST [1:?] OF maths_value) : function_application;
RETURN (function_application (afunction, arguments)
    || multiple_arity_generic_expression (convert_to_maths_function (afunction) +
      convert_to_operands (arguments))  -- derived
      || generic_expression() );
END_FUNCTION;

FUNCTION make_function_space
	(domain_constraint: space_constraint_type; domain_argument: maths_space; range_constraint: space_constraint_type; range_argument: maths_space) : function_space;
RETURN (function_space (domain_constraint, domain_argument, range_constraint,
    range_argument)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;

FUNCTION make_int_literal
	(lit_value: INTEGER) : int_literal;
RETURN (int_literal ()
    || literal_number(lit_value)
      || simple_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || simple_generic_expression()
      || generic_literal() );
END_FUNCTION;

FUNCTION make_listed_product_space
	(factors: LIST [0:?] OF maths_space) : listed_product_space;
RETURN (listed_product_space (factors)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;

FUNCTION make_logical_literal
	(lit_value: LOGICAL) : logical_literal;
RETURN (logical_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;

FUNCTION make_maths_enum_literal
	(lit_value: maths_enum_atom) : maths_enum_literal;
RETURN (maths_enum_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;

FUNCTION make_maths_tuple_literal
	(lit_value: LIST [0:?] OF maths_value) : maths_tuple_literal;
RETURN (maths_tuple_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;

FUNCTION make_parallel_composed_function
	(srcdom: maths_space_or_function; prepfuncs: LIST [2:?] OF maths_function; finfunc: maths_function_select) : parallel_composed_function;
RETURN (parallel_composed_function (srcdom, prepfuncs, finfunc)
    || maths_function()
      || generic_expression()
    || multiple_arity_generic_expression (convert_to_operands_prcmfn (
      srcdom, prepfuncs, finfunc)) );
END_FUNCTION;

FUNCTION make_polar_complex_number_region
	(centre: complex_number_literal; dis_constraint: real_interval; dir_constraint: finite_real_interval) : polar_complex_number_region;
RETURN (polar_complex_number_region (centre, dis_constraint, dir_constraint)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;

FUNCTION make_real_interval_from_min
	(min: REAL; minclo: open_closed) : real_interval_from_min;
RETURN (real_interval_from_min (min, minclo)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;

FUNCTION make_real_interval_to_max
	(max: REAL; maxclo: open_closed) : real_interval_to_max;
RETURN (real_interval_to_max (max, maxclo)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;

FUNCTION make_real_literal
	(lit_value: REAL) : real_literal;
RETURN (real_literal ()
    || literal_number(lit_value)
      || simple_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || simple_generic_expression()
      || generic_literal() );
END_FUNCTION;

FUNCTION make_string_literal
	(lit_value: STRING) : string_literal;
RETURN (string_literal (lit_value)
    || simple_string_expression()
      || string_expression()
        || expression()
          || generic_expression()
      || simple_generic_expression()
    || generic_literal() );
END_FUNCTION;

FUNCTION make_uniform_product_space
	(base: maths_space; exponent: positive_integer) : uniform_product_space;
RETURN (uniform_product_space (base, exponent)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;

FUNCTION max_exists
	(spc: maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  RETURN (bool(((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types) OR
    ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) OR
    ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types)));
END_FUNCTION;

FUNCTION max_included
	(spc: maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types) THEN
    RETURN (TRUE);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (bool(spc\finite_real_interval.max_closure = closed));
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types) THEN
    RETURN (bool(spc\real_interval_to_max.max_closure = closed));
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

FUNCTION member_of
	(val: GENERIC: G; spc: maths_space) : LOGICAL;
FUNCTION fedex(val : AGGREGATE OF GENERIC:X;
                 i   : INTEGER) : GENERIC:X;
    RETURN (val[i]);
  END_FUNCTION;  -- fedex

  LOCAL
    v : maths_value := simplify_maths_value (convert_to_maths_value (val));
    vtypes : SET OF STRING := stripped_typeof (v);
    s : maths_space := simplify_maths_space (spc);
    stypes : SET OF STRING := stripped_typeof (s);
    tmp_int : INTEGER;
    tmp_real : REAL;
    tmp_cmplx : complex_number_literal;
    lgcl, cum : LOGICAL;
    vspc, sspc : maths_space;
    smem : SET OF maths_value;
    factors : LIST OF maths_space;
  END_LOCAL;
  IF NOT EXISTS (s) THEN
    RETURN (FALSE);
  END_IF;
  IF NOT EXISTS (v) THEN
    RETURN (s = the_generics);
  END_IF;
  IF ('GENERIC_EXPRESSION' IN vtypes) AND
    NOT ('MATHS_SPACE' IN vtypes) AND
    NOT ('MATHS_FUNCTION' IN vtypes) AND
    NOT ('COMPLEX_NUMBER_LITERAL' IN vtypes) THEN
    IF has_values_space (v) THEN
      vspc := values_space_of (v);
      IF subspace_of (vspc, s) THEN
        RETURN (TRUE);
      END_IF;
      IF NOT compatible_spaces (vspc, s) THEN
        RETURN (FALSE);
      END_IF;
      RETURN (UNKNOWN);
    END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN stypes THEN
    CASE s\elementary_space.space_id OF
    es_numbers :  RETURN (('NUMBER' IN vtypes) OR
                          ('COMPLEX_NUMBER_LITERAL' IN vtypes));
    es_complex_numbers :  RETURN ('COMPLEX_NUMBER_LITERAL' IN vtypes);
    es_reals :  RETURN (('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes));
    es_integers :  RETURN ('INTEGER' IN vtypes);
    es_logicals :  RETURN ('LOGICAL' IN vtypes);
    es_booleans :  RETURN ('BOOLEAN' IN vtypes);
    es_strings :  RETURN ('STRING' IN vtypes);
    es_binarys :  RETURN ('BINARY' IN vtypes);
    es_maths_spaces :  RETURN ('MATHS_SPACE' IN vtypes);
    es_maths_functions :  RETURN ('MATHS_FUNCTION' IN vtypes);
    es_generics :  RETURN (TRUE);
    END_CASE;
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN stypes THEN
    IF 'INTEGER' IN vtypes THEN
      tmp_int := v;
      RETURN ({s\finite_integer_interval.min <= tmp_int <=
        s\finite_integer_interval.max});
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'INTEGER_INTERVAL_FROM_MIN' IN stypes THEN
    IF 'INTEGER' IN vtypes THEN
      tmp_int := v;
      RETURN (s\integer_interval_from_min.min <= tmp_int);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'INTEGER_INTERVAL_TO_MAX' IN stypes THEN
    IF 'INTEGER' IN vtypes THEN
      tmp_int := v;
      RETURN (tmp_int <= s\integer_interval_to_max.max);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_REAL_INTERVAL' IN stypes THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes) THEN
      tmp_real := v;
      IF s\finite_real_interval.min_closure = closed THEN
        IF s\finite_real_interval.max_closure = closed THEN
          RETURN ({s\finite_real_interval.min <= tmp_real <=
            s\finite_real_interval.max});
        ELSE
          RETURN ({s\finite_real_interval.min <= tmp_real <
            s\finite_real_interval.max});
        END_IF;
      ELSE
        IF s\finite_real_interval.max_closure = closed THEN
          RETURN ({s\finite_real_interval.min < tmp_real <=
            s\finite_real_interval.max});
        ELSE
          RETURN ({s\finite_real_interval.min < tmp_real <
            s\finite_real_interval.max});
        END_IF;
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'REAL_INTERVAL_FROM_MIN' IN stypes THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes) THEN
      tmp_real := v;
      IF s\real_interval_from_min.min_closure = closed THEN
        RETURN (s\real_interval_from_min.min <= tmp_real);
      ELSE
        RETURN (s\real_interval_from_min.min < tmp_real);
     END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'REAL_INTERVAL_TO_MAX' IN stypes THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes) THEN
      tmp_real := v;
      IF s\real_interval_to_max.max_closure = closed THEN
        RETURN (tmp_real <= s\real_interval_to_max.max);
      ELSE
        RETURN (tmp_real < s\real_interval_to_max.max);
     END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN stypes THEN
    IF 'COMPLEX_NUMBER_LITERAL' IN vtypes THEN
      RETURN (member_of(v\complex_number_literal.real_part,
        s\cartesian_complex_number_region.real_constraint) AND
        member_of(v\complex_number_literal.imag_part,
        s\cartesian_complex_number_region.imag_constraint));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'POLAR_COMPLEX_NUMBER_REGION' IN stypes THEN
    IF 'COMPLEX_NUMBER_LITERAL' IN vtypes THEN
      tmp_cmplx := v;
      tmp_cmplx.real_part := tmp_cmplx.real_part -
        s\polar_complex_number_region.centre.real_part;
      tmp_cmplx.imag_part := tmp_cmplx.imag_part -
        s\polar_complex_number_region.centre.imag_part;
      tmp_real := SQRT (tmp_cmplx.real_part**2 + tmp_cmplx.imag_part**2);
      IF NOT member_of(tmp_real,
        s\polar_complex_number_region.distance_constraint) THEN
        RETURN (FALSE);
      END_IF;
      IF tmp_real = 0.0 THEN
        RETURN (TRUE);  -- The centre has no direction.
      END_IF;
      tmp_real := atan2(tmp_cmplx.imag_part,tmp_cmplx.real_part);
      RETURN (member_of(tmp_real,
        s\polar_complex_number_region.direction_constraint) OR
        member_of(tmp_real + 2.0*PI,
        s\polar_complex_number_region.direction_constraint));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_SPACE' IN stypes THEN
    smem := s\finite_space.members;
    cum := FALSE;
    REPEAT i := 1 TO SIZEOF (smem);
      cum := cum OR equal_maths_values(v,smem[i]);
      IF cum = TRUE THEN
        RETURN (TRUE);
      END_IF;
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN stypes THEN
    IF 'LIST' IN vtypes THEN
      IF SIZEOF (v) = s\uniform_product_space.exponent THEN
        sspc := s\uniform_product_space.base;
        cum := TRUE;
        REPEAT i := 1 TO SIZEOF (v);
          cum := cum AND member_of(v[i],sspc);
--          cum := cum AND member_of (fedex (v, i), sspc);
            -- See note above for explanation of fedex()
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN stypes THEN
    IF 'LIST' IN vtypes THEN
      factors := s\listed_product_space.factors;
      IF SIZEOF (v) = SIZEOF (factors) THEN
        cum := TRUE;
        REPEAT i := 1 TO SIZEOF (v);
          cum := cum AND member_of(v[i],factors[i]);
--          cum := cum AND member_of (fedex (v, i), factors[i]);
            -- See note above for explanation of fedex()
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN stypes THEN
    IF 'LIST' IN vtypes THEN
      sspc := s\extended_tuple_space.base;
      tmp_int := space_dimension(sspc);
      IF SIZEOF (v) >= tmp_int THEN
        cum := TRUE;
        REPEAT i := 1 TO tmp_int;
          cum := cum AND member_of(v[i],factor_space(sspc,i));
--          cum := cum AND member_of (fedex (v, i), factor_space (sspc, i));
            -- See note above for explanation of fedex()
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        sspc := s\extended_tuple_space.extender;
        REPEAT i := tmp_int+1 TO SIZEOF (v);
          cum := cum AND member_of(v[i],sspc);
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FUNCTION_SPACE' IN stypes THEN
    IF 'MATHS_FUNCTION' IN vtypes THEN
      vspc := v\maths_function.domain;
      sspc := s\function_space.domain_argument;
      CASE s\function_space.domain_constraint OF
      sc_equal : cum := equal_maths_spaces (vspc, sspc);
      sc_subspace : cum := subspace_of (vspc, sspc);
      sc_member : cum := member_of (vspc, sspc);
      END_CASE;
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
      vspc := v\maths_function.range;
      sspc := s\function_space.range_argument;
      CASE s\function_space.range_constraint OF
      sc_equal : cum := cum AND equal_maths_spaces (vspc, sspc);
      sc_subspace : cum := cum AND subspace_of (vspc, sspc);
      sc_member : cum := cum AND member_of (vspc, sspc);
      END_CASE;
      RETURN (cum);
    END_IF;
    RETURN (FALSE);
  END_IF;
  -- Should be unreachable
  RETURN (UNKNOWN);
END_FUNCTION;

FUNCTION min_exists
	(spc: maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  RETURN (bool(((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types) OR
    ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) OR
    ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types)));
END_FUNCTION;

FUNCTION min_included
	(spc: maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (TRUE);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (bool(spc\finite_real_interval.min_closure = closed));
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (bool(spc\real_interval_from_min.min_closure = closed));
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

FUNCTION mixed_loop_type_set
	(l: SET [0:?] OF loop) : LOGICAL;
    LOCAL
      poly_loop_type: LOGICAL;
    END_LOCAL;
    IF(SIZEOF(l) <= 1) THEN
      RETURN(FALSE);
    END_IF;
    poly_loop_type := ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLY_LOOP' IN TYPEOF(l[1]));
    REPEAT i := 2 TO SIZEOF(l);
      IF(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLY_LOOP' IN TYPEOF(l[i])) <> poly_loop_type)
          THEN
          RETURN(TRUE);
       END_IF;
    END_REPEAT;
    RETURN(FALSE);
END_FUNCTION;

FUNCTION msb_shells
	(brep: manifold_solid_brep) : SET [1:?] OF closed_shell;
    LOCAL   
      return_set: SET[1:?] OF closed_shell := [brep.outer];   
    END_LOCAL;   

    IF SIZEOF(QUERY(msbtype <* TYPEOF(brep) |   
                 msbtype LIKE '*BREP_WITH_VOIDS'))  >= 1    
          THEN   
       return_set := return_set + brep\brep_with_voids.voids;   
    END_IF;   
   RETURN(return_set);
END_FUNCTION;

FUNCTION msf_curve_check
	(cv: representation_item) : BOOLEAN;
IF SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BOUNDED_CURVE',
  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONIC',
  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_REPLICA', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE',
  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_CURVE_3D'] * TYPEOF(cv)) > 1 THEN
  RETURN(FALSE);
END_IF;

(* b_spline_curves shall not self-intersect
 *)
IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE' IN TYPEOF (cv)) AND
  (cv\b_spline_curve.self_intersect = FALSE)OR
  (cv\b_spline_curve.self_intersect = UNKNOWN)) THEN
  RETURN(TRUE);
ELSE

  (* conics and lines are valid curve types
   *)
  IF SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONIC', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE'] 
    * TYPEOF (cv)) = 1 THEN
    RETURN(TRUE);
  ELSE

    (* a curve_replica shall reference a valid curve
     *)
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_REPLICA' IN TYPEOF(cv) THEN
      RETURN (msf_curve_check(cv\curve_replica.parent_curve)); 
    ELSE 
 
      (* an offset_curve_3d shall not self-intersect and
         shall reference a valid curve; a polyline is not a
         valid basis_curve
       *)
      IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_CURVE_3D' IN TYPEOF (cv))
        AND
        ((cv\offset_curve_3d.self_intersect = FALSE) OR
        (cv\offset_curve_3d.self_intersect = UNKNOWN))
        AND
        (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN TYPEOF
        (cv\offset_curve_3d.basis_curve)))) THEN
        RETURN (msf_curve_check(cv\offset_curve_3d.basis_curve)); 
      ELSE 
 
        (* a pcurve shall reference a valid curve and a valid
           basis_surface
         *)
        IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN TYPEOF(cv) THEN 
          RETURN ((msf_curve_check
          (cv\pcurve.reference_to_curve\representation.items[1])) AND
          (msf_surface_check(cv\pcurve.basis_surface)));
        ELSE 
 
          (* a surface_curve references a curve_3d and one or
             two pcurves or one or two surfaces or one of
             each; all of these references shall be valid
           *)
          IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE' IN TYPEOF(cv) THEN 

            (* if the curve reference is correct, check also the rest
             *)
            IF msf_curve_check(cv\surface_curve.curve_3d) THEN
              REPEAT i := 1 TO SIZEOF
              (cv\surface_curve.associated_geometry);

                (* do for one or two associated_geometrys:
                 *)
                IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE' IN 
                  TYPEOF (cv\surface_curve.associated_geometry[i]) THEN  
                  IF NOT msf_surface_check
                    (cv\surface_curve.associated_geometry[i]) THEN  
                    RETURN(FALSE);  
                  END_IF;  
                ELSE  
                  IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN TYPEOF 
                    (cv\surface_curve.associated_geometry[i]) THEN  
                    IF NOT msf_curve_check
                      (cv\surface_curve.associated_geometry[i]) THEN 
                      RETURN(FALSE);  
                    END_IF;  
                  END_IF;  
                END_IF; 
              END_REPEAT;  
              RETURN(TRUE);
            END_IF; 
          ELSE

            (* a polyline shall have at least 3 points
             *)
            IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN TYPEOF(cv) THEN
              IF (SIZEOF (cv\polyline.points) >= 3) THEN RETURN (TRUE);
              END_IF;
            END_IF;
          END_IF; 
        END_IF; 
      END_IF; 
    END_IF; 
  END_IF; 
END_IF; 
(* FALSE is returned if the input parameter cv is not a valid curve.
 *)
RETURN (FALSE);
END_FUNCTION;

FUNCTION msf_surface_check
	(surf: surface) : BOOLEAN;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELEMENTARY_SURFACE' IN TYPEOF(surf) THEN
    RETURN(TRUE);
  ELSE 

    (* a swept_surface shall have a valid sweeping curve
     *)
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SWEPT_SURFACE' IN TYPEOF (surf) THEN 
      RETURN (msf_curve_check(surf\swept_surface.swept_curve));  
    ELSE 
 
      (* an offset_surface shall not self-intersect and shall
         reference a valid surface
       *)
      IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_SURFACE' IN TYPEOF (surf)) AND
        (surf\offset_surface.self_intersect = FALSE) OR 
        (surf\offset_surface.self_intersect = UNKNOWN)) THEN
        RETURN (msf_surface_check(surf\offset_surface.basis_surface));
      ELSE 
 
        (* a surface_replica shall have a valid parent surface
         *)
        IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_REPLICA' IN TYPEOF(surf) THEN 
          RETURN(msf_surface_check(surf\surface_replica.parent_surface)); 
        ELSE

          (* a b_spline_surface shall not self-intersect
           *)
          IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_SURFACE' IN TYPEOF(surf)) AND
            (surf\b_spline_surface.self_intersect = FALSE) OR
            (surf\b_spline_surface.self_intersect = UNKNOWN)) THEN
            RETURN(TRUE);
          END_IF;
        END_IF; 
      END_IF; 
    END_IF; 
  END_IF; 
  RETURN(FALSE);
END_FUNCTION;

FUNCTION necessary_value_coordinate_system
	(cs_value: field_value; coordinate_system: GENERIC) : BOOLEAN;
IF (SIZEOF (
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TENSOR1_2D',
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TENSOR1_3D',
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SYMMETRIC_TENSOR2_2D',
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SYMMETRIC_TENSOR2_3D'] *
        TYPEOF (cs_value)) = 1) THEN
        IF (NOT EXISTS (coordinate_system) ) THEN
            RETURN (FALSE);
        END_IF;
    END_IF;

    RETURN (TRUE);
END_FUNCTION;

FUNCTION nmsf_curve_check
	(cv: representation_item) : BOOLEAN;
IF SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BOUNDED_CURVE',
   'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONIC',
   'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_REPLICA',
   'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE',
   'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_CURVE_3D'] * TYPEOF(cv)) > 1
 THEN RETURN(FALSE);
 ELSE

  (* b_spline_curves shall not self-intersect
   *)
  IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE' IN TYPEOF (cv)) AND
    (cv\b_spline_curve.self_intersect = FALSE) OR
    (cv\b_spline_curve.self_intersect = UNKNOWN))
  THEN RETURN(TRUE);
  ELSE

    (* conics and lines are valid curve types
     *)
    IF SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONIC',
    'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE'] * TYPEOF (cv)) = 1 THEN
      RETURN(TRUE);
    ELSE

      (* a curve_replica shall reference a valid curve
       *)
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_REPLICA' IN TYPEOF(cv) THEN
        RETURN (nmsf_curve_check(cv\curve_replica.parent_curve)); 
      ELSE 
 
        (* an offset_curve_3d shall not self-intersect and
           shall reference a valid curve; a polyline is not a
           valid basis_curve
         *)
        IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_CURVE_3D' IN TYPEOF (cv)) 
          AND
          ((cv\offset_curve_3d.self_intersect = FALSE) OR
          (cv\offset_curve_3d.self_intersect = UNKNOWN))
          AND
          (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN TYPEOF
          (cv\offset_curve_3d.basis_curve)))) THEN
          RETURN (nmsf_curve_check(cv\offset_curve_3d.basis_curve)); 
        ELSE 
 
          (* a pcurve shall reference a valid curve and a valid
             basis_surface
           *)
          IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN TYPEOF(cv) THEN 
            RETURN ((nmsf_curve_check
            (cv\pcurve.reference_to_curve\representation.items[1]))
            AND
            (nmsf_surface_check(cv\pcurve.basis_surface)));
          ELSE 
 
            (* a surface_curve references a curve_3d and one or
               two pcurves or one or two surfaces or one of
               each; all of these references shall be valid
             *)
            IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE' IN TYPEOF(cv) THEN 

              (* if the curve reference is correct, check also the rest
               *)
              IF nmsf_curve_check(cv\surface_curve.curve_3d) THEN
                REPEAT i := 1 TO SIZEOF
                (cv\surface_curve.associated_geometry);

                  (* do for one or two associated_geometrys:
                   *)
                  IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE' IN 
                    TYPEOF (cv\surface_curve.associated_geometry[i]) THEN  
                    IF NOT nmsf_surface_check
                      (cv\surface_curve.associated_geometry[i]) THEN  
                      RETURN(FALSE);  
                    END_IF;  
                  ELSE  
                    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN TYPEOF 
                      (cv\surface_curve.associated_geometry[i]) THEN  
                      IF NOT nmsf_curve_check
                        (cv\surface_curve.associated_geometry[i]) THEN 
                        RETURN(FALSE);  
                      END_IF;  
                    END_IF;  
                  END_IF; 
                END_REPEAT;  
                RETURN(TRUE);
              END_IF; 
            ELSE

              (* a polyline shall have at least 3 points 
               *)
              IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN TYPEOF(cv) THEN
                IF (SIZEOF (cv\polyline.points) >= 3) THEN RETURN (TRUE);
                END_IF;
              END_IF;
            END_IF; 
          END_IF; 
        END_IF; 
      END_IF; 
    END_IF; 
  END_IF; 
 END_IF; 
 (* FALSE is returned if the input parameter cv is not a valid curve.
  *)
 RETURN (FALSE);
END_FUNCTION;

FUNCTION nmsf_surface_check
	(surf: surface) : BOOLEAN;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELEMENTARY_SURFACE' IN TYPEOF(surf) THEN
    RETURN(TRUE);
  ELSE 

    (* a swept_surface shall have a valid sweeping curve
     *)
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SWEPT_SURFACE' IN TYPEOF (surf) THEN 
      RETURN (nmsf_curve_check(surf\swept_surface.swept_curve));  
    ELSE 
 
      (* an offset_surface shall not self-intersect and shall
         reference a valid surface
       *)
      IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_SURFACE' IN TYPEOF (surf)) AND
        (surf\offset_surface.self_intersect = FALSE) OR 
        (surf\offset_surface.self_intersect = UNKNOWN)) THEN
        RETURN (nmsf_surface_check(surf\offset_surface.basis_surface));
      ELSE 
 
        (* a surface_replica shall have a valid parent surface
         *)
        IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_REPLICA' IN TYPEOF(surf) THEN 
          RETURN(nmsf_surface_check(surf\surface_replica.parent_surface)); 
        ELSE

          (* a b_spline_surface shall not self-intersect
           *)
          IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_SURFACE' IN TYPEOF(surf))
            AND
            (surf\b_spline_surface.self_intersect = FALSE) OR
            (surf\b_spline_surface.self_intersect = UNKNOWN)) THEN
            RETURN(TRUE);
          END_IF;
        END_IF; 
      END_IF; 
    END_IF; 
  END_IF; 
  RETURN(FALSE);
END_FUNCTION;

FUNCTION no_cyclic_domain_reference
	(ref: maths_space_or_function; used: SET [0:?] OF maths_function) : BOOLEAN;
  LOCAL
    typenames : SET OF STRING := TYPEOF (ref);
    func      : maths_function;
  END_LOCAL;
  IF (NOT EXISTS (ref)) OR (NOT EXISTS (used)) THEN
    RETURN (FALSE);
  END_IF;
  IF (schema_prefix + 'MATHS_SPACE') IN typenames THEN
    RETURN (TRUE);
  END_IF;
  func := ref;
  IF func IN used THEN
    RETURN (FALSE);
  END_IF;
  IF (schema_prefix + 'CONSTANT_FUNCTION') IN typenames THEN
    RETURN (no_cyclic_domain_reference (func\constant_function.source_of_domain,
      used + [func]));
  END_IF;
  IF (schema_prefix + 'SELECTOR_FUNCTION') IN typenames THEN
    RETURN (no_cyclic_domain_reference (func\selector_function.source_of_domain,
      used + [func]));
  END_IF;
  IF (schema_prefix + 'PARALLEL_COMPOSED_FUNCTION') IN typenames THEN
    RETURN (no_cyclic_domain_reference (
      func\parallel_composed_function.source_of_domain, used + [func]));
  END_IF;
  RETURN (TRUE);
END_FUNCTION;

FUNCTION no_cyclic_space_reference
	(spc: maths_space; refs: SET [0:?] OF maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING;
    refs_plus : SET OF maths_space;
  END_LOCAL;
  IF (spc IN refs) THEN
    RETURN (FALSE);
  END_IF;
  types := TYPEOF (spc);
  refs_plus := refs + spc;
  IF (schema_prefix + 'FINITE_SPACE') IN types THEN
    RETURN (bool(SIZEOF (QUERY (sp <* QUERY (mem <* spc\finite_space.members |
      (schema_prefix + 'MATHS_SPACE') IN TYPEOF (mem)) |
      NOT no_cyclic_space_reference (sp, refs_plus))) = 0));
  END_IF;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN types THEN
    RETURN (no_cyclic_space_reference (spc\uniform_product_space.base, refs_plus));
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN types THEN
    RETURN (bool(SIZEOF (QUERY (fac <* spc\listed_product_space.factors |
      NOT no_cyclic_space_reference (fac, refs_plus))) = 0));
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types THEN
    RETURN (no_cyclic_space_reference (spc\extended_tuple_space.base, refs_plus)
      AND no_cyclic_space_reference (spc\extended_tuple_space.extender, refs_plus));
  END_IF;
  -- spc contains no references to other spaces
  RETURN (TRUE);
END_FUNCTION;

FUNCTION nondecreasing
	(lr: LIST [0:?] OF REAL) : BOOLEAN;
IF NOT EXISTS (lr) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT j := 2 TO SIZEOF (lr);
    IF lr[j] < lr[j-1] THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;

FUNCTION normalise
	(arg: vector_or_direction) : vector_or_direction;
    LOCAL
      ndim   : INTEGER;
      v      : direction;
      result : vector_or_direction;
      vec    : vector;
      mag    : REAL;
    END_LOCAL;
    
    IF NOT EXISTS (arg) THEN
      result := ?;
  (* When function is called with invalid data a NULL result is returned *)
    ELSE
      ndim := arg.dim;
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VECTOR' IN TYPEOF(arg) THEN
        BEGIN
              v := dummy_gri || direction(arg\vector.orientation.direction_ratios);
          IF arg.magnitude = 0.0 THEN
            RETURN(?);
          ELSE
           vec := dummy_gri || vector (v, 1.0);
          END_IF;
        END;
      ELSE
        v := dummy_gri || direction (arg.direction_ratios);
      END_IF;
      mag := 0.0;
      REPEAT  i := 1 TO ndim;
        mag := mag + v.direction_ratios[i]*v.direction_ratios[i];
      END_REPEAT;
      IF mag > 0.0 THEN
        mag := SQRT(mag);
        REPEAT  i := 1 TO ndim;
          v.direction_ratios[i] := v.direction_ratios[i]/mag;
        END_REPEAT;
        IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VECTOR' IN TYPEOF(arg) THEN
          vec.orientation := v;
          result := vec;
        ELSE
          result := v;
        END_IF;
      ELSE
        RETURN(?);
      END_IF;
    END_IF;
    RETURN (result);
END_FUNCTION;

FUNCTION number_of_terms
	(node_dof_list: LIST [1:?] OF LIST [1:?] OF degree_of_freedom; matrix_type: matrix_symmetry) : INTEGER;
  LOCAL
    num_terms              : INTEGER;
    number_of_freedoms     : INTEGER;
  END_LOCAL;

  number_of_freedoms := 0; (* loop for each item in the outer list*)

  REPEAT i := 1 TO SIZEOF (node_dof_list); (* find size of inner list*)
    number_of_freedoms := number_of_freedoms + SIZEOF (node_dof_list[i]);
  END_REPEAT;

  IF (matrix_type = symmetric) THEN
    num_terms := (number_of_freedoms * (number_of_freedoms+1)) DIV 2;
  END_IF;

  IF (matrix_type = diagonal) THEN
    num_terms := number_of_freedoms;
  END_IF;

RETURN (num_terms);
END_FUNCTION;

FUNCTION number_superspace_of
	(spc: maths_space) : elementary_space;
IF subspace_of_es(spc,es_integers) THEN  RETURN (the_integers);  END_IF;
  IF subspace_of_es(spc,es_reals)    THEN  RETURN (the_reals);     END_IF;
  IF subspace_of_es(spc,es_complex_numbers) THEN  RETURN (the_complex_numbers); END_IF;
  IF subspace_of_es(spc,es_numbers)  THEN  RETURN (the_numbers);   END_IF;
  RETURN (?);
END_FUNCTION;

FUNCTION number_tuple_subspace_check
	(spc: maths_space) : LOGICAL;
  LOCAL
    types : SET OF STRING := stripped_typeof(spc);
    factors : LIST OF maths_space;
    cum : LOGICAL := TRUE;
  END_LOCAL;
  IF 'UNIFORM_PRODUCT_SPACE' IN types THEN
    RETURN (subspace_of_es(spc\uniform_product_space.base,es_numbers));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN types THEN
    factors := spc\listed_product_space.factors;
    REPEAT i := 1 TO SIZEOF (factors);
      cum := cum AND subspace_of_es(factors[i],es_numbers);
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types THEN
    cum := subspace_of_es(spc\extended_tuple_space.extender,es_numbers);
    cum := cum AND number_tuple_subspace_check(spc\extended_tuple_space.base);
    RETURN (cum);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

FUNCTION one_tuples_of
	(spc: maths_space) : tuple_space;
RETURN (make_uniform_product_space (spc, 1));
END_FUNCTION;

FUNCTION open_shell_reversed
	(a_shell: open_shell) : oriented_open_shell;
   LOCAL
     the_reverse : oriented_open_shell;
   END_LOCAL;
   IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_OPEN_SHELL' IN TYPEOF (a_shell) ) THEN
     the_reverse := dummy_tri ||
                  connected_face_set (
                      a_shell\connected_face_set.cfs_faces) ||
                  open_shell () || oriented_open_shell(
                    a_shell\oriented_open_shell.open_shell_element,
                      (NOT (a_shell\oriented_open_shell.orientation)));
   ELSE
     the_reverse := dummy_tri ||
                 connected_face_set (
                     a_shell\connected_face_set.cfs_faces) ||
                 open_shell () ||  oriented_open_shell (a_shell, FALSE);
   END_IF;
   RETURN (the_reverse);
END_FUNCTION;

FUNCTION orthogonal_complement
	(vec: direction) : direction;
   LOCAL
     result :  direction ;
   END_LOCAL;

   IF (vec.dim <> 2) OR NOT EXISTS (vec) THEN
     RETURN(?);
   ELSE
     result := dummy_gri || direction([-vec.direction_ratios[2],
                                          vec.direction_ratios[1]]);
     RETURN(result);
   END_IF;
END_FUNCTION;

FUNCTION parallel_composed_function_composability_check
	(funcs: LIST [0:?] OF maths_function; final: maths_function_select) : BOOLEAN;
  LOCAL
    tplsp : tuple_space := the_zero_tuple_space;
    finfun : maths_function := convert_to_maths_function (final);
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF (funcs);
    tplsp := assoc_product_space (tplsp, funcs[i].range);
  END_REPEAT;
  RETURN (compatible_spaces (tplsp, finfun.domain));
END_FUNCTION;

FUNCTION parallel_composed_function_domain_check
	(comdom: tuple_space; funcs: LIST [0:?] OF maths_function) : BOOLEAN;
REPEAT i := 1 TO SIZEOF (funcs);
    IF NOT (compatible_spaces (comdom, funcs[i].domain)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;

FUNCTION parse_express_identifier
	(s: STRING; i: positive_integer) : positive_integer;
  LOCAL
    k : positive_integer;
  END_LOCAL;
  k := i;
  IF i <= LENGTH (s) THEN
    IF (s[i] LIKE '@') THEN
      REPEAT UNTIL (k > LENGTH (s)) OR
        ((s[k] <> '_') AND NOT (s[k] LIKE '@') AND NOT (s[k] LIKE '#'));
        k := k + 1;
      END_REPEAT;
    END_IF;
  END_IF;
  RETURN (k);
END_FUNCTION;

FUNCTION partial_derivative_check
	(domain: tuple_space; d_vars: LIST [1:?] OF input_selector) : BOOLEAN;
  LOCAL
    domn : tuple_space := domain;
    fspc : maths_space;
    dim : INTEGER;
    k : INTEGER;
  END_LOCAL;
  IF (space_dimension (domain) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (domain))) THEN
    domn := factor1 (domain);
  END_IF;
  dim := space_dimension (domn);
  REPEAT i := 1 TO SIZEOF (d_vars);
    k := d_vars[i];
    IF k > dim THEN
       RETURN (FALSE);
    END_IF;
    fspc := factor_space (domn, k);
    IF (NOT subspace_of_es (fspc,es_reals)) AND
      (NOT subspace_of_es (fspc,es_complex_numbers)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;

FUNCTION path_head_to_tail
	(a_path: path) : LOGICAL;
   LOCAL
     n : INTEGER;
     p : LOGICAL := TRUE;
   END_LOCAL;
     
     n := SIZEOF (a_path.edge_list);
     REPEAT i := 2 TO n;
       p := p AND (a_path.edge_list[i-1].edge_end :=:
                   a_path.edge_list[i].edge_start);
     END_REPEAT;
     
     RETURN (p);
END_FUNCTION;

FUNCTION path_reversed
	(a_path: path) : oriented_path;
  LOCAL
    the_reverse : oriented_path ;
  END_LOCAL;
  IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_PATH' IN TYPEOF (a_path) ) THEN
    the_reverse := dummy_tri ||
       path(list_of_topology_reversed (a_path.edge_list)) ||
          oriented_path(a_path\oriented_path.path_element,
                          NOT(a_path\oriented_path.orientation)) ;
  ELSE
    the_reverse := dummy_tri ||
                   path(list_of_topology_reversed (a_path.edge_list)) ||
                       oriented_path(a_path, FALSE);
  END_IF;

  RETURN (the_reverse);
END_FUNCTION;

FUNCTION real_max
	(spc: maths_space) : REAL;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) THEN
    RETURN (spc\finite_integer_interval.max);
  END_IF;
  IF ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types) THEN
    RETURN (spc\integer_interval_to_max.max);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (spc\finite_real_interval.max);
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types) THEN
    RETURN (spc\real_interval_to_max.max);
  END_IF;
  RETURN (?);
END_FUNCTION;

FUNCTION real_min
	(spc: maths_space) : REAL;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) THEN
    RETURN (spc\finite_integer_interval.min);
  END_IF;
  IF ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (spc\integer_interval_from_min.min);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (spc\finite_real_interval.min);
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (spc\real_interval_from_min.min);
  END_IF;
  RETURN (?);
END_FUNCTION;

FUNCTION regular_indexing
	(sub: LIST [0:?] OF INTEGER; base: zero_or_one; shape: LIST [1:?] OF positive_integer; inc: LIST [1:?] OF INTEGER; first: INTEGER) : INTEGER;
  LOCAL
    k : INTEGER;
    index : INTEGER;
  END_LOCAL;
  IF NOT EXISTS (sub) OR NOT EXISTS (base) OR NOT EXISTS (shape) OR
    NOT EXISTS (inc) OR NOT EXISTS (first) THEN
    RETURN (?);
  END_IF;
  IF (SIZEOF (sub) <> SIZEOF (inc)) OR (SIZEOF (sub) <> SIZEOF (shape)) THEN
    RETURN (?);
  END_IF;
  index := first;
  REPEAT j := 1 TO SIZEOF (sub);
    IF NOT EXISTS (sub[j]) OR NOT EXISTS (inc[j]) THEN
      RETURN (?);
    END_IF;
    k := sub[j] - base;
    IF NOT ({0 <= k < shape[j]}) THEN
      RETURN (?);
    END_IF;
    index := index + k*inc[j];
  END_REPEAT;
  RETURN (index);
END_FUNCTION;

FUNCTION remove_first
	(alist: LIST [0:?] OF GENERIC: GEN) : LIST [0:?] OF GENERIC: GEN;
  LOCAL
    blist : LIST OF GENERIC:GEN := alist;
  END_LOCAL;
  IF SIZEOF (blist) > 0 THEN
    REMOVE (blist, 1);
  END_IF;
  RETURN (blist);
END_FUNCTION;

FUNCTION repackage
	(tspace: tuple_space; repckg: repackage_options) : tuple_space;
CASE repckg OF
  ro_nochange : RETURN (tspace);
  ro_wrap_as_tuple : RETURN (one_tuples_of (tspace));
  ro_unwrap_tuple : RETURN (factor1 (tspace));
  OTHERWISE : RETURN (?);
  END_CASE;
END_FUNCTION;

FUNCTION required_0d_nodes
	(node_list: LIST [1:?] OF node_representation) : BOOLEAN;
RETURN (SIZEOF (node_list) = 1);
END_FUNCTION;

FUNCTION required_1d_nodes
	(node_list: LIST [1:?] OF node_representation; order: element_order) : BOOLEAN;
  LOCAL
   end_nodes                : INTEGER;
   additional_nodes         : INTEGER;
  END_LOCAL;

  end_nodes := 2;

  IF (order = linear) THEN
    additional_nodes := 0;
  END_IF;
  IF (order = quadratic) THEN
    additional_nodes := 1;
  END_IF;
  IF (order = cubic) THEN
    additional_nodes := 2;
  END_IF;

  RETURN (SIZEOF (node_list) = end_nodes + additional_nodes);
END_FUNCTION;

FUNCTION required_2d_nodes
	(node_list: LIST [1:?] OF node_representation; element_shape: element_2d_shape; order: element_order) : BOOLEAN;
  LOCAL
    vertex_nodes            : INTEGER;
    edge_nodes              : INTEGER;
    edge_face_body_nodes    : INTEGER;
  END_LOCAL;

  IF (element_shape = element_2d_shape.triangle) THEN
    vertex_nodes := 3;
    IF (order = linear) THEN
      edge_nodes           := 0;
      edge_face_body_nodes := 0;
    END_IF;
    IF (order = quadratic) THEN
      edge_nodes           := 3;
      edge_face_body_nodes := 3;
    END_IF;
    IF (order = cubic) THEN
      edge_nodes           := 6;
      edge_face_body_nodes := 7;
    END_IF;
  END_IF;

  IF (element_shape = element_2d_shape.quadrilateral) THEN
    vertex_nodes := 4;
    IF (order = linear) THEN
      edge_nodes           := 0;
      edge_face_body_nodes := 0;
    END_IF;
    IF (order = quadratic) THEN
      edge_nodes           := 4;
      edge_face_body_nodes := 5;
    END_IF;
    IF (order = cubic) THEN
      edge_nodes           := 8;
      edge_face_body_nodes := 12;
    END_IF;
  END_IF;

  RETURN ((SIZEOF (node_list) = vertex_nodes + edge_nodes) OR 
          (SIZEOF (node_list) = vertex_nodes + edge_face_body_nodes));
END_FUNCTION;

FUNCTION required_3d_nodes
	(node_list: LIST [1:?] OF node_representation; element_shape: volume_3d_element_shape; order: element_order) : BOOLEAN;
  LOCAL
    vertex_nodes            : INTEGER;
    edge_nodes              : INTEGER;
    edge_face_body_nodes    : INTEGER;
  END_LOCAL;

  IF (element_shape = volume_3d_element_shape.hexahedron) THEN
    vertex_nodes := 8;
    IF (order = linear) THEN
      edge_nodes           := 0;
      edge_face_body_nodes := 0;
    END_IF;
    IF (order = quadratic) THEN
      edge_nodes           := 12;
      edge_face_body_nodes := 19;
    END_IF;
    IF (order = cubic) THEN
      edge_nodes           := 24;
      edge_face_body_nodes := 56;
    END_IF;
  END_IF;

  IF (element_shape = volume_3d_element_shape.wedge) THEN
    vertex_nodes := 6;
    IF (order = linear) THEN
      edge_nodes           := 0;
      edge_face_body_nodes := 0;
    END_IF;
    IF (order = quadratic) THEN
      edge_nodes           := 9;
      edge_face_body_nodes := 12;
    END_IF;
    IF (order = cubic) THEN
      edge_nodes           := 18;
      edge_face_body_nodes := 34;
    END_IF;
  END_IF;

  IF (element_shape = volume_3d_element_shape.tetrahedron) THEN
    vertex_nodes := 4;
    IF (order = linear) THEN
      edge_nodes           := 0;
      edge_face_body_nodes := 0;
    END_IF;
    IF (order = quadratic) THEN
      edge_nodes           := 6;
      edge_face_body_nodes := 6;
    END_IF;
    IF (order = cubic) THEN
      edge_nodes           := 12;
      edge_face_body_nodes := 16;
    END_IF;
  END_IF;

  IF (element_shape = volume_3d_element_shape.pyramid) THEN
    vertex_nodes := 5;
    IF (order = linear) THEN
      edge_nodes           := 0;
      edge_face_body_nodes := 0;
    END_IF;
    IF (order = quadratic) THEN
      edge_nodes           := 8;
      edge_face_body_nodes := 9;
    END_IF;
    IF (order = cubic) THEN
      edge_nodes           := 16;
      edge_face_body_nodes := 25;
    END_IF;
  END_IF;

  RETURN ((SIZEOF (node_list) = vertex_nodes + edge_nodes) OR 
          (SIZEOF (node_list) = vertex_nodes + edge_face_body_nodes));
END_FUNCTION;

FUNCTION scalar_times_vector
	(scalar: REAL; vec: vector_or_direction) : vector;
    LOCAL
      v      : direction;
      mag    : REAL;
      result : vector;
    END_LOCAL;
 
    IF NOT EXISTS (scalar) OR NOT EXISTS (vec) THEN
      RETURN (?) ;
     ELSE
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VECTOR' IN TYPEOF (vec) THEN
        v   := dummy_gri || direction(vec\vector.orientation.direction_ratios);
        mag := scalar * vec.magnitude;
      ELSE
        v   := dummy_gri || direction(vec.direction_ratios);
        mag := scalar;
      END_IF;
      IF (mag < 0.0 ) THEN
        REPEAT i := 1 TO SIZEOF(v.direction_ratios);
          v.direction_ratios[i] := -v.direction_ratios[i];
        END_REPEAT;
        mag := -mag;
      END_IF;
      result := dummy_gri || vector(normalise(v), mag);
    END_IF;
    RETURN (result);
END_FUNCTION;

FUNCTION second_proj_axis
	(z_axis: direction; x_axis: direction; arg: direction) : direction;
   LOCAL
     y_axis : vector;
     v      : direction;
     temp   : vector;
   END_LOCAL;
   
   IF NOT EXISTS(arg) THEN
     v := dummy_gri || direction([0.0,1.0,0.0]);
   ELSE
     v := arg;
   END_IF;
   
   temp   := scalar_times_vector(dot_product(v, z_axis), z_axis);
   y_axis := vector_difference(v, temp);
   temp   := scalar_times_vector(dot_product(v, x_axis), x_axis);
   y_axis := vector_difference(y_axis, temp);
   y_axis := normalise(y_axis);
   RETURN(y_axis.orientation);
END_FUNCTION;

FUNCTION set_of_topology_reversed
	(a_set: set_of_reversible_topology_item) : set_of_reversible_topology_item;
   LOCAL
     the_reverse : set_of_reversible_topology_item;
   END_LOCAL;
   
   the_reverse := [];
   REPEAT i := 1 TO SIZEOF (a_set);
     the_reverse := the_reverse + topology_reversed (a_set [i]);
   END_REPEAT;
   
   RETURN (the_reverse);
END_FUNCTION;

FUNCTION shape_of_array
	(func: maths_function) : LIST [0:?] OF positive_integer;
  LOCAL
    tspace : tuple_space;
    temp : maths_space;
    result : LIST OF positive_integer := [];
  END_LOCAL;
  IF (schema_prefix + 'EXPLICIT_TABLE_FUNCTION') IN TYPEOF (func) THEN
    RETURN (func\explicit_table_function.shape);
  END_IF;
  tspace := func.domain;
  IF (space_dimension (tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (tspace))) THEN
    tspace := factor1 (tspace);
  END_IF;
  REPEAT i := 1 TO space_dimension (tspace);
    temp := factor_space (tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
      RETURN (?);
    END_IF;
    INSERT (result, temp\finite_integer_interval.size, i-1);
  END_REPEAT;
  RETURN (result);
END_FUNCTION;

FUNCTION shell_reversed
	(a_shell: shell) : shell;
IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OPEN_SHELL' IN TYPEOF (a_shell) ) THEN
     RETURN (open_shell_reversed (a_shell));
   ELSE
     IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CLOSED_SHELL' IN TYPEOF (a_shell) ) THEN
       RETURN (closed_shell_reversed (a_shell));
     ELSE
       RETURN (?);
     END_IF;
   END_IF;
END_FUNCTION;

FUNCTION shorten_array
	(longa: ARRAY OF GENERIC: T; oldl: INTEGER; newl: INTEGER) : ARRAY OF GENERIC: T;
   LOCAL
     shorta : ARRAY [1:newl] OF GENERIC : T;
   END_LOCAL;

   IF (newl > oldl) THEN
     RETURN(?);
   ELSE
     REPEAT i := 1 TO newl;
       shorta[i] := longa[i];
     END_REPEAT;
     RETURN(shorta);
   END_IF;
END_FUNCTION;

FUNCTION simplify_function_application
	(expr: function_application) : maths_value;
FUNCTION ctmv(x : GENERIC:G) : maths_value;
    RETURN (convert_to_maths_value(x));
  END_FUNCTION;  -- local abbreviation for convert_to_maths_value function
  PROCEDURE parts(       c : complex_number_literal;
                  VAR x, y : REAL);
    x := c.real_part;  y := c.imag_part;
  END_PROCEDURE;  -- parts
  FUNCTION makec(x, y : REAL) : complex_number_literal;
    RETURN (make_complex_number_literal(x,y));
  END_FUNCTION;  -- local abbreviation for make_complex_number_literal function
  FUNCTION good_t(v  : maths_value;
                  tn : STRING) : BOOLEAN;
    LOCAL
      tpl : LIST OF maths_value;
    END_LOCAL;
    IF 'LIST' IN TYPEOF (v) THEN
      tpl := v;
      REPEAT i := 1 TO SIZEOF (tpl);
        IF NOT (tn IN TYPEOF (tpl[i])) THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    RETURN (FALSE);
  END_FUNCTION;  -- good_t
  CONSTANT
    cnlit : STRING := schema_prefix + 'COMPLEX_NUMBER_LITERAL';
  END_CONSTANT;
  LOCAL
    types : SET OF STRING := stripped_typeof(expr.func);
    ef_val : elementary_function_enumerators;
    is_elementary : BOOLEAN := FALSE;
    v, v1, v2, v3 : maths_value;
    vlist : LIST OF maths_value := [];
    gexpr : generic_expression;
    pairs : SET [1:?] OF LIST [2:2] OF maths_value;
    boo : BOOLEAN;
    lgc, cum : LOGICAL;
    j, k, n : INTEGER;
    p, q, r, s, t, u : REAL;
    str, st2 : STRING;
    bin, bi2 : BINARY;
    tpl, tp2 : LIST OF maths_value;
    mem :SET OF maths_value := [];
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF (expr.arguments);
    v := simplify_maths_value(expr.arguments[i]);
    INSERT (vlist, v, i-1);
  END_REPEAT;
  IF SIZEOF (vlist) >= 1 THEN  v1 := vlist[1];  END_IF;
  IF SIZEOF (vlist) >= 2 THEN  v2 := vlist[2];  END_IF;
  IF SIZEOF (vlist) >= 3 THEN  v3 := vlist[3];  END_IF;
  IF 'ELEMENTARY_FUNCTION_ENUMERATORS' IN types THEN
    ef_val := expr.func;
    is_elementary := TRUE;
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN types THEN
    ef_val := expr.func\elementary_function.func_id;
    is_elementary := TRUE;
  END_IF;
  IF is_elementary THEN
    CASE ef_val OF
    ef_and : BEGIN
      cum := TRUE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'LOGICAL' IN TYPEOF (vlist[i]) THEN
          lgc := vlist[i];  cum := cum AND lgc;
          IF lgc = FALSE THEN  RETURN (ctmv(FALSE));  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(cum));  END_IF;
      IF cum <> TRUE THEN  INSERT (vlist, ctmv(cum), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_or : BEGIN
      cum := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'LOGICAL' IN TYPEOF (vlist[i]) THEN
          lgc := vlist[i];  cum := cum OR lgc;
          IF lgc = TRUE THEN  RETURN (ctmv(TRUE));  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(cum));  END_IF;
      IF cum <> FALSE THEN  INSERT (vlist, ctmv(cum), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_not :
      IF 'LOGICAL' IN TYPEOF (v1) THEN  lgc := v1;  RETURN (ctmv(NOT lgc));  END_IF;
    ef_xor : BEGIN
      IF 'LOGICAL' IN TYPEOF (v1) THEN
        lgc := v1;
        IF 'LOGICAL' IN TYPEOF (v2) THEN  cum := v2;  RETURN (ctmv(lgc XOR cum));
        ELSE IF lgc = FALSE THEN  RETURN (ctmv(v2));
        ELSE IF lgc = UNKNOWN THEN  RETURN (ctmv(UNKNOWN));
        ELSE  RETURN (make_function_application(ef_not,[v2]));
        END_IF;  END_IF;  END_IF;
      ELSE IF 'LOGICAL' IN TYPEOF (v2) THEN
        lgc := v2;
        IF lgc = FALSE THEN  RETURN (ctmv(v1));
        ELSE IF lgc = UNKNOWN THEN  RETURN (ctmv(UNKNOWN));
        ELSE  RETURN (make_function_application(ef_not,[v1]));
        END_IF;  END_IF;
      END_IF;  END_IF;
      END;
    ef_negate_i :
      IF 'INTEGER' IN TYPEOF (v1) THEN  j := v1;  RETURN (ctmv(-j));  END_IF;
    ef_add_i : BEGIN
      j := 0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'INTEGER' IN TYPEOF (vlist[i]) THEN
          k := vlist[i];  j := j + k;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(j));  END_IF;
      IF j <> 0 THEN  INSERT (vlist, ctmv(j), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j - k));
      END_IF;
    ef_multiply_i : BEGIN
      j := 1;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'INTEGER' IN TYPEOF (vlist[i]) THEN
          k := vlist[i];  j := j * k;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(j));  END_IF;
      IF j <> 1 THEN  INSERT (vlist, ctmv(j), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_divide_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j DIV k));
      END_IF;
    ef_mod_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j MOD k));
      END_IF;
    ef_exponentiate_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  n := 1;
        REPEAT i := 1 TO ABS(k);  n := n * j;  END_REPEAT;
        IF k < 0 THEN  n := 1 DIV n;  END_IF;
        RETURN (ctmv(n));
      END_IF;
    ef_eq_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j = k));
      END_IF;
    ef_ne_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j <> k));
      END_IF;
    ef_gt_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j > k));
      END_IF;
    ef_lt_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j < k));
      END_IF;
    ef_ge_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j >= k));
      END_IF;
    ef_le_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j <= k));
      END_IF;
    ef_abs_i :
      IF 'INTEGER' IN TYPEOF (v1) THEN  j := v1;  RETURN (ctmv(ABS(j)));  END_IF;
    ef_max_i : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'INTEGER' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  k := vlist[i];  IF k > j THEN  j := k;  END_IF;
          ELSE  j := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(j));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(j), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_min_i : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'INTEGER' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  k := vlist[i];  IF k < j THEN  j := k;  END_IF;
          ELSE  j := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(j));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(j), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    -- ef_if_i : combined with ef_if
    ef_negate_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(-r));  END_IF;
    ef_reciprocal_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(1.0/r));  END_IF;
    ef_add_r : BEGIN
      r := 0.0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'REAL' IN TYPEOF (vlist[i]) THEN
          s := vlist[i];  r := r + s;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(r));  END_IF;
      IF r <> 0.0 THEN  INSERT (vlist, ctmv(r), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r - s));
      END_IF;
    ef_multiply_r : BEGIN
      r := 1.0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'REAL' IN TYPEOF (vlist[i]) THEN
          s := vlist[i];  r := r * s;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(r));  END_IF;
      IF r <> 1.0 THEN  INSERT (vlist, ctmv(r), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_divide_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r / s));
      END_IF;
    ef_mod_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  t := r/s;  j := t DIV 1;
        IF (t < 0.0) AND (j <> t) THEN  j := j - 1;  END_IF;
        RETURN (ctmv(r - j * s));
      END_IF;
    ef_exponentiate_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r ** s));
      END_IF;
    ef_exponentiate_ri :
      IF ('REAL' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        r := v1;  k := v2;  t := 1.0;
        REPEAT i := 1 TO ABS(k);  t := t * r;  END_REPEAT;
        IF k < 0 THEN  t := 1.0/t;  END_IF;
        RETURN (ctmv(t));
      END_IF;
    ef_eq_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r = s));
      END_IF;
    ef_ne_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r <> s));
      END_IF;
    ef_gt_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r > s));
      END_IF;
    ef_lt_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r < s));
      END_IF;
    ef_ge_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r >= s));
      END_IF;
    ef_le_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r <= s));
      END_IF;
    ef_abs_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(ABS(r)));  END_IF;
    ef_max_r : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'REAL' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  s := vlist[i];  IF s > r THEN  r := s;  END_IF;
          ELSE  r := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(r));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(r), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_min_r : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'REAL' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  s := vlist[i];  IF s < r THEN  r := s;  END_IF;
          ELSE  r := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(r));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(r), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_acos_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(ACOS(r)));  END_IF;
    ef_asin_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(ASIN(r)));  END_IF;
    ef_atan2_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(atan2(r,s)));
      END_IF;
    ef_cos_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(COS(r)));  END_IF;
    ef_exp_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(EXP(r)));  END_IF;
    ef_ln_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(LOG(r)));  END_IF;
    ef_log2_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(LOG2(r)));  END_IF;
    ef_log10_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(LOG10(r)));  END_IF;
    ef_sin_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(SIN(r)));  END_IF;
    ef_sqrt_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(SQRT(r)));  END_IF;
    ef_tan_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(TAN(r)));  END_IF;
    -- ef_if_r : combined with ef_if
    ef_form_c :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (makec(r,s));
      END_IF;
    ef_rpart_c :
      IF cnlit IN TYPEOF (v1) THEN
        RETURN (ctmv(v1\complex_number_literal.real_part));
      END_IF;
    ef_ipart_c :
      IF cnlit IN TYPEOF (v1) THEN
        RETURN (ctmv(v1\complex_number_literal.imag_part));
      END_IF;
    ef_negate_c :
      IF cnlit IN TYPEOF (v1) THEN  parts(v1,p,q);  RETURN (makec(-p,-q));  END_IF;
    ef_reciprocal_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := p*p + q*q;  RETURN (makec(p/t,-q/t));
      END_IF;
    ef_add_c : BEGIN
      p := 0.0;  q := 0.0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF cnlit IN TYPEOF (vlist[i]) THEN
          parts(vlist[i],r,s);  p := p + r;  q := q + s;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (makec(p,q));  END_IF;
      IF p*p+q*q <> 0.0 THEN  INSERT (vlist, makec(p,q), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  RETURN (makec(p-r,q-s));
      END_IF;
    ef_multiply_c : BEGIN
      p := 1.0;  q := 0.0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF cnlit IN TYPEOF (vlist[i]) THEN
          parts(vlist[i],r,s);  p := p*r-q*s;  q := p*s+q*r;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (makec(p,q));  END_IF;
      IF (p <> 1.0) OR (q <> 0.0) THEN  INSERT (vlist, makec(p,q), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_divide_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  t := r*r+s*s;
        RETURN (makec((p*r+q*s)/t,(q*r-p*s)/t));
      END_IF;
    ef_exponentiate_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  t := 0.5*LOG(p*p+q*q);  u := atan2(q,p);
        p := r*t-s*u;  q := r*u+s*t;  r := EXP(p);
        RETURN (makec(r*COS(q),r*SIN(q)));
      END_IF;
    ef_exponentiate_ci :
      IF (cnlit IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        parts(v1,p,q);  k := v2;  r := 1.0;  s := 0.0;
        REPEAT i := 1 TO ABS(k);  r := p*r-q*s;  s := p*s+q*r;  END_REPEAT;
        IF k < 0 THEN  t := r*r+s*s;  r := r/t;  s := -s/t;  END_IF;
        RETURN (makec(r,s));
      END_IF;
    ef_eq_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  RETURN (ctmv((p = r) AND (q = s)));
      END_IF;
    ef_ne_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  RETURN (ctmv((p <> r) OR (q <> s)));
      END_IF;
    ef_conjugate_c :
      IF cnlit IN TYPEOF (v1) THEN  parts(v1,p,q);  RETURN (makec(p,-q));  END_IF;
    ef_abs_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  RETURN (ctmv(SQRT(p*p+q*q)));
      END_IF;
    ef_arg_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  RETURN (ctmv(atan2(q,p)));
      END_IF;
    ef_cos_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := 0.5*EXP(-q);  u := 0.5*EXP(q);
        RETURN (makec((t+u)*COS(p),(t-u)*SIN(p)));
      END_IF;
    ef_exp_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  RETURN (makec(EXP(p)*COS(q),EXP(p)*SIN(q)));
      END_IF;
    ef_ln_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  RETURN (makec(0.5*LOG(p*p+q*q),atan2(q,p)));
      END_IF;
    ef_sin_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := 0.5*EXP(-q);  u := 0.5*EXP(q);
        RETURN (makec((t+u)*SIN(p),(u-t)*COS(p)));
      END_IF;
    ef_sqrt_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := SQRT(SQRT(p*p+q*q));  u := 0.5*atan2(q,p);
        RETURN (makec(t*COS(u),t*SIN(u)));
      END_IF;
    ef_tan_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := EXP(2.0*q) + EXP(-2.0*q) + 2.0*COS(2.0*p);
        RETURN (makec(2.0*SIN(2.0*p)/t,(EXP(-2.0*q)-EXP(2.0*q))/t));
      END_IF;
    -- ef_if_c : combined with ef_if
    ef_subscript_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        str := v1;  k := v2;  RETURN (ctmv(str[k]));
      END_IF;
    ef_eq_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str = st2));
      END_IF;
    ef_ne_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str <> st2));
      END_IF;
    ef_gt_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str > st2));
      END_IF;
    ef_lt_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str < st2));
      END_IF;
    ef_ge_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str >= st2));
      END_IF;
    ef_le_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str <= st2));
      END_IF;
    ef_subsequence_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) AND
        ('INTEGER' IN TYPEOF (v3)) THEN
        str := v1;  j := v2;  k := v3;  RETURN (ctmv(str[j:k]));
      END_IF;
    ef_concat_s : BEGIN
      str := '';
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'STRING' IN TYPEOF (vlist[i]) THEN
          st2 := vlist[i];  str := str + st2;
          REMOVE (vlist, i);
        ELSE IF str <> '' THEN
          INSERT (vlist, ctmv(str), i);
          str := '';
        END_IF;  END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(str));  END_IF;
      IF str <> '' THEN  INSERT (vlist, ctmv(str), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_size_s :
      IF 'STRING' IN TYPEOF (v1) THEN  str:=v1;  RETURN (ctmv(LENGTH(str)));  END_IF;
    ef_format :
      IF ('NUMBER' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        RETURN (ctmv(FORMAT(v1,v2)));
      END_IF;
    ef_value :
      IF 'STRING' IN TYPEOF (v1) THEN  str:=v1;  RETURN (ctmv(VALUE(str)));  END_IF;
    ef_like :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        RETURN (ctmv(v1 LIKE v2));
      END_IF;
    -- ef_if_s : combined with ef_if
    ef_subscript_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        bin := v1;  k := v2;  RETURN (ctmv(bin[k]));
      END_IF;
    ef_eq_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin = bi2));
      END_IF;
    ef_ne_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin <> bi2));
      END_IF;
    ef_gt_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin > bi2));
      END_IF;
    ef_lt_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin < bi2));
      END_IF;
    ef_ge_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin >= bi2));
      END_IF;
    ef_le_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin <= bi2));
      END_IF;
    ef_subsequence_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) AND
        ('INTEGER' IN TYPEOF (v3)) THEN
        bin := v1;  j := v2;  k := v3;  RETURN (ctmv(bin[j:k]));
      END_IF;
    ef_concat_b : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'BINARY' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  bi2 := vlist[i];  bin := bin + bi2;
          ELSE         bin := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        ELSE IF boo THEN
          INSERT (vlist, ctmv(bin), i);
          boo := FALSE;
        END_IF;  END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(bin));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(bin), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_size_b :
      IF 'BINARY' IN TYPEOF (v1) THEN  bin:=v1;  RETURN (ctmv(BLENGTH(bin)));  END_IF;
    -- ef_if_b : combined with ef_if
    ef_subscript_t :
      IF ('LIST' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        tpl := v1;  k := v2;  RETURN (ctmv(tpl[k]));
      END_IF;
    ef_eq_t :
      IF ('LIST' IN TYPEOF (v1)) AND ('LIST' IN TYPEOF (v2)) THEN
        lgc := equal_maths_values(v1,v2);
        IF lgc <> UNKNOWN THEN  RETURN (ctmv(lgc));  END_IF;
      END_IF;
    ef_ne_t :
      IF ('LIST' IN TYPEOF (v1)) AND ('LIST' IN TYPEOF (v2)) THEN
        lgc := equal_maths_values(v1,v2);
        IF lgc <> UNKNOWN THEN  RETURN (ctmv(NOT lgc));  END_IF;
      END_IF;
    ef_concat_t : BEGIN
      tpl := [];
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'STRING' IN TYPEOF (vlist[i]) THEN
          tp2 := vlist[i];  tpl := tpl + tp2;
          REMOVE (vlist, i);
        ELSE IF SIZEOF (tpl) <> 0 THEN
          INSERT (vlist, ctmv(tpl), i);
          tpl := [];
        END_IF;  END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(tpl));  END_IF;
      IF SIZEOF (tpl) <> 0 THEN  INSERT (vlist, ctmv(tpl), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_size_t :
      IF 'LIST' IN TYPEOF (v1) THEN  tpl:=v1;  RETURN (ctmv(SIZEOF(tpl)));  END_IF;
    ef_entuple :
      RETURN (ctmv(vlist));
    ef_detuple :  -- This can have multiple outputs, but the expression only
                  -- denotes the first.
      IF 'LIST' IN TYPEOF (v1) THEN  tpl:=v1;  RETURN (ctmv(tpl[1]));  END_IF;
    ef_insert :
      IF ('LIST' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v3)) THEN
        tpl := v1;  k := v3;  INSERT (tpl, v2, k);  RETURN (ctmv(tpl));
      END_IF;
    ef_remove :
      IF ('LIST' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        tpl := v1;  k := v2;  REMOVE (tpl, k);  RETURN (ctmv(tpl));
      END_IF;
    -- ef_if_t : combined with ef_if
    ef_sum_it :
      IF good_t(v1,'INTEGER') THEN
        tpl := v1;  j := 0;
        REPEAT i := 1 TO SIZEOF (tpl);  j := j + tpl[i];  END_REPEAT;
        RETURN (ctmv(j));
      END_IF;
    ef_product_it :
      IF good_t(v1,'INTEGER') THEN
        tpl := v1;  j := 1;
        REPEAT i := 1 TO SIZEOF (tpl);  j := j * tpl[i];  END_REPEAT;
        RETURN (ctmv(j));
      END_IF;
    ef_add_it : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF good_t(vlist[i],'INTEGER') THEN
          IF NOT boo THEN  tpl := vlist[i];  boo := TRUE;
          ELSE
            tp2 := vlist[i];
            IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
            REPEAT l := 1 TO SIZEOF (tpl);  tpl[j] := tpl[j] + tp2[j];  END_REPEAT;
          END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(tpl));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(tpl), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_it :
      IF good_t(v1,'INTEGER') AND good_t(v2,'INTEGER') THEN
        tpl := v1;  tp2 := v2;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);  tpl[i] := tpl[i] - tp2[i];  END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_scalar_mult_it :
      IF ('INTEGER' IN TYPEOF (v1)) AND good_t(v2,'INTEGER') THEN
        j := v1;  tpl := v2;
        REPEAT i := 1 TO SIZEOF (tpl);  tpl[i] := j * tpl[i];  END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_dot_prod_it :
      IF good_t(v1,'INTEGER') AND good_t(v2,'INTEGER') THEN
        tpl := v1;  tp2 := v2;  j := 0;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);  j := j + tpl[i] * tp2[i];  END_REPEAT;
        RETURN (ctmv(j));
      END_IF;
    ef_sum_rt :
      IF good_t(v1,'REAL') THEN
        tpl := v1;  r := 0.0;
        REPEAT i := 1 TO SIZEOF (tpl);  r := r + tpl[i];  END_REPEAT;
        RETURN (ctmv(r));
      END_IF;
    ef_product_rt :
      IF good_t(v1,'REAL') THEN
        tpl := v1;  r := 1.0;
        REPEAT i := 1 TO SIZEOF (tpl);  r := r * tpl[i];  END_REPEAT;
        RETURN (ctmv(r));
      END_IF;
    ef_add_rt : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF good_t(vlist[i],'REAL') THEN
          IF NOT boo THEN  tpl := vlist[i];  boo := TRUE;
          ELSE
            tp2 := vlist[i];
            IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
            REPEAT l := 1 TO SIZEOF (tpl);  tpl[j] := tpl[j] + tp2[j];  END_REPEAT;
          END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(tpl));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(tpl), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_rt :
      IF good_t(v1,'REAL') AND good_t(v2,'REAL') THEN
        tpl := v1;  tp2 := v2;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);  tpl[i] := tpl[i] - tp2[i];  END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_scalar_mult_rt :
      IF ('REAL' IN TYPEOF (v1)) AND good_t(v2,'REAL') THEN
        r := v1;  tpl := v2;
        REPEAT i := 1 TO SIZEOF (tpl);  tpl[i] := r * tpl[i];  END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_dot_prod_rt :
      IF good_t(v1,'REAL') AND good_t(v2,'REAL') THEN
        tpl := v1;  tp2 := v2;  r := 0;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);  r := r + tpl[i] * tp2[i];  END_REPEAT;
        RETURN (ctmv(r));
      END_IF;
    ef_norm_rt :
      IF good_t(v1,'REAL') THEN
        tpl := v1;  r := 0.0;
        REPEAT i := 1 TO SIZEOF (tpl);  r := r + tpl[i]*tpl[i];  END_REPEAT;
        RETURN (ctmv(SQRT(r)));
      END_IF;
    ef_sum_ct :
      IF good_t(v1,cnlit) THEN
        tpl := v1;  p := 0.0;  q := 0.0;
        REPEAT i:=1 TO SIZEOF (tpl);  parts(tpl[i],r,s);  p:=p+r;  q:=q+s;  END_REPEAT;
        RETURN (makec(p,q));
      END_IF;
    ef_product_ct :
      IF good_t(v1,cnlit) THEN
        tpl := v1;  p := 1.0;  q := 0.0;
        REPEAT i := 1 TO SIZEOF (tpl);
          parts(tpl[i],r,s);  p := p*r-q*s;  q := p*s+q*r;
        END_REPEAT;
        RETURN (makec(p,q));
      END_IF;
    ef_add_ct : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF good_t(vlist[i],cnlit) THEN
          IF NOT boo THEN  tpl := vlist[i];  boo := TRUE;
          ELSE
            tp2 := vlist[i];
            IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
            REPEAT l := 1 TO SIZEOF (tpl);
              parts(tpl[j],p,q); parts(tp2[j],r,s);  tpl[j] := makec(p+r,q+s);
            END_REPEAT;
          END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(tpl));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(tpl), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_ct :
      IF good_t(v1,cnlit) AND good_t(v2,cnlit) THEN
        tpl := v1;  tp2 := v2;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);
          parts(tpl[i],p,q);  parts(tp2[i],r,s);  tpl[i] := makec(p-r,q-s);
        END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_scalar_mult_ct :
      IF (cnlit IN TYPEOF (v1)) AND good_t(v2,cnlit) THEN
        parts(v1,p,q);  tpl := v2;
        REPEAT i := 1 TO SIZEOF (tpl);
          parts(tpl[i],r,s);  tpl[i] := makec(p*r-q*s,p*s+q*r);
        END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_dot_prod_ct :
      IF good_t(v1,cnlit) AND good_t(v2,cnlit) THEN
        tpl := v1;  tp2 := v2;  t := 0.0;  u := 0.0;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);
          parts(tpl[i],p,q);  parts(tp2[i],r,s);  t := t + p*r+q*s;  u := u + q*r-p*s;
        END_REPEAT;
        RETURN (makec(t,u));
      END_IF;
    ef_norm_ct :
      IF good_t(v1,cnlit) THEN
        tpl := v1;  r := 0.0;
        REPEAT i := 1 TO SIZEOF (tpl);  parts(tpl[i],p,q);  r:=r+p*p+q*q;  END_REPEAT;
        RETURN (ctmv(SQRT(r)));
      END_IF;
    ef_if, ef_if_i, ef_if_r, ef_if_c, ef_if_s, ef_if_b, ef_if_t :
      IF 'LOGICAL' IN TYPEOF (v1) THEN
        lgc := v1;  IF lgc THEN  RETURN (v2);  ELSE  RETURN (v3);  END_IF;
      END_IF;
    ef_ensemble :   -- (mem + vlist) effectively converts list to set
      RETURN (make_finite_space(mem + vlist));
    ef_member_of :
      IF (schema_prefix + 'MATHS_SPACE') IN TYPEOF (v2) THEN
        lgc := member_of(v1,v2);
        IF lgc <> UNKNOWN THEN  RETURN (ctmv(lgc));  END_IF;
      END_IF;
    END_CASE;
    RETURN (make_function_application(expr.func,vlist));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN types THEN
    gexpr := substitute(expr.func\abstracted_expression_function.expr,
      expr.func\quantifier_expression.variables,vlist);
    RETURN (simplify_generic_expression(gexpr));
  END_IF;
  IF 'FINITE_FUNCTION' IN types THEN
    pairs := expr.func\finite_function.pairs;
    REPEAT i := 1 TO SIZEOF (pairs);
      IF equal_maths_values(vlist[1],pairs[i][1]) THEN
        RETURN (simplify_maths_value(pairs[i][2]));
      END_IF;
    END_REPEAT;
    RETURN (make_function_application(expr.func,vlist));
  END_IF;
  RETURN (expr);
END_FUNCTION;

FUNCTION simplify_generic_expression
	(expr: generic_expression) : maths_value;
FUNCTION restore_unary(expr : unary_generic_expression;
                         opnd : generic_expression) : generic_expression;
    expr.operand := opnd;
    RETURN (expr);
  END_FUNCTION;  
  FUNCTION restore_binary(expr       : binary_generic_expression;
                          opd1, opd2 : generic_expression) : generic_expression;
    expr.operands[1] := opd1;
    expr.operands[2] := opd2;
    RETURN (expr);
  END_FUNCTION;  
  FUNCTION restore_mulary(expr : multiple_arity_generic_expression;
                          ops  : LIST OF generic_expression) : generic_expression;
    expr.operands := ops;
    RETURN (expr);
  END_FUNCTION;  
  FUNCTION make_number_literal(nmb : NUMBER) : generic_literal;
    IF 'INTEGER' IN TYPEOF (nmb) THEN  RETURN (make_int_literal(nmb));  END_IF;
    RETURN (make_real_literal(nmb));
  END_FUNCTION;  
  LOCAL
    types : SET OF STRING := stripped_typeof (expr);
    v1, v2 : maths_value;
    vlist : LIST OF maths_value := [];
    op1, op2 : generic_expression;
    oplist : LIST OF generic_expression := [];
    opnds : LIST [2:?] OF generic_expression;
    n, m : INTEGER;
    finfun : maths_function_select;
    boo : BOOLEAN;
    str : STRING;
    nmb : NUMBER;
  END_LOCAL;
  IF 'INT_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\int_literal.the_value));
  END_IF;
  IF 'REAL_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\real_literal.the_value));
  END_IF;
  IF 'BOOLEAN_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\boolean_literal.the_value));
  END_IF;
  IF 'STRING_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\string_literal.the_value));
  END_IF;
  IF 'COMPLEX_NUMBER_LITERAL' IN types THEN
    RETURN (expr);  
  END_IF;
  IF 'LOGICAL_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\logical_literal.lit_value));
  END_IF;
  IF 'BINARY_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\binary_literal.lit_value));
  END_IF;
  IF 'MATHS_ENUM_LITERAL' IN types THEN
    RETURN (expr\maths_enum_literal.lit_value);
  END_IF;
  IF 'REAL_TUPLE_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\real_tuple_literal.lit_value));
  END_IF;
  IF 'INTEGER_TUPLE_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\integer_tuple_literal.lit_value));
  END_IF;
  IF 'ATOM_BASED_LITERAL' IN types THEN
    RETURN (expr\atom_based_literal.lit_value);
  END_IF;
  IF 'MATHS_TUPLE_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\maths_tuple_literal.lit_value));
  END_IF;
  IF 'MATHS_SPACE' IN types THEN
    RETURN (simplify_maths_space(expr));
  END_IF;
  IF 'FUNCTION_APPLICATION' IN types THEN
    RETURN (simplify_function_application(expr));
  END_IF;
  IF 'UNARY_GENERIC_EXPRESSION' IN types THEN
    v1 := simplify_generic_expression(expr\unary_generic_expression.operand);
    op1 := convert_to_operand(v1);
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types THEN
    v1 := simplify_generic_expression(expr\binary_generic_expression.operands[1]);
    op1 := convert_to_operand(v1);
    v2 := simplify_generic_expression(expr\binary_generic_expression.operands[2]);
    op2 := convert_to_operand(v2);
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF (opnds);
      v1 := simplify_generic_expression(opnds[i]);
      INSERT (vlist, v1, i-1);
      INSERT (oplist, convert_to_operand(v1), i-1);
    END_REPEAT;
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN types THEN
    v1 := vlist[1];
    n := SIZEOF (vlist);
    finfun := vlist[n];
    REMOVE (vlist, n);
    REMOVE (vlist, 1);
    RETURN (make_parallel_composed_function(v1,vlist,finfun));
  END_IF;
  IF ('ABS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (ABS(v1)));
  END_IF;
  IF ('ACOS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (ACOS(v1)));
  END_IF;
  IF 'AND_EXPRESSION' IN types THEN
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'BOOLEAN' IN TYPEOF (vlist[i]) THEN
        boo := vlist[i];
        IF NOT boo THEN  RETURN (convert_to_maths_value(FALSE));  END_IF;
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(TRUE));  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF ('ASIN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (ASIN(v1)));
  END_IF;
  IF ('ATAN_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (ATAN(v1,v2)));
  END_IF;
  IF ('COMPARISON_EXPRESSION' IN types) AND (
    (('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2))) OR
    (('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2))) OR
    (('BOOLEAN' IN TYPEOF (v1)) AND ('BOOLEAN' IN TYPEOF (v2))) ) THEN
    IF      'COMPARISON_EQUAL'         IN types THEN  boo := bool(v1 = v2);
    ELSE IF 'COMPARISON_GREATER'       IN types THEN  boo := bool(v1 > v2);
    ELSE IF 'COMPARISON_GREATER_EQUAL' IN types THEN  boo := bool(v1 >= v2);
    ELSE IF 'COMPARISON_LESS'          IN types THEN  boo := bool(v1 < v2);
    ELSE IF 'COMPARISON_LESS_EQUAL'    IN types THEN  boo := bool(v1 <= v2);
    ELSE IF 'COMPARISON_NOT_EQUAL'     IN types THEN  boo := bool(v1 <> v2);
    ELSE IF 'LIKE_EXPRESSION'          IN types THEN  boo := bool(v1 LIKE v2);
    ELSE  RETURN (?);  -- Unreachable
    END_IF;  END_IF;  END_IF;  END_IF;  END_IF;  END_IF;  END_IF;
    RETURN (convert_to_maths_value (boo));
  END_IF;
  IF 'CONCAT_EXPRESSION' IN types THEN
    str := '';
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'STRING' IN TYPEOF (vlist[i]) THEN
        str := vlist[i] + str;
        REMOVE (oplist, i);
      ELSE IF LENGTH(str) > 0 THEN
        INSERT (oplist, make_string_literal(str), i);
        str := '';
      END_IF;  END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(str));  END_IF;
    IF LENGTH(str) > 0 THEN  INSERT (oplist, make_string_literal(str), 0);  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF ('COS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (COS(v1)));
  END_IF;
  IF ('DIV_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 DIV v2));
  END_IF;
  IF 'EQUALS_EXPRESSION' IN types THEN
    opnds := expr\binary_generic_expression.operands;
    RETURN (convert_to_maths_value (opnds[1] :=: opnds[2]));
  END_IF;
  IF ('EXP_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (EXP(v1)));
  END_IF;
  IF ('FORMAT_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (FORMAT(v1,v2)));
  END_IF;
  IF ('INDEX_EXPRESSION' IN types) AND
    ('STRING' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    str := v1;  n := v2;
    RETURN (convert_to_maths_value (str[n]));
  END_IF;
  IF ('INT_VALUE_EXPRESSION' IN types) AND ('STRING' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (VALUE(v1)));
  END_IF;
  IF 'INTERVAL_EXPRESSION' IN types THEN
    str := '';
    IF 'NUMBER'  IN TYPEOF (vlist[1]) THEN str := 'NUMBER';   END_IF;
    IF 'STRING'  IN TYPEOF (vlist[1]) THEN str := 'STRING';   END_IF;
    IF 'BOOLEAN' IN TYPEOF (vlist[1]) THEN str := 'BOOLEAN';  END_IF;
    IF (LENGTH (str) > 0) AND (str IN TYPEOF (vlist[2])) AND
      (str IN TYPEOF (vlist[3])) THEN
      RETURN (convert_to_maths_value ({vlist[1] <= vlist[2] <= vlist[3]}));
    END_IF;
  END_IF;
  IF ('LENGTH_EXPRESSION' IN types) AND ('STRING' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (LENGTH(v1)));
  END_IF;
  IF ('LOG_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (LOG(v1)));
  END_IF;
  IF ('LOG10_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (LOG10(v1)));
  END_IF;
  IF ('LOG2_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (LOG2(v1)));
  END_IF;
  IF 'MAXIMUM_EXPRESSION' IN types THEN
    boo := FALSE;
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF (vlist[i]) THEN
        IF boo THEN
          IF nmb < vlist[i] THEN  nmb := vlist[i];  END_IF;
        ELSE
          nmb := vlist[i];  boo := TRUE;
        END_IF;
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(nmb));  END_IF;
    IF boo THEN  INSERT (oplist, make_number_literal(nmb), 0);  END_IF;
  END_IF;
  IF 'MINIMUM_EXPRESSION' IN types THEN
    boo := FALSE;
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF (vlist[i]) THEN
        IF boo THEN
          IF nmb > vlist[i] THEN  nmb := vlist[i];  END_IF;
        ELSE
          nmb := vlist[i];  boo := TRUE;
        END_IF;
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(nmb));  END_IF;
    IF boo THEN  INSERT (oplist, make_number_literal(nmb), 0);  END_IF;
  END_IF;
  IF ('MINUS_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 - v2));
  END_IF;
  IF ('MOD_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 MOD v2));
  END_IF;
  IF 'MULT_EXPRESSION' IN types THEN
    nmb := 1;
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF (vlist[i]) THEN
        nmb := nmb * vlist[i];
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(nmb));  END_IF;
    IF nmb <> 1 THEN  INSERT (oplist, make_number_literal(nmb), 0);  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF ('NOT_EXPRESSION' IN types) AND ('BOOLEAN' IN TYPEOF (v1)) THEN
    boo := v1;
    RETURN (convert_to_maths_value (NOT(boo)));
  END_IF;
  IF ('ODD_EXPRESSION' IN types) AND ('INTEGER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (ODD(v1)));
  END_IF;
  IF 'OR_EXPRESSION' IN types THEN
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'BOOLEAN' IN TYPEOF (vlist[i]) THEN
        boo := vlist[i];
        IF boo THEN  RETURN (convert_to_maths_value(TRUE));  END_IF;
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(FALSE));  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF 'PLUS_EXPRESSION' IN types THEN
    nmb := 0;
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF (vlist[i]) THEN
        nmb := nmb + vlist[i];
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(nmb));  END_IF;
    IF nmb <> 0 THEN  INSERT (oplist, make_number_literal(nmb), 0);  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF ('POWER_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 ** v2));
  END_IF;
  IF ('SIN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (SIN(v1)));
  END_IF;
  IF ('SLASH_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 / v2));
  END_IF;
  IF ('SQUARE_ROOT_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (SQRT(v1)));
  END_IF;
  IF ('SUBSTRING_EXPRESSION' IN types) AND
    ('STRING' IN TYPEOF (vlist[1])) AND ('NUMBER' IN TYPEOF (vlist[2])) AND
    ('NUMBER' IN TYPEOF (vlist[3])) THEN
    str := vlist[1];  n := vlist[2];  m := vlist[3];
    RETURN (convert_to_maths_value (str[n:m]));
  END_IF;
  IF ('TAN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (TAN(v1)));
  END_IF;
  IF ('UNARY_MINUS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    nmb := v1;
    RETURN (convert_to_maths_value (-nmb));
  END_IF;
  IF ('VALUE_EXPRESSION' IN types) AND ('STRING' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (VALUE(v1)));
  END_IF;
  IF ('XOR_EXPRESSION' IN types) AND
    ('BOOLEAN' IN TYPEOF (v1)) AND ('BOOLEAN' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 XOR v2));
  END_IF;
  -- No special simplification defined, return same with simplified operands.
  IF 'UNARY_GENERIC_EXPRESSION' IN types THEN
    RETURN (restore_unary(expr,op1));
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types THEN
    RETURN (restore_binary(expr,op1,op2));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN
    RETURN (restore_mulary(expr,oplist));
  END_IF;
  -- Should be unreachable, but for safety, return unsimplified expression.
  RETURN (expr);
END_FUNCTION;

FUNCTION simplify_maths_space
	(spc: maths_space) : maths_space;
  LOCAL
    stypes : SET OF STRING := stripped_typeof (spc);
    sset : SET OF maths_value;
    zset : SET OF maths_value := [];
    zval : maths_value;
    zspc : maths_space;
    zallint : BOOLEAN := TRUE;
    zint, zmin, zmax : INTEGER;
    factors : LIST OF maths_space;
    zfactors : LIST OF maths_space := [];
    rspc : maths_space;
  END_LOCAL;
  IF 'FINITE_SPACE' IN stypes THEN
    sset := spc\finite_space.members;
    REPEAT i := 1 TO SIZEOF (sset);
      zval := simplify_maths_value(sset[i]);
      zset := zset + [zval];
      IF zallint AND ('INTEGER' IN TYPEOF (zval)) THEN
        zint := zval;
        IF i = 1 THEN
          zmin := zint;
          zmax := zint;
        ELSE
          IF zint < zmin THEN
            zmin := zint;
          END_IF;
          IF zint > zmax THEN
            zmax := zint;
          END_IF;
        END_IF;
      ELSE
        zallint := FALSE;
      END_IF;
    END_REPEAT;
    IF zallint AND (SIZEOF(zset) = zmax-zmin+1) THEN
      RETURN (make_finite_integer_interval(zmin,zmax));
    END_IF;
    RETURN (make_finite_space(zset));
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN stypes THEN
    zspc := simplify_maths_space(spc\uniform_product_space.base);
    RETURN (make_uniform_product_space(zspc,spc\uniform_product_space.exponent));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN stypes THEN
    factors := spc\listed_product_space.factors;
    REPEAT i := 1 TO SIZEOF (factors);
      INSERT (zfactors, simplify_maths_space(factors[i]), i-1);
    END_REPEAT;
    RETURN (make_listed_product_space(zfactors));
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN stypes THEN
    zspc := simplify_maths_space(spc\extended_tuple_space.base);
    rspc := simplify_maths_space(spc\extended_tuple_space.extender);
    RETURN (make_extended_tuple_space(zspc,rspc));
  END_IF;
  IF 'FUNCTION_SPACE' IN stypes THEN
    zspc := simplify_maths_space(spc\function_space.domain_argument);
    rspc := simplify_maths_space(spc\function_space.range_argument);
    RETURN (make_function_space(spc\function_space.domain_constraint,zspc,
      spc\function_space.range_constraint,rspc));
  END_IF;
  RETURN (spc);
END_FUNCTION;

FUNCTION simplify_maths_value
	(val: maths_value) : maths_value;
  LOCAL
    vtypes : SET OF STRING := stripped_typeof(val);
    vlist : LIST OF maths_value;
    nlist : LIST OF maths_value := [];
  END_LOCAL;
  IF 'GENERIC_EXPRESSION' IN vtypes THEN
    RETURN (simplify_generic_expression(val));
  END_IF;
  IF 'LIST' IN vtypes THEN
    vlist := val;
    REPEAT i := 1 TO SIZEOF (vlist);
      INSERT (nlist, simplify_maths_value(vlist[i]), i-1);
    END_REPEAT;
    RETURN (convert_to_maths_value(nlist));
  END_IF;
  RETURN (val);
END_FUNCTION;

FUNCTION singleton_member_of
	(spc: maths_space) : maths_value;
  LOCAL
    types : SET OF STRING := stripped_typeof (spc);
  END_LOCAL;
  IF 'FINITE_SPACE' IN types THEN
    IF SIZEOF (spc\finite_space.members) = 1 THEN
      RETURN (spc\finite_space.members[1]);
    END_IF;
    RETURN (?);
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types THEN
    IF spc\finite_integer_interval.size = 1 THEN
      RETURN (spc\finite_integer_interval.min);
    END_IF;
    RETURN (?);
  END_IF;
  RETURN (?);
END_FUNCTION;

FUNCTION space_dimension
	(tspace: tuple_space) : nonnegative_integer;
  LOCAL
    types : SET OF STRING := TYPEOF (tspace);
  END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN types THEN
    RETURN (tspace\uniform_product_space.exponent);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN types THEN
    RETURN (SIZEOF (tspace\listed_product_space.factors));
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types THEN
    -- In the case of an extended_tuple_space, the minimum dimension is returned.
    RETURN (space_dimension (tspace\extended_tuple_space.base));
  END_IF;
  -- Should be unreachable
  RETURN (?);
END_FUNCTION;

FUNCTION space_is_continuum
	(space: maths_space) : BOOLEAN;
  LOCAL
    typenames : SET OF STRING := TYPEOF (space);
    factors : LIST OF maths_space;
  END_LOCAL;
  IF NOT EXISTS (space) THEN
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(space,es_reals) OR subspace_of_es(space,es_complex_numbers) THEN
    RETURN (TRUE);
  END_IF;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames THEN
    RETURN (space_is_continuum(space\uniform_product_space.base));
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames THEN
    factors := space\listed_product_space.factors;
    IF SIZEOF(factors) = 0 THEN
      RETURN (FALSE);
    END_IF;
    REPEAT i := 1 TO SIZEOF (factors);
      IF NOT space_is_continuum(factors[i]) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

FUNCTION space_is_singleton
	(spc: maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING := stripped_typeof (spc);
  END_LOCAL;
  IF 'FINITE_SPACE' IN types THEN
    RETURN (bool(SIZEOF (spc\finite_space.members) = 1));
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types THEN
    RETURN (bool(spc\finite_integer_interval.size = 1));
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

FUNCTION stripped_typeof
	(arg: GENERIC: G) : SET [0:?] OF STRING;
  LOCAL
    types : SET OF STRING := TYPEOF (arg);
    stypes : SET OF STRING := [];
    n : INTEGER := LENGTH (schema_prefix);
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF (types);
    IF types[i][1:n] = schema_prefix THEN
       stypes := stypes + [types[i][n+1:LENGTH(types[i])]];
    ELSE
       stypes := stypes + [types[i]];
    END_IF;
  END_REPEAT;
  RETURN (stypes);
END_FUNCTION;

FUNCTION subspace_of
	(space1: maths_space; space2: maths_space) : LOGICAL;
  LOCAL
    spc1 : maths_space := simplify_maths_space(space1);
    spc2 : maths_space := simplify_maths_space(space2);
    types1 : SET OF STRING := stripped_typeof (spc1);
    types2 : SET OF STRING := stripped_typeof (spc2);
    lgcl, cum : LOGICAL;
    es_val : elementary_space_enumerators;
    bnd1, bnd2 : REAL;
    n : INTEGER;
    sp1, sp2 : maths_space;
    prgn1, prgn2 : polar_complex_number_region;
    aitv : finite_real_interval;
  END_LOCAL;
  IF NOT EXISTS (spc1) OR NOT EXISTS (spc2) THEN
    RETURN (FALSE);
  END_IF;
  IF spc2 = the_generics THEN
    RETURN (TRUE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types1 THEN
    IF NOT ('ELEMENTARY_SPACE' IN types2) THEN
      RETURN (FALSE);
    END_IF;
    es_val := spc2\elementary_space.space_id;
    IF spc1\elementary_space.space_id = es_val THEN
      RETURN (TRUE);
    END_IF;
    -- Note that the cases (spc2=the_generics) and (spc1=spc2) have been handled.
    CASE spc1\elementary_space.space_id OF
    es_numbers :  RETURN (FALSE);
    es_complex_numbers :  RETURN (es_val = es_numbers);
    es_reals :  RETURN (es_val = es_numbers);
    es_integers :  RETURN (es_val = es_numbers);
    es_logicals :  RETURN (FALSE);
    es_booleans :  RETURN (es_val = es_logicals);
    es_strings :  RETURN (FALSE);
    es_binarys :  RETURN (FALSE);
    es_maths_spaces :  RETURN (FALSE);
    es_maths_functions :  RETURN (FALSE);
    es_generics :  RETURN (FALSE);
    END_CASE;
    -- Should be unreachable.
    RETURN (UNKNOWN);
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types1 THEN
    cum := TRUE;
    REPEAT i := spc1\finite_integer_interval.min TO spc1\finite_integer_interval.max;
      cum := cum AND member_of (i, spc2);
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'INTEGER_INTERVAL_FROM_MIN' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_integers));
    END_IF;
    IF 'INTEGER_INTERVAL_FROM_MIN' IN types2 THEN
      RETURN (spc1\integer_interval_from_min.min>=spc2\integer_interval_from_min.min);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'INTEGER_INTERVAL_TO_MAX' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_integers));
    END_IF;
    IF 'INTEGER_INTERVAL_TO_MAX' IN types2 THEN
      RETURN (spc1\integer_interval_to_max.max <= spc2\integer_interval_to_max.max);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_REAL_INTERVAL' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types2) OR
      ('REAL_INTERVAL_FROM_MIN' IN types2) OR
      ('REAL_INTERVAL_TO_MAX' IN types2) THEN
      IF min_exists (spc2) THEN
        bnd1 := spc1\finite_real_interval.min;
        bnd2 := real_min (spc2);
        IF (bnd1 < bnd2) OR ((bnd1 = bnd2) AND min_included (spc1) AND NOT
          min_included (spc2)) THEN
          RETURN (FALSE);
        END_IF;
      END_IF;
      IF max_exists (spc2) THEN
        bnd1 := spc1\finite_real_interval.max;
        bnd2 := real_max (spc2);
        IF (bnd1 > bnd2) OR ((bnd1 = bnd2) AND max_included (spc1) AND NOT
          max_included (spc2)) THEN
          RETURN (FALSE);
        END_IF;
      END_IF;
      RETURN (TRUE);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'REAL_INTERVAL_FROM_MIN' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF 'REAL_INTERVAL_FROM_MIN' IN types2 THEN
      bnd1 := spc1\real_interval_from_min.min;
      bnd2 := spc2\real_interval_from_min.min;
      RETURN ((bnd2 < bnd1) OR ((bnd2 = bnd1) AND (min_included (spc2) OR
        NOT min_included (spc1))));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'REAL_INTERVAL_TO_MAX' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF 'REAL_INTERVAL_TO_MAX' IN types2 THEN
      bnd1 := spc1\real_interval_to_max.max;
      bnd2 := spc2\real_interval_to_max.max;
      RETURN ((bnd2 > bnd1) OR ((bnd2 = bnd1) AND (max_included (spc2) OR
        NOT max_included (spc1))));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_complex_numbers));
    END_IF;
    IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types2 THEN
      RETURN (subspace_of(spc1\cartesian_complex_number_region.real_constraint,
        spc2\cartesian_complex_number_region.real_constraint) AND
        subspace_of(spc1\cartesian_complex_number_region.imag_constraint,
        spc2\cartesian_complex_number_region.imag_constraint));
    END_IF;
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN types2 THEN
      RETURN (subspace_of(enclose_cregion_in_pregion(spc1,
        spc2\polar_complex_number_region.centre),spc2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'POLAR_COMPLEX_NUMBER_REGION' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_complex_numbers));
    END_IF;
    IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types2 THEN
      RETURN (subspace_of(enclose_pregion_in_cregion(spc1),spc2));
    END_IF;
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN types2 THEN
      prgn1 := spc1;
      prgn2 := spc2;
      IF prgn1.centre = prgn2.centre THEN
        IF prgn2.direction_constraint.max > PI THEN
          aitv := make_finite_real_interval(-PI,open,prgn2.direction_constraint.max
            -2.0*PI,prgn2.direction_constraint.max_closure);
          RETURN (subspace_of(prgn1.distance_constraint,prgn2.distance_constraint)
            AND (subspace_of(prgn1.direction_constraint,prgn2.direction_constraint)
              OR subspace_of(prgn1.direction_constraint,aitv)));
        ELSE
          RETURN (subspace_of(prgn1.distance_constraint,prgn2.distance_constraint)
            AND subspace_of(prgn1.direction_constraint,prgn2.direction_constraint));
        END_IF;
      END_IF;
      RETURN (subspace_of(enclose_pregion_in_pregion(prgn1,prgn2.centre),prgn2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_SPACE' IN types1 THEN
    cum := TRUE;
    REPEAT i := 1 TO SIZEOF (spc1\finite_space.members);
      cum := cum AND member_of (spc1\finite_space.members[i], spc2);
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'PRODUCT_SPACE' IN types1 THEN
    IF 'PRODUCT_SPACE' IN types2 THEN
      IF space_dimension (spc1) = space_dimension (spc2) THEN
        cum := TRUE;
        REPEAT i := 1 TO space_dimension (spc1);
          cum := cum AND subspace_of (factor_space(spc1,i), factor_space(spc2,i));
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      IF space_dimension (spc1) >= space_dimension (spc2) THEN
        cum := TRUE;
        REPEAT i := 1 TO space_dimension (spc1);
          cum := cum AND subspace_of (factor_space(spc1,i), factor_space(spc2,i));
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types1 THEN
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      n := space_dimension (spc1);
      IF n < space_dimension (spc2) THEN
        n := space_dimension (spc2);
      END_IF;
      cum := TRUE;
      REPEAT i := 1 TO n+1;
        cum := cum AND subspace_of (factor_space(spc1,i), factor_space(spc2,i));
        IF cum = FALSE THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FUNCTION_SPACE' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      RETURN (spc2\elementary_space.space_id = es_maths_functions);
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      cum := TRUE;
      sp1 := spc1\function_space.domain_argument;
      sp2 := spc2\function_space.domain_argument;
      CASE spc1\function_space.domain_constraint OF
      sc_equal : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : cum := cum AND equal_maths_spaces (sp1, sp2);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : cum := cum AND member_of (sp1, sp2);
        END_CASE;
        END;
      sc_subspace : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : RETURN (FALSE);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : BEGIN
          IF NOT member_of (sp1, sp2) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        END_CASE;
        END;
      sc_member : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : cum := cum AND space_is_singleton(sp1) AND
          equal_maths_spaces(singleton_member_of(sp1),sp2);
        sc_subspace : BEGIN
          IF NOT member_of (sp2, sp1) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        sc_member : cum := cum AND (subspace_of (sp1, sp2));
        END_CASE;
        END;
      END_CASE;
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
      sp1 := spc1\function_space.range_argument;
      sp2 := spc2\function_space.range_argument;
      CASE spc1\function_space.range_constraint OF
      sc_equal : BEGIN
        CASE spc2\function_space.range_constraint OF
        sc_equal : cum := cum AND equal_maths_spaces (sp1, sp2);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : cum := cum AND member_of (sp1, sp2);
        END_CASE;
        END;
      sc_subspace : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : RETURN (FALSE);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : BEGIN
          IF NOT member_of (sp1, sp2) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        END_CASE;
        END;
      sc_member : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : cum := cum AND space_is_singleton(sp1) AND
          equal_maths_spaces(singleton_member_of(sp1),sp2);
        sc_subspace : BEGIN
          IF NOT member_of (sp2, sp1) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        sc_member : cum := cum AND subspace_of (sp1, sp2);
        END_CASE;
        END;
      END_CASE;
      RETURN (cum);
    END_IF;
    RETURN (FALSE);
  END_IF;
  -- Should be unreachable
  RETURN (UNKNOWN);
END_FUNCTION;

FUNCTION subspace_of_es
	(spc: maths_space; es: elementary_space_enumerators) : LOGICAL;
  LOCAL
    types : SET OF STRING := stripped_typeof(spc);
  END_LOCAL;
  IF NOT EXISTS (spc) OR NOT EXISTS (es) THEN  RETURN (FALSE);  END_IF;
  IF 'ELEMENTARY_SPACE' IN types THEN
    RETURN (es_subspace_of_es(spc\elementary_space.space_id,es));
  END_IF;
  IF 'FINITE_SPACE' IN types THEN
    RETURN (all_members_of_es(spc\finite_space.members,es));
  END_IF;
  CASE es OF
  es_numbers : RETURN (
    ('FINITE_INTEGER_INTERVAL' IN types) OR
    ('INTEGER_INTERVAL_FROM_MIN' IN types) OR
    ('INTEGER_INTERVAL_TO_MAX' IN types) OR
    ('FINITE_REAL_INTERVAL' IN types) OR
    ('REAL_INTERVAL_FROM_MIN' IN types) OR
    ('REAL_INTERVAL_TO_MAX' IN types) OR
    ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types) OR
    ('POLAR_COMPLEX_NUMBER_REGION' IN types) );
  es_complex_numbers : RETURN (
    ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types) OR
    ('POLAR_COMPLEX_NUMBER_REGION' IN types) );
  es_reals : RETURN (
    ('FINITE_REAL_INTERVAL' IN types) OR
    ('REAL_INTERVAL_FROM_MIN' IN types) OR
    ('REAL_INTERVAL_TO_MAX' IN types) );
  es_integers : RETURN (
    ('FINITE_INTEGER_INTERVAL' IN types) OR
    ('INTEGER_INTERVAL_FROM_MIN' IN types) OR
    ('INTEGER_INTERVAL_TO_MAX' IN types) );
  es_logicals : RETURN (FALSE);
  es_booleans : RETURN (FALSE);
  es_strings : RETURN (FALSE);
  es_binarys : RETURN (FALSE);
  es_maths_spaces : RETURN (FALSE);
  es_maths_functions : RETURN ('FUNCTION_SPACE' IN types);
  es_generics : RETURN (TRUE);
  END_CASE;
  RETURN (UNKNOWN);
END_FUNCTION;

FUNCTION substitute
	(expr: generic_expression; vars: LIST [1:?] OF generic_variable; vals: LIST [1:?] OF maths_value) : generic_expression;
  LOCAL
    types : SET OF STRING := stripped_typeof(expr);
    opnds : LIST OF generic_expression;
    op1, op2 : generic_expression;
    qvars : LIST OF generic_variable;
    srcdom : maths_space_or_function;
    prpfun : LIST [1:?] OF maths_function;
    finfun : maths_function_select;
  END_LOCAL;
  IF SIZEOF (vars) <> SIZEOF (vals) THEN  RETURN (?);  END_IF;
  IF 'GENERIC_LITERAL' IN types THEN  RETURN (expr);  END_IF;
  IF 'GENERIC_VARIABLE' IN types THEN
    REPEAT i := 1 TO SIZEOF (vars);
      IF expr :=: vars[i] THEN  RETURN (vals[i]);  END_IF;
    END_REPEAT;
    RETURN (expr);
  END_IF;
  IF 'QUANTIFIER_EXPRESSION' IN types THEN
    qvars := expr\quantifier_expression.variables;
    -- Variables subject to a quantifier do not participate in this kind of
    -- substitution process.
    REPEAT i := SIZEOF (vars) TO 1 BY -1;
      IF vars[i] IN qvars THEN
        REMOVE (vars, i);
        REMOVE (vals, i);
      END_IF;
    END_REPEAT;
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF (opnds);
      IF NOT (opnds[i] IN qvars) THEN
        expr\multiple_arity_generic_expression.operands[i] :=
          substitute(opnds[i],vars,vals);
        -- This technique will not work on subtypes of quantifier_expression
        -- which derive their operands from other attributes!
      END_IF;
    END_REPEAT;
    RETURN (expr);  -- operands modified!
  END_IF;
  IF 'UNARY_GENERIC_EXPRESSION' IN types THEN
    op1 := expr\unary_generic_expression.operand;
    expr\unary_generic_expression.operand := substitute(op1, vars, vals);
    -- This technique will not work on subtypes of unary_generic_expression
    -- which derive their operands from other attributes!
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types THEN
    op1 := expr\binary_generic_expression.operands[1];
    expr\binary_generic_expression.operands[1] := substitute(op1, vars, vals);
    op2 := expr\binary_generic_expression.operands[2];
    expr\binary_generic_expression.operands[2] := substitute(op2, vars, vals);
    -- This technique will not work on subtypes of binary_generic_expression
    -- which derive their operands from other attributes!
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN types THEN
    -- Subtype of multiple_arity_generic_expression which derives its operands.
    srcdom := expr\parallel_composed_function.source_of_domain;
    prpfun := expr\parallel_composed_function.prep_functions;
    finfun := expr\parallel_composed_function.final_function;
    srcdom := substitute(srcdom,vars,vals);
    REPEAT i := 1 TO SIZEOF (prpfun);
      prpfun[i] := substitute(prpfun[i],vars,vals);
    END_REPEAT;
    IF 'MATHS_FUNCTION' IN stripped_typeof(finfun) THEN
      finfun := substitute(finfun,vars,vals);
    END_IF;
    RETURN (make_parallel_composed_function(srcdom,prpfun,finfun));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF (opnds);
      expr\multiple_arity_generic_expression.operands[i] :=
        substitute(opnds[i],vars,vals);
        -- This technique will not work on subtypes of multiple_arity_generic_
        -- expression which derive their operands from other attributes!
    END_REPEAT;
  END_IF;
  RETURN (expr);
END_FUNCTION;

FUNCTION surface_condition_correlation
	(pd: property_definition; rep: representation) : LOGICAL;
CASE pd.name OF
      'visual appearance', 'tactile appearance', 'contact ratio', 'hardness', 'treatment result', 'surface texture' : 
	  RETURN(pd.name = rep.name);
      OTHERWISE : RETURN(UNKNOWN);
    END_CASE;
END_FUNCTION;

FUNCTION surface_weights_positive
	(b: rational_b_spline_surface) : BOOLEAN;
   LOCAL
     result        : BOOLEAN := TRUE;
   END_LOCAL;
   
   REPEAT i := 0 TO b.u_upper;
     REPEAT j := 0 TO b.v_upper;
       IF (b.weights[i][j] <= 0.0)  THEN
         result := FALSE;
         RETURN(result);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(result);
END_FUNCTION;

FUNCTION temporal_spatial_domain_for_model
	(domain: numerical_model) : BOOLEAN;
    LOCAL
      spatial_set : SET OF spatial_decomposition_of_numerical_model;
      behavioural_set : SET OF behavioural_decomposition_of_numerical_model;
      domains : SET OF numerical_model := [];
      viewing : BAG OF view_relationship;
      spatial_bag : BAG OF spatial_decomposition_of_numerical_model;
      behavioural_bag : BAG OF behavioural_decomposition_of_numerical_model;
    END_LOCAL;

    viewing := USEDIN(domain, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VIEW_RELATIONSHIP.VIEW');
    IF SIZEOF(viewing) > 0 THEN
      RETURN (TRUE);
    END_IF;
    spatial_bag := USEDIN(domain, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SPATIAL_DECOMPOSITION_OF_NUMERICAL_MODEL.PARTS');
    IF SIZEOF(spatial_bag) > 0 THEN
      spatial_set := bag_to_set(spatial_bag);
      REPEAT i := 1 TO HIINDEX(spatial_set);
        domains := domains + spatial_set[i].whole;
      END_REPEAT;
    END_IF;
    behavioural_bag := USEDIN(domain, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BEHAVIOURAL_DECOMPOSITION_OF_NUMERICAL_MODEL.PARTS');
    IF SIZEOF(behavioural_bag) > 0 THEN
      behavioural_set := bag_to_set(behavioural_bag);
      REPEAT i := 1 TO HIINDEX(behavioural_set);
        domains := domains + behavioural_set[i].whole;
      END_REPEAT;
    END_IF;
    IF SIZEOF(domains) > 0 THEN
      REPEAT i := 1 TO HIINDEX(domains);
        IF temporal_spatial_domain_for_model(domains[i]) THEN
          RETURN (TRUE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN (FALSE);
END_FUNCTION;

FUNCTION this_schema : STRING;
RETURN('MESH_TOPOLOGY_SCHEMA');
END_FUNCTION;

FUNCTION topology_reversed
	(an_item: reversible_topology) : reversible_topology;
IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE' IN TYPEOF (an_item)) THEN
     RETURN (edge_reversed (an_item));
   END_IF;

   IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PATH' IN TYPEOF (an_item)) THEN
     RETURN (path_reversed (an_item));
   END_IF;

   IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BOUND' IN TYPEOF (an_item)) THEN
     RETURN (face_bound_reversed (an_item));
   END_IF;
  
   IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE' IN TYPEOF (an_item)) THEN
     RETURN (face_reversed (an_item));
   END_IF;

   IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL' IN TYPEOF (an_item)) THEN
     RETURN (shell_reversed (an_item));
   END_IF;

   IF ('SET' IN TYPEOF (an_item)) THEN
     RETURN (set_of_topology_reversed (an_item));
   END_IF;

   IF ('LIST' IN TYPEOF (an_item)) THEN
     RETURN (list_of_topology_reversed (an_item));
   END_IF;

   RETURN (?);
END_FUNCTION;

FUNCTION type_check_function
	(the_type: GENERIC; sub_names: SET [0:?] OF STRING; criterion: INTEGER) : LOGICAL;
IF ((NOT EXISTS(the_type)) OR (NOT ({0 <= criterion <= 3})) OR (SIZEOF(sub_names) = 0)) THEN
      RETURN (UNKNOWN);
    ELSE
      CASE criterion OF 
        0:
          RETURN (SIZEOF(sub_names * TYPEOF(the_type)) > 0);
        1:
          RETURN (SIZEOF(sub_names * TYPEOF(the_type)) = 0);
        2:
          RETURN (SIZEOF(sub_names * TYPEOF(the_type)) = 1);
        3:
          RETURN (SIZEOF(sub_names * TYPEOF(the_type)) <= 1);
      END_CASE;
    END_IF;
END_FUNCTION;

FUNCTION using_items
	(item: founded_item_select; checked_items: SET [0:?] OF founded_item_select) : SET [0:?] OF founded_item_select;
    LOCAL
      new_check_items    : SET OF founded_item_select;
      result_items       : SET OF founded_item_select;
      next_items         : SET OF founded_item_select;
    END_LOCAL;
    result_items := [];
    new_check_items := checked_items + item;
    -- Find the set of representation_items or founded_items
    -- in which item is used directly.
    next_items := QUERY(z <* bag_to_set( USEDIN(item , '')) |
      ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z)) OR
      ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FOUNDED_ITEM'        IN TYPEOF(z)));
    -- If the set of next_items is not empty;
    IF SIZEOF(next_items) > 0 THEN
      -- For each element in the set, find the using_items recursively
      REPEAT i := 1 TO HIINDEX(next_items);
        -- Check for loop in data model, i.e. one of the next_items
        -- occurred earlier in the set of check_items;
        IF NOT(next_items[i] IN new_check_items) THEN
          result_items := result_items + next_items[i] +
                          using_items(next_items[i],new_check_items);
        END_IF;
      END_REPEAT;
    END_IF;
    -- return the set of representation_items or founded_items
    -- in which the input item is used directly and indirectly.
    RETURN (result_items);
END_FUNCTION;

FUNCTION using_representations
	(item: founded_item_select) : SET [0:?] OF representation;
    LOCAL
      results            : SET OF representation;
      result_bag         : BAG OF representation;
      intermediate_items : SET OF founded_item_select;
    END_LOCAL;
    -- Find the representations in which the item is used and add to the
    -- results set.
    results := [];
    result_bag := USEDIN(item,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REPRESENTATION.ITEMS');
    IF SIZEOF(result_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(result_bag);
        results := results + result_bag[i];
      END_REPEAT;
    END_IF;
    -- Find all representation_items or founded_items
    -- by which item is referenced directly or indirectly.
    intermediate_items := using_items(item,[]);
    -- If the set of intermediate items is not empty;
    IF SIZEOF(intermediate_items) > 0 THEN
      -- For each element in the set, add the
      -- representations of that element.
      REPEAT i := 1 TO HIINDEX(intermediate_items);
        result_bag := USEDIN(intermediate_items[i],
                      'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REPRESENTATION.ITEMS');
        IF SIZEOF(result_bag) > 0 THEN
          REPEAT j := 1 TO HIINDEX(result_bag);
            results := results + result_bag[j];
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
    -- Return the set of representation in which the input item is
    -- used directly and indirectly (through intervening
    -- representation_items or founded items).
    RETURN (results);
END_FUNCTION;

FUNCTION valid_basis_curve_in_2d_wireframe
	(crv: curve) : BOOLEAN;
IF SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE',
               'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE',
               'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELLIPSE',
               'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CIRCLE'] * 
               TYPEOF (crv)) = 1
    THEN RETURN (TRUE);
  ELSE
    -- if the curve is a trimmed_curve
    IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TRIMMED_CURVE') 
    IN TYPEOF (crv)) THEN
      -- if a line, parabola, or hyperbola is being trimmed, then valid
      IF SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE',
                   'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARABOLA',
                   'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.HYPERBOLA'] *
           TYPEOF(crv\trimmed_curve.basis_curve)) = 1
        THEN RETURN (TRUE);
      -- otherwise, recursively check basis_curve
      ELSE RETURN (valid_basis_curve_in_2d_wireframe
                         (crv\trimmed_curve.basis_curve));
      END_IF;
    ELSE
      -- recursively check the offset_curve basis curve
      IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_CURVE_2D') 
      IN TYPEOF (crv))
        THEN RETURN (valid_basis_curve_in_2d_wireframe
                           (crv\offset_curve_2d.basis_curve));
      ELSE
        -- recursively check the curve_replica parent curve
        IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_REPLICA') 
        IN TYPEOF (crv))
          THEN RETURN (valid_basis_curve_in_2d_wireframe
                         (crv\curve_replica.parent_curve));
        ELSE
          -- recursively check the composite_curve segments
          IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_CURVE') 
          IN TYPEOF (crv)) THEN
            RETURN (SIZEOF (QUERY (ccs <* crv\composite_curve.segments |
                      NOT (valid_basis_curve_in_2d_wireframe
                             (ccs.parent_curve)))) = 0);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

FUNCTION valid_calendar_date
	(date: calendar_date) : LOGICAL;
CASE date.month_component OF
    1  : RETURN({ 1 <= date.day_component <= 31 });
    2  : BEGIN
           IF (leap_year(date.year_component)) THEN
             RETURN({ 1 <= date.day_component <= 29 });
           ELSE
             RETURN({ 1 <= date.day_component <= 28 });
           END_IF;
         END;
    3  : RETURN({ 1 <= date.day_component <= 31 });
    4  : RETURN({ 1 <= date.day_component <= 30 });
    5  : RETURN({ 1 <= date.day_component <= 31 });
    6  : RETURN({ 1 <= date.day_component <= 30 });
    7  : RETURN({ 1 <= date.day_component <= 31 });
    8  : RETURN({ 1 <= date.day_component <= 31 });
    9  : RETURN({ 1 <= date.day_component <= 30 });
    10 : RETURN({ 1 <= date.day_component <= 31 });
    11 : RETURN({ 1 <= date.day_component <= 30 });
    12 : RETURN({ 1 <= date.day_component <= 31 });
  END_CASE;
  RETURN (FALSE);
END_FUNCTION;

FUNCTION valid_datum_target_parameters
	(pdf: placed_datum_target_feature) : BOOLEAN;
  LOCAL
    rep_set : SET OF representation := [] ;
    parameter_representations: SET OF representation;
  END_LOCAL;

  REPEAT i := 1 TO HIINDEX(pdf.representation_associations);
    rep_set := rep_set + pdf.representation_associations[i].used_representation;
  END_REPEAT;
  parameter_representations := QUERY(rep <* rep_set | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN TYPEOF(rep)));

  IF (SIZEOF( QUERY( srwp <* parameter_representations |
          (SIZEOF( QUERY( i <* srwp.items |
          (i.name='orientation') AND
          ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLACEMENT' IN TYPEOF(i)))) = 1))) <> 1) THEN
    RETURN(FALSE);
  END_IF;
  CASE pdf\shape_aspect.description OF
    'point': RETURN(SIZEOF(QUERY( srwp <* parameter_representations |
              (SIZEOF(srwp.items) = 1))) = 1);
    'circle', 'circular curve': RETURN((SIZEOF( QUERY( srwp <* parameter_representations |
              (SIZEOF(srwp.items) = 2))) = 1) AND
             (SIZEOF( QUERY( srwp <* parameter_representations |
              (SIZEOF( QUERY( i <* srwp.items |
                (i.name='target diameter') AND
                (SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM',
		   'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2) )) = 1))) = 1));
    'line': RETURN(SIZEOF( QUERY( srwp <* parameter_representations |
              (SIZEOF( QUERY( i <* srwp.items |
                (i.name='target length') AND
                (SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM',
		'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2) )) = 1))) = 1);
    'rectangle': RETURN((SIZEOF( QUERY( srwp <* parameter_representations |
              (SIZEOF(srwp.items)= 3))) = 1) AND
             (SIZEOF( QUERY( srwp <* parameter_representations |
              (SIZEOF( QUERY( i <* srwp.items |
                (i.name='target length') AND
                (SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM',
		'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2))) = 1))) = 1) AND
              (SIZEOF( QUERY( srwp <* parameter_representations |
               (SIZEOF( QUERY( i <* srwp.items |
                 (i.name='target width') AND
                 (SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM',
 		'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                  ) = 2))) = 1) )) = 1));
    OTHERWISE : RETURN(FALSE);
  END_CASE;
END_FUNCTION;

FUNCTION valid_geometrically_bounded_wf_curve
	(crv: curve) : BOOLEAN;
IF SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELLIPSE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CIRCLE' ] * TYPEOF (crv)) = 1 THEN 
 RETURN (TRUE);
 ELSE 
 IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TRIMMED_CURVE' IN TYPEOF (crv) THEN 
 IF SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARABOLA', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.HYPERBOLA' ] * TYPEOF (crv\trimmed_curve.basis_curve)) = 1 THEN 
 RETURN (TRUE);
 ELSE 
 RETURN (valid_geometrically_bounded_wf_curve(crv\trimmed_curve.basis_curve));
 END_IF ;
 ELSE 
 IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_CURVE_3D' IN TYPEOF (crv) THEN 
 RETURN (valid_geometrically_bounded_wf_curve(crv\offset_curve_3d.basis_curve));
 ELSE 
 IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_REPLICA' IN TYPEOF (crv) THEN 
 RETURN (valid_geometrically_bounded_wf_curve(crv\curve_replica.parent_curve));
 ELSE 
 IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_CURVE' IN TYPEOF (crv) THEN 
 RETURN ( SIZEOF ( 
QUERY ( ccs <* crv\composite_curve.segments| NOT valid_geometrically_bounded_wf_curve(ccs.parent_curve) )) = 0);
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 RETURN (FALSE);
END_FUNCTION;

FUNCTION valid_geometrically_bounded_wf_point
	(pnt: point) : BOOLEAN;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT' IN TYPEOF (pnt) THEN 
 RETURN (TRUE);
 ELSE 
 IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_CURVE' IN TYPEOF (pnt) THEN 
 RETURN (valid_geometrically_bounded_wf_curve(pnt\point_on_curve.basis_curve));
 ELSE 
 IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_REPLICA' IN TYPEOF (pnt) THEN 
 RETURN (valid_geometrically_bounded_wf_point(pnt\point_replica.parent_pt));
 END_IF ;
 END_IF ;
 END_IF ;
 RETURN (FALSE);
END_FUNCTION;

FUNCTION valid_measure_value
	(m: measure_value) : BOOLEAN;
IF ('REAL' IN TYPEOF (m)) THEN
    RETURN (m > 0.0);
    ELSE
     IF ('INTEGER' IN TYPEOF (m)) THEN
      RETURN (m > 0);
      ELSE
        RETURN (TRUE);
      END_IF;
    END_IF;
END_FUNCTION;

FUNCTION valid_parametric_coordinate
	(coordinates: LIST [1:3] OF parameter_value) : BOOLEAN;
    LOCAL
      i                     : INTEGER;
    END_LOCAL; 

    REPEAT i:=1 TO HIINDEX(coordinates);
      IF ((1.0 < coordinates[i]) OR (coordinates[i] < -1.0)) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;

    RETURN (TRUE);
END_FUNCTION;

FUNCTION valid_selected_instance_representation
	(pd: product_definition_or_assembly_relationship) : LOGICAL;
    LOCAL
      properties: SET OF property_definition := bag_to_set(QUERY( prd<* USEDIN ( pd ,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROPERTY_DEFINITION.DEFINITION' ) | 
        (prd.name = 'occurrence selection' )));
      property_definition_representations: SET OF property_definition_representation := bag_to_set(QUERY ( pdr <* USEDIN ( properties[1] , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
	    ( pdr.used_representation.name = 'selection criteria' )));
      selected_representation: representation;
    END_LOCAL;
    IF (SIZEOF( properties)<>1) THEN
	  RETURN(FALSE);
    END_IF;
    IF (SIZEOF(property_definition_representations)<>1) THEN
	  RETURN(FALSE);
    END_IF;
    selected_representation := property_definition_representations[1]\property_definition_representation.used_representation;
    IF (SIZEOF(selected_representation\representation.items) <1) OR (SIZEOF(selected_representation\representation.items) >2) THEN
	  RETURN(FALSE);
    END_IF;
    IF (SIZEOF ( QUERY ( i <* selected_representation\representation.items |
	  ( SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM' ,
      'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VALUE_RANGE']* TYPEOF ( i ) ) = 1) AND
      ( i.name = 'selection quantity' ))) <> 1 ) THEN
      RETURN(FALSE);
    END_IF;
    IF (SIZEOF ( QUERY ( i <* selected_representation\representation.items |
	  ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND
 	  ( i.name = 'selection control' )))> 1) THEN
	  RETURN(FALSE);
    END_IF; --the selection control is not specified then the quantity shall be a qualified_representation_item or a value_range
    IF (SIZEOF ( QUERY ( i <* selected_representation\representation.items |
      ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF( i ) ) AND
      ( i.name = 'selection control' ) ))= 0) AND 
      (SIZEOF ( QUERY ( i <* selected_representation\representation.items |
      ( i.name = 'selection quantity' ) AND  
      ( SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.QUALIFIED_REPRESENTATION_ITEM' ,
      'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VALUE_RANGE']* TYPEOF ( i ) ) =0 ))) > 0 ) THEN
	  RETURN(FALSE);
    END_IF;
    RETURN(TRUE);
END_FUNCTION;

FUNCTION valid_time
	(time: local_time) : BOOLEAN;
IF EXISTS(time.second_component) THEN
    RETURN (EXISTS(time.minute_component));
  ELSE
    RETURN (TRUE);
  END_IF;
END_FUNCTION;

FUNCTION valid_units
	(m: measure_with_unit) : BOOLEAN;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MASS_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TIME_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.THERMODYNAMIC_TEMPERATURE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CELSIUS_TEMPERATURE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLANE_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AREA_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VOLUME_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.RATIO_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ACCELERATION_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 1.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
     IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CAPACITANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( -2.0, -1.0, 4.0, 1.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELECTRIC_CHARGE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
        IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONDUCTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
          IF derive_dimensional_exponents(m.unit_component) <> 
            dimensional_exponents( -2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0 ) THEN
            RETURN (FALSE);
          END_IF;
    END_IF;
        IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELECTRIC_POTENTIAL_MEASURE' IN TYPEOF(m.value_component) THEN
          IF derive_dimensional_exponents(m.unit_component) <> 
            dimensional_exponents( 2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0 ) THEN
            RETURN (FALSE);
          END_IF;
    END_IF;    
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ENERGY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FORCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FREQUENCY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ILLUMINANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( -2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
     IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.INDUCTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LUMINOUS_FLUX_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAGNETIC_FLUX_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
     IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAGNETIC_FLUX_DENSITY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POWER_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRESSURE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( -1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.RESISTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VELOCITY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 1.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.RADIOACTIVITY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ABSORBED_DOSE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DOSE_EQUIVALENT_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    RETURN (TRUE);
END_FUNCTION;

FUNCTION valid_wireframe_edge_curve
	(crv: curve) : BOOLEAN;
IF SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONIC', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' ] * TYPEOF (crv)) = 1 THEN 
 RETURN (TRUE);
 ELSE 
 IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_REPLICA' IN TYPEOF (crv) THEN 
 RETURN (valid_wireframe_edge_curve(crv\curve_replica.parent_curve));
 ELSE 
 IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_CURVE_3D' IN TYPEOF (crv) THEN 
 RETURN (valid_wireframe_edge_curve(crv\offset_curve_3d.basis_curve));
 END_IF ;
 END_IF ;
 END_IF ;
 RETURN (FALSE);
END_FUNCTION;

FUNCTION valid_wireframe_vertex_point
	(pnt: point) : BOOLEAN;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT' IN TYPEOF (pnt) THEN 
 RETURN (TRUE);
 ELSE 
 IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_REPLICA' IN TYPEOF (pnt) THEN 
 RETURN (valid_wireframe_vertex_point(pnt\point_replica.parent_pt));
 END_IF ;
 END_IF ;
 RETURN (FALSE);
END_FUNCTION;

FUNCTION validate_countersink_radii
	(cskhole: solid_with_stepped_round_hole_and_conical_transitions) : BOOLEAN;
  LOCAL
    i,j             : INTEGER;
    n               : INTEGER := 1 +
                        cskhole\solid_with_stepped_round_hole.segments;
    smaller, larger : positive_length_measure;
  END_LOCAL;

  REPEAT i := 1 TO SIZEOF(cskhole.conical_transitions);

  -- First check whether transition i applies to the entry of the hole or 
  -- the exit of a through hole - those cases only need to be checked for 
  -- the sign of the cone apex angle.

  IF (((cskhole.conical_transitions[i].transition_number = 1)
       AND (cskhole.conical_transitions[i].cone_apex_angle < 0))
    XOR ((cskhole.conical_transitions[i].transition_number = n)
         AND (cskhole.conical_transitions[i].cone_apex_angle > 0))) 
  THEN RETURN(FALSE); 
  ELSE
    IF ((cskhole.conical_transitions[i].transition_number <> 1)
      AND (cskhole.conical_transitions[i].transition_number <> n))
    THEN

  -- For all remaining transitions, check that the cone base radius 
  -- lies in the range of validity.


      BEGIN
        j := cskhole.conical_transitions[i].transition_number;
        IF cskhole\solid_with_stepped_round_hole.segment_radii[j] 
          > cskhole\solid_with_stepped_round_hole.segment_radii[j-1]
        THEN 
          BEGIN
            IF (cskhole.conical_transitions[i].cone_apex_angle > 0)
            THEN RETURN(FALSE);
            END_IF;
            larger 
              := cskhole\solid_with_stepped_round_hole.segment_radii[j];
            smaller 
              := cskhole\solid_with_stepped_round_hole.segment_radii[j-1];
          END;
        ELSE
          BEGIN
            IF (cskhole.conical_transitions[i].cone_apex_angle < 0)
            THEN RETURN(FALSE);
            END_IF;
            larger  
              := cskhole\solid_with_stepped_round_hole.segment_radii[j-1];
            smaller 
              := cskhole\solid_with_stepped_round_hole.segment_radii[j];
          END;
        END_IF; 
        IF ((cskhole.conical_transitions[i].cone_base_radius > larger)
          OR (cskhole.conical_transitions[i].cone_base_radius < smaller))
        THEN RETURN(FALSE);
        END_IF;
      END;
    END_IF;
  END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;

FUNCTION value_range_aggregate_rep_item
	(agg: AGGREGATE OF representation_item) : BOOLEAN;
BEGIN 
  IF (SIZEOF(QUERY(i1 <* agg | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i1)) )) = 6) THEN 
	  RETURN (TRUE); 
   ELSE 
	RETURN (FALSE); 
   END_IF; 
   END;
END_FUNCTION;

FUNCTION value_range_wr1
	(agg: compound_item_definition) : BOOLEAN;
BEGIN
      IF (SIZEOF(agg) = 2) AND ((SIZEOF(QUERY (i1 <* agg | (
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF
        (i1)))) = 2) OR
        (SIZEOF(QUERY (i2 <* agg | (
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VALUE_REPRESENTATION_ITEM' IN TYPEOF
        (i2)))) = 2)) 
      THEN
        RETURN(TRUE);
      ELSE
        RETURN(FALSE);
      END_IF;
    END;
END_FUNCTION;

FUNCTION value_range_wr2
	(agg: compound_item_definition) : BOOLEAN;
BEGIN
      IF ((SIZEOF(QUERY (i <* agg | (i\representation_item.name = 'upper limit'))) = 1)
        AND (SIZEOF(QUERY (i <* agg | (i\representation_item.name = 'lower limit'))) = 1))
      THEN
        RETURN(TRUE);
      ELSE
        RETURN(FALSE);
      END_IF;
    END;
END_FUNCTION;

FUNCTION value_range_wr3
	(agg: compound_item_definition) : BOOLEAN;
BEGIN
      IF (SIZEOF(QUERY(i1 <* agg |
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (i1)) AND
        (SIZEOF (QUERY (i2 <* agg |
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (i2)) AND
        (i1 :<>: i2) AND (i1\measure_with_unit.unit_component :=: i2\measure_with_unit.unit_component))) = 1))) = 2)
      THEN
        RETURN (TRUE);
      ELSE
        RETURN (FALSE);
      END_IF;
    END;
END_FUNCTION;

FUNCTION values_space_of
	(expr: generic_expression) : maths_space;
  LOCAL
    e_prefix : STRING := 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.';
    typenames : SET OF STRING := TYPEOF (expr);
  END_LOCAL;
  IF (schema_prefix + 'MATHS_VARIABLE') IN typenames THEN
    RETURN (expr\maths_variable.values_space);
  END_IF;
  IF (e_prefix + 'EXPRESSION') IN typenames THEN
    IF (e_prefix + 'NUMERIC_EXPRESSION') IN typenames THEN
      IF expr\numeric_expression.is_int THEN
        IF (e_prefix + 'INT_LITERAL') IN typenames THEN
          RETURN (make_finite_space ([expr\int_literal.the_value]));
        ELSE
          RETURN (the_integers);
        END_IF;
      ELSE
        IF (e_prefix + 'REAL_LITERAL') IN typenames THEN
          RETURN (make_finite_space ([expr\real_literal.the_value]));
        ELSE
          RETURN (the_reals);
        END_IF;
      END_IF;
    END_IF;
    IF (e_prefix + 'BOOLEAN_EXPRESSION') IN typenames THEN
      IF (e_prefix + 'BOOLEAN_LITERAL') IN typenames THEN
        RETURN (make_finite_space ([expr\boolean_literal.the_value]));
      ELSE
        RETURN (the_booleans);
      END_IF;
    END_IF;
    IF (e_prefix + 'STRING_EXPRESSION') IN typenames THEN
      IF (e_prefix + 'STRING_LITERAL') IN typenames THEN
        RETURN (make_finite_space ([expr\string_literal.the_value]));
      ELSE
        RETURN (the_strings);
      END_IF;
    END_IF;
    RETURN (?);  -- unknown subtype of expression
  END_IF;
  IF (schema_prefix + 'MATHS_FUNCTION') IN typenames THEN
    IF expression_is_constant (expr) THEN
      RETURN (make_finite_space ([expr]));
    ELSE
      RETURN (make_function_space (sc_equal, expr\maths_function.domain,
        sc_equal, expr\maths_function.range));
    END_IF;
  END_IF;
  IF (schema_prefix + 'FUNCTION_APPLICATION') IN typenames THEN
    RETURN (expr\function_application.func.range);
  END_IF;
  IF (schema_prefix + 'MATHS_SPACE') IN typenames THEN
    IF expression_is_constant (expr) THEN
      RETURN (make_finite_space ([expr]));
    ELSE
      -- This case cannot occur in this version of the schema.
      -- When it becomes possible, the subtypes should be analysed and
      -- more finely defined spaces returned.
      RETURN (make_elementary_space (es_maths_spaces));
    END_IF;
  END_IF;
  IF (schema_prefix + 'DEPENDENT_VARIABLE_DEFINITION') IN typenames THEN
    RETURN (values_space_of (expr\unary_generic_expression.operand));
  END_IF;
  IF (schema_prefix + 'COMPLEX_NUMBER_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr]));
  END_IF;
  IF (schema_prefix + 'LOGICAL_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\logical_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'BINARY_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\binary_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'MATHS_ENUM_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\maths_enum_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'REAL_TUPLE_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\real_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'INTEGER_TUPLE_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\integer_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'ATOM_BASED_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\atom_based_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'MATHS_TUPLE_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\maths_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'PARTIAL_DERIVATIVE_EXPRESSION') IN typenames THEN
    RETURN (drop_numeric_constraints (values_space_of (
      expr\partial_derivative_expression.derivand)));
  END_IF;
  IF (schema_prefix + 'DEFINITE_INTEGRAL_EXPRESSION') IN typenames THEN
    RETURN (drop_numeric_constraints (values_space_of (
      expr\definite_integral_expression.integrand)));
  END_IF;
  RETURN (?);
END_FUNCTION;

FUNCTION variable_value_type
	(variable: GENERIC) : STRING;
    LOCAL
     svt                    : STRING;
     feacr                  : STRING;
     variable_typeof        : SET [1:?] OF STRING;
    END_LOCAL;
        
    svt     := 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.';
    feacr   := 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.';
    variable_typeof := TYPEOF (variable);

    IF SIZEOF ([(feacr + 'CURVE_SCALAR_VARIABLE'),
                (feacr + 'SURFACE_SCALAR_VARIABLE'),
                (feacr + 'VOLUME_SCALAR_VARIABLE'),
                (feacr + 'BOUNDARY_CURVE_SCALAR_VARIABLE'),
                (feacr + 'BOUNDARY_SURFACE_SCALAR_VARIABLE'),
                (feacr + 'AGGREGATED_SCALAR_VARIABLE'),
                (feacr + 'VOLUME_ANGULAR_VARIABLE'),
                (feacr + 'AGGREGATED_ANGULAR_VARIABLE'),
                (feacr + 'APPLICATION_DEFINED_SCALAR_VARIABLE')] *
               variable_typeof ) = 1 THEN
        RETURN (svt + 'SCALAR');
    END_IF;

    IF SIZEOF ([(feacr + 'CURVE_VECTOR_2D_VARIABLE'),
                (feacr + 'SURFACE_VECTOR_2D_VARIABLE'),
                (feacr + 'APPLICATION_DEFINED_VECTOR_2D_VARIABLE')] *
               variable_typeof ) = 1 THEN
        RETURN (svt + 'TENSOR1_2D');
    END_IF;

    IF SIZEOF ([(feacr + 'CURVE_VECTOR_3D_VARIABLE'),
                (feacr + 'SURFACE_VECTOR_3D_VARIABLE'),
                (feacr + 'VOLUME_VECTOR_3D_VARIABLE'),
                (feacr + 'BOUNDARY_CURVE_VECTOR_3D_VARIABLE'),
                (feacr + 'BOUNDARY_SURFACE_VECTOR_3D_VARIABLE'),
                (feacr + 'AGGREGATED_VECTOR_3D_VARIABLE'),
                (feacr + 'APPLICATION_DEFINED_VECTOR_3D_VARIABLE')] *
               variable_typeof ) = 1 THEN
        RETURN (svt + 'TENSOR1_3D');
    END_IF;

    IF SIZEOF ([(feacr + 'SURFACE_TENSOR2_2D_VARIABLE'),
                (feacr + 'APPLICATION_DEFINED_TENSOR2_2D_VARIABLE')] *
               variable_typeof ) = 1 THEN
        RETURN (svt + 'SYMMETRIC_TENSOR2_3D');
    END_IF;

    IF SIZEOF ([(feacr + 'VOLUME_TENSOR2_3D_VARIABLE'),
                (feacr + 'AGGREGATED_TENSOR2_3D_VARIABLE'),
                (feacr + 'APPLICATION_DEFINED_TENSOR2_3D_VARIABLE')] *
               variable_typeof ) = 1 THEN
        RETURN (svt + 'SYMMETRIC_TENSOR2_3D');
    END_IF;

    RETURN ('NO_MATCH');
END_FUNCTION;

FUNCTION vector_difference
	(arg1: vector_or_direction; arg2: vector_or_direction) : vector;
    LOCAL
      result          : vector;
      res, vec1, vec2 : direction;
      mag, mag1, mag2 : REAL;
      ndim            : INTEGER;
    END_LOCAL;
 
    IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim <> arg2.dim)
        THEN
      RETURN (?) ;
     ELSE
      BEGIN
        IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VECTOR' IN TYPEOF(arg1) THEN
          mag1 := arg1.magnitude;
          vec1 := arg1\vector.orientation;
        ELSE
          mag1 := 1.0;
          vec1 := arg1;
        END_IF;
        IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VECTOR' IN TYPEOF(arg2) THEN
          mag2 := arg2.magnitude;
          vec2 := arg2\vector.orientation;
        ELSE
          mag2 := 1.0;
          vec2 := arg2;
        END_IF;
        vec1 := normalise (vec1);
        vec2 := normalise (vec2);
        ndim := SIZEOF(vec1.direction_ratios);
        mag := 0.0;
        res := dummy_gri || direction(vec1.direction_ratios);
        REPEAT i := 1 TO ndim;
          res.direction_ratios[i] := mag1*vec1.direction_ratios[i] -
                                      mag2*vec2.direction_ratios[i];
          mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
        END_REPEAT;
        IF (mag > 0.0 ) THEN
        result := dummy_gri || vector( res, SQRT(mag));
        ELSE
          result := dummy_gri || vector( vec1,  0.0);
        END_IF;
      END;
    END_IF;
    RETURN (result);
END_FUNCTION;

END_SCHEMA; 

